/* avatar-content.tsx generated by @compiled/babel-plugin v0.38.1 */
import _extends from "@babel/runtime/helpers/extends";
import "./avatar-content.compiled.css";
import * as React from 'react';
import { ax, ix } from "@compiled/react/runtime";
import { forwardRef } from 'react';
import { fg } from '@atlaskit/platform-feature-flags';
import { useAvatarContent, useEnsureIsInsideAvatar } from './context';
const boxShadowCssVar = '--avatar-box-shadow';
const bgColorCssVar = '--avatar-bg-color';
const styles = {
  root: "_19itglyw _12ji1r31 _1qu2glyw _12y31o36 _1reo15vq _18m915vq _v564ieh6 _1e0c1txw _kqswpfqs _4cvr1fhb _1bah1h6o _2lx21bp4 _80om1kw7 _6rthv77o _1pfhv77o _12l2v77o _ahbqv77o _85i5ze3t _1q51ze3t _y4tize3t _bozgze3t _t9ec1aqe _9v7aze3t _qc5o1p41 _z0ai1osq _18postnw _1hfk1j28 _aetrf705 _1peqidpf _11fnglyw _1ejjglyw _mizu194a _1ah3v77o _ra3xnqa1 _128mdkaa _4dave4h9",
  circle: "_2rko1qll _14mj1qll",
  square: "_2rkol0p1",
  positionRelative: "_kqswh2mm",
  disabled: "_80om13gf _1hfkvuon _1peqs237"
};
const unboundStyles = {
  root: "_vchh1ntv _bfhkcxp3 _16qs1nhn",
  hexagonFocusContainer: "_1rjc1wgn _18zr1dm9 _1mou5h37 _bfhk1j28 _mkrz1k6g _1o9o1v1w",
  hexagonBorderContainer: "_1rjcf6hp _18zruxly _bfhkcxp3 _mkrz1kw7 _1o9ovuon",
  hexagon: "_2rkoidpf _mkrz1kw7 _16qsn7od _14mjidpf _1ejjn7od _128midpf _4davidpf",
  interactive: "_80omtlke _4tpu1g4v _ez1ykb7n _gcm1182g _eeh8kb7n _jlxit94y"
};
const widthHeightMap = {
  xsmall: "_1bsb7vkz _4t3i7vkz",
  small: "_1bsb1tcg _4t3i1tcg",
  medium: "_1bsbzwfg _4t3izwfg",
  large: "_1bsb1ylp _4t3i1ylp",
  xlarge: "_1bsb16xz _4t3i16xz",
  xxlarge: "_1bsb1qr7 _4t3i1qr7"
};
const marginAdjustmentMap = {
  xsmall: "_195gcwjc",
  small: "_195gcwjc",
  medium: "_195gs7t4",
  large: "_195gs7t4",
  xlarge: "_195g8ocb",
  xxlarge: "_195g1ukp"
};
const borderRadiusMap = {
  xsmall: "_2rkolb4i _14mjlb4i",
  small: "_2rkolb4i _14mjlb4i",
  medium: "_2rko12b0 _14mj12b0",
  large: "_2rko12b0 _14mj12b0",
  xlarge: "_2rko1qi0 _14mj1qi0",
  xxlarge: "_2rkopb1k _14mjpb1k"
};
/**
 * __Avatar content__
 *
 * Avatar content renders the avatar content. It can be composed with the Avatar component
 * to create a custom avatar.
 *
 * - [Examples](https://atlassian.design/components/avatar/examples)
 * - [Code](https://atlassian.design/components/avatar/code)
 * - [Usage](https://atlassian.design/components/avatar/usage)
 */
export const AvatarContent = /*#__PURE__*/forwardRef(({
  children
}, ref) => {
  useEnsureIsInsideAvatar();
  const {
    as: Container,
    appearance,
    avatarImage,
    borderColor = "var(--ds-surface, #FFFFFF)",
    href,
    isDisabled,
    label,
    onClick,
    ref: contextRef,
    tabIndex,
    target,
    testId,
    size,
    stackIndex
  } = useAvatarContent();
  const isInteractive = Boolean(onClick || href || isDisabled);
  const renderedContent = /*#__PURE__*/React.createElement(Container, _extends({
    style: {
      [bgColorCssVar]: borderColor,
      [boxShadowCssVar]: `0 0 0 2px ${borderColor}`
    },
    ref: ref || contextRef,
    "aria-label": isInteractive ? label : undefined,
    onClick: onClick,
    tabIndex: tabIndex,
    "data-testid": testId,
    disabled: isDisabled,
    type: Container === 'button' ? 'button' : undefined
  }, href && {
    href,
    target,
    rel: target === '_blank' ? 'noopener noreferrer' : undefined
  }, {
    className: ax([unboundStyles.root, styles.root, !fg('platform_dst_avatar_tile') && !fg('platform_dst_avatar_tile_stage2') && borderRadiusMap[size], appearance === 'square' && (fg('platform_dst_avatar_tile') || fg('platform_dst_avatar_tile_stage2')) && styles.square, appearance === 'circle' && styles.circle, appearance === 'hexagon' && unboundStyles.hexagon, widthHeightMap[size], stackIndex !== undefined && styles.positionRelative, isInteractive && !isDisabled && unboundStyles.interactive, isDisabled && styles.disabled])
  }), children || avatarImage);
  if (appearance !== 'hexagon') {
    return renderedContent;
  }

  // For a Hexagon Avatar in order to have hexagonal "border" and "outline", we have to
  // layer multiple elements and use their background colors to create the different layers.
  return /*#__PURE__*/React.createElement("div", {
    style: {
      [bgColorCssVar]: borderColor,
      [boxShadowCssVar]: `0 0 0 2px ${borderColor}`
    },
    "data-testid": testId ? `${testId}-hexagon-focus-container` : 'hexagon-focus-container',
    className: ax([unboundStyles.hexagonFocusContainer, marginAdjustmentMap[size]])
  }, /*#__PURE__*/React.createElement("div", {
    "data-testid": testId ? `${testId}-hexagon-border-container` : 'hexagon-border-container',
    className: ax([unboundStyles.hexagonBorderContainer])
  }, renderedContent));
});