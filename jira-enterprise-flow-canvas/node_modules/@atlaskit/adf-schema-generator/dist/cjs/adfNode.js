"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ADFNode = void 0;
exports.adfNode = adfNode;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _base = /*#__PURE__*/new WeakMap();
var _spec = /*#__PURE__*/new WeakMap();
var _variant = /*#__PURE__*/new WeakMap();
var _variants = /*#__PURE__*/new WeakMap();
var _type = /*#__PURE__*/new WeakMap();
var _groups = /*#__PURE__*/new WeakMap();
var ADFNode = exports.ADFNode = /*#__PURE__*/function () {
  function ADFNode(type) {
    (0, _classCallCheck2.default)(this, ADFNode);
    _classPrivateFieldInitSpec(this, _base, null);
    _classPrivateFieldInitSpec(this, _spec, null);
    _classPrivateFieldInitSpec(this, _variant, null);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _classPrivateFieldInitSpec(this, _variants, new Map());
    _classPrivateFieldInitSpec(this, _type, void 0);
    _classPrivateFieldInitSpec(this, _groups, void 0);
    _classPrivateFieldSet(_type, this, type);
    _classPrivateFieldSet(_groups, this, []);
  }

  /**
   * Returns true if the node has been defined, e.g. node.define() method was called.
   */
  return (0, _createClass2.default)(ADFNode, [{
    key: "isDefined",
    value: function isDefined() {
      return !!_classPrivateFieldGet(_spec, this);
    }

    /**
     * Returns true if the node is a root node.
     * Which marks the top level of the DSL schema tree.
     */
  }, {
    key: "isRoot",
    value: function isRoot() {
      // @ts-expect-error
      return _classPrivateFieldGet(_spec, this).root;
    }

    /**
     * Checks whether the node is ignored by a given transformer.
     */
  }, {
    key: "isIgnored",
    value: function isIgnored(transformerName) {
      var _classPrivateFieldGet2;
      if (!_classPrivateFieldGet(_spec, this)) {
        throw new Error('Node is not defined');
      }
      return (_classPrivateFieldGet2 = _classPrivateFieldGet(_spec, this).ignore) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.includes(transformerName);
    }

    /**
     * If true, the node doesn't allow marks to be set.
     * This is stricter than simply having an empty marks list.
     */
  }, {
    key: "hasNoMarks",
    value: function hasNoMarks() {
      // @ts-expect-error
      return _classPrivateFieldGet(_spec, this).noMarks;
    }

    /**
     * Define a node.
     *
     * Assigns NodeSpec to the node. If node was not defined and can't be part of the schema tree.
     */
  }, {
    key: "define",
    value: function define(spec) {
      var _spec$marks;
      if (_classPrivateFieldGet(_spec, this)) {
        throw new Error('Cannot re-define a node');
      }
      _classPrivateFieldSet(_spec, this, spec);
      if (spec.noMarks && (_spec$marks = spec.marks) !== null && _spec$marks !== void 0 && _spec$marks.length) {
        throw new Error('Node with noMarks true has marks');
      }
      return this;
    }

    /**
     * Define a variant of the node.
     *
     * There is quite often a need to define a slightly different version of the node. E.g.:
     * - A feature flag to enable/disable a feature
     * - Stricter validation for a specific use case, like allowing certain marks on a top level node,
     *   and not allowing them on a nested variant of the same node.
     *
     * Variant allows for this use case.
     *
     * Each variant shallowly overrides the base node spec. And then can be used via node.use('variant_name') method.
     */
  }, {
    key: "variant",
    value: function variant(name, spec) {
      if (!_classPrivateFieldGet(_spec, this)) {
        throw new Error('Cannot define a variant if base was not defined');
      }
      if (_classPrivateFieldGet(_variant, this)) {
        throw new Error('Cannot create a variant of a variant');
      }

      // any – #variants are strictly typed and typescript is not happy about generic string
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      if (_classPrivateFieldGet(_variants, this).has(name)) {
        throw new Error("Variant \"".concat(name, "\" already exists"));
      }

      // This properties must not be inherited from the base node by the variant
      // as they can cause unexpected behavior.
      //
      // The purpose of this is to force people to manually clone these if needed.
      var NOT_INHERITED_PROPERTIES = ['DANGEROUS_MANUAL_OVERRIDE', 'hasEmptyMarks', 'stage0', 'noExtend'];
      var baseSpec = _objectSpread({}, _classPrivateFieldGet(_spec, this));
      for (var _i = 0, _NOT_INHERITED_PROPER = NOT_INHERITED_PROPERTIES; _i < _NOT_INHERITED_PROPER.length; _i++) {
        var prop = _NOT_INHERITED_PROPER[_i];
        if (prop in baseSpec) {
          // @ts-expect-error
          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
          delete baseSpec[prop];
        }
      }
      var newSpec = _objectSpread(_objectSpread({}, baseSpec), spec);
      var newAdfNode = new ADFNode(_classPrivateFieldGet(_type, this)).define(newSpec).setBase(this).setVariant(name);

      // any – #variants are strictly typed and typescript is not happy about generic string
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      _classPrivateFieldGet(_variants, this).set(name, newAdfNode);

      // any – since we are adding a new variant, the type of the base variant needs to be extended
      // with the new variant name, hence this doesn't match the return type,
      // type casting to any to make TS happy
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return this;
    }

    /**
     * Private method to set the base node. Used in variant creation so there is a link between the base and the variant.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  }, {
    key: "setBase",
    value: function setBase(base) {
      _classPrivateFieldSet(_base, this, base);
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return this;
    }

    /**
     * For a variant node, returns the base node from which the variant was created.
     */
  }, {
    key: "getBase",
    value: function getBase() {
      return _classPrivateFieldGet(_base, this);
    }
  }, {
    key: "getType",
    value: function getType() {
      return _classPrivateFieldGet(_type, this);
    }

    /**
     * A full name of the node which includes node type and variant name.
     */
  }, {
    key: "getName",
    value: function getName() {
      var stage0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var stage0Suffix = stage0 && this.hasStage0() ? '_stage0' : '';
      if (_classPrivateFieldGet(_variant, this)) {
        return "".concat(_classPrivateFieldGet(_type, this), "_").concat(_classPrivateFieldGet(_variant, this)).concat(stage0Suffix);
      }
      return "".concat(_classPrivateFieldGet(_type, this)).concat(stage0Suffix);
    }
  }, {
    key: "getSpec",
    value: function getSpec() {
      var stage0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (stage0 && this.hasStage0()) {
        var _classPrivateFieldGet3, _classPrivateFieldGet4;
        return _objectSpread(_objectSpread({}, _classPrivateFieldGet(_spec, this)), ((_classPrivateFieldGet3 = _classPrivateFieldGet(_spec, this)) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.stage0) === true ? {} : (_classPrivateFieldGet4 = _classPrivateFieldGet(_spec, this)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.stage0);
      }
      return _classPrivateFieldGet(_spec, this);
    }

    /**
     * Return true if the node has a stage0 spec.
     * It's true for both cases:
     * - full node stage 0
     * - partial stage 0 override for a node
     */
  }, {
    key: "hasStage0",
    value: function hasStage0() {
      var _classPrivateFieldGet5;
      return !!((_classPrivateFieldGet5 = _classPrivateFieldGet(_spec, this)) !== null && _classPrivateFieldGet5 !== void 0 && _classPrivateFieldGet5.stage0);
    }

    /**
     * Return true if the node is stage0 only.
     */
  }, {
    key: "isStage0Only",
    value: function isStage0Only() {
      var _classPrivateFieldGet6;
      return ((_classPrivateFieldGet6 = _classPrivateFieldGet(_spec, this)) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.stage0) === true;
    }
  }, {
    key: "getMarks",
    value: function getMarks() {
      var _this$getSpec$marks, _this$getSpec;
      var stage0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return (_this$getSpec$marks = (_this$getSpec = this.getSpec(stage0)) === null || _this$getSpec === void 0 ? void 0 : _this$getSpec.marks) !== null && _this$getSpec$marks !== void 0 ? _this$getSpec$marks : [];
    }
  }, {
    key: "getMarksTypes",
    value: function getMarksTypes() {
      var stage0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return this.getMarks(stage0).map(function (mark) {
        return mark.getType();
      });
    }

    /**
     * Returns the name of the variant.
     */
  }, {
    key: "getVariant",
    value: function getVariant() {
      return _classPrivateFieldGet(_variant, this) || 'base';
    }

    /**
     * Returns all variants of the node.
     */
  }, {
    key: "getVariants",
    value: function getVariants() {
      return _classPrivateFieldGet(_variants, this);
    }

    /**
     * Returns true if variant has attributes that don't match base spec.
     */
  }, {
    key: "hasAttributeOverride",
    value: function hasAttributeOverride() {
      if (this.getVariant() === 'base') {
        return false;
      }
      // @ts-expect-error
      return _classPrivateFieldGet(_spec, this).attrs !== _classPrivateFieldGet(_base, this).getSpec().attrs;
    }

    /**
     * Private method to set the variant name. Used when creating a variant.
     */
  }, {
    key: "setVariant",
    value: function setVariant(variant) {
      _classPrivateFieldSet(_variant, this, variant);
      return this;
    }
  }, {
    key: "use",
    value: function use(variantName) {
      if (!_classPrivateFieldGet(_variants, this).has(variantName)) {
        throw new Error("Variant \"".concat(variantName, "\" does not exist"));
      }
      // cast to ADFNode as we know it exists due to the has() check above and we always set an ADFNode in the map
      return _classPrivateFieldGet(_variants, this).get(variantName);
    }
  }, {
    key: "setGroup",
    value: function setGroup(group) {
      if (!_classPrivateFieldGet(_groups, this).includes(group)) {
        _classPrivateFieldGet(_groups, this).push(group);
      }
      return this;
    }
  }, {
    key: "getGroups",
    value: function getGroups() {
      return _classPrivateFieldGet(_groups, this);
    }
  }]);
}();
function adfNode(type) {
  return new ADFNode(type);
}

// Filter out string type from allowed keys
// Before:
// type T = string | 'hello' | 'world';
// After:
// type T = 'hello' | 'world';