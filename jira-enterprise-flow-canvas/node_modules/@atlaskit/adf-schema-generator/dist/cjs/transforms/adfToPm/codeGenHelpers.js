"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertTypeToTypeName = exports.buildADFAttributesTypes = exports._type = exports._namedTypeImport = exports._namedImport = exports._interface = exports._functionCallToVariable = exports._codeBlock = void 0;
exports.stringifyWithUndefined = stringifyWithUndefined;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _capitalize = require("../../utils/capitalize");
var convertTypeToTypeName = exports.convertTypeToTypeName = function convertTypeToTypeName(type) {
  var suffix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Definition';
  return "".concat(type.split('_').map(_capitalize.capitalize).join('')).concat(suffix);
};
var _codeBlock = exports._codeBlock = function _codeBlock() {
  for (var _len = arguments.length, blocks = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    blocks[_key2] = arguments[_key2];
  }
  return blocks.filter(function (b) {
    return b !== '';
  }).join('\n\n');
};
function escape(str) {
  // handle special characters: \n
  return str.replace(/\n/g, '\\n');
}
var buildADFAttributesType = function buildADFAttributesType(attrKey, attrValue) {
  var key = "".concat(attrKey).concat(attrValue.optional ? '?' : '');
  switch (attrValue.type) {
    case 'string':
    case 'number':
    case 'boolean':
      return ["".concat(key, ": ").concat(attrValue.type)];
    case 'enum':
      return ["".concat(key, ": ").concat(attrValue.values.map(function (v) {
        return "\"".concat(escape(v), "\"");
      }).join('|'))];
    case 'array':
      return ["".concat(key, ": Array<").concat(attrValue.items.type, ">")];
    case 'object':
      return ["".concat(key, ": Record<string, unknown>")];
    default:
      throw new Error("Unknown type for \"".concat(attrKey, "\". ADF Attributes must have a type defined in the DSL."));
  }
};
var buildADFAttributesTypes = exports.buildADFAttributesTypes = function buildADFAttributesTypes(attrs) {
  return Object.entries(attrs).flatMap(function (_ref) {
    var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
      attrKey = _ref2[0],
      attrValue = _ref2[1];
    return buildADFAttributesType(attrKey, attrValue);
  });
};
var _interface = exports._interface = function _interface(name, body) {
  return "export interface ".concat(name, " {").concat(body, "}");
};
var _type = exports._type = function _type(name, body) {
  return "export type ".concat(name, " = ").concat(body);
};
var _functionCallToVariable = exports._functionCallToVariable = function _functionCallToVariable(variableName, functionName, args) {
  return "export const ".concat(variableName, " = ").concat(functionName, "(").concat(args.join(','), ")");
};
var _namedImport = exports._namedImport = function _namedImport(pkg) {
  for (var _len2 = arguments.length, names = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
    names[_key3 - 1] = arguments[_key3];
  }
  return "import { ".concat(names.join(', '), " } from '").concat(pkg, "'");
};
var _namedTypeImport = exports._namedTypeImport = function _namedTypeImport(pkg) {
  for (var _len3 = arguments.length, names = new Array(_len3 > 1 ? _len3 - 1 : 0), _key4 = 1; _key4 < _len3; _key4++) {
    names[_key4 - 1] = arguments[_key4];
  }
  return "import type { ".concat(names.join(', '), " } from '").concat(pkg, "'");
};

/**
 * This helper function is used to keep undefined in the generated code,
 * because JSON.stringify will strip out undefined key-value pair by default.
 * @param obj object
 * @returns
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function stringifyWithUndefined(obj) {
  return JSON.stringify(obj, function (_key, value) {
    return value !== undefined ? value : 'undefined';
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  }).replace(/"undefined"/g, undefined);
}