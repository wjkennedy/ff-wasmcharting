"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adfToPm = adfToPm;
exports.transform = transform;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _traverse = require("../../traverse");
var _pmNodeGroupsCodeGen = require("./pmNodeGroupsCodeGen");
var _pmNodesCodeGen = require("./pmNodesCodeGen");
var _pmMarksCodeGen = require("./pmMarksCodeGen");
var _buildPmSpec = require("./buildPmSpec");
var _buildContentExpression = require("./buildContentExpression");
var _buildPmNodeTypes = require("./buildPmNodeTypes");
var _transformerNames = require("../transformerNames");
var _pseudoGroups = require("./pseudoGroups");
var _getNodeNames = require("./getNodeNames");
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function isNodeReturnValue(value) {
  return value && 'node' in value;
}
function isGroupReturnValue(value) {
  return value && 'group' in value;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function transform(adf) {
  var nodeResMap = {};
  var markResMap = {};
  var nodeGroupMap = {};
  var ignoredGroups = new Set(Array.from(_pseudoGroups.PSEUDO_GROUPS));
  (0, _traverse.traverse)(adf, {
    node: function node(_node, content, cycle) {
      if (_node.isIgnored(_transformerNames.PMSpecTransformerName)) {
        return undefined;
      }
      function processNode(node) {
        var stage0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var nodeName = node.getName(stage0);
        var nodeSpec = node.getSpec(stage0);
        var marks = node.getMarks(stage0);

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        marks.forEach(function (mark) {
          if (!markResMap[mark.getType()]) {
            markResMap[mark.getType()] = {
              mark: mark,
              pmMarkSpec: (0, _buildPmSpec.buildMarkSpec)(mark)
            };
          }
        });
        if (!cycle) {
          var _nodeSpec$marks$map, _nodeSpec$marks;
          nodeResMap[nodeName] = {
            pmNodeSpec: (0, _buildPmSpec.buildNodeSpec)(node.getType(), nodeSpec, node.getGroups(), content),
            nodeTypeDefinition: (0, _buildPmNodeTypes.buildNodeTypeDefinition)(nodeSpec, node.getType(), (_nodeSpec$marks$map = (_nodeSpec$marks = nodeSpec.marks) === null || _nodeSpec$marks === void 0 ? void 0 : _nodeSpec$marks.map(function (m) {
              return m.getType();
            })) !== null && _nodeSpec$marks$map !== void 0 ? _nodeSpec$marks$map : [], content)
          };
        }
      }
      if (_node.isStage0Only()) {
        // Entire node is stage0
        processNode(_node, true);
      } else {
        // Partial override of node spec in stage0
        if (_node.hasStage0()) {
          processNode(_node, true);
        }

        // In case of partial override, need to generate node spec for base node as well
        processNode(_node);
      }
      return {
        node: _node
      };
    },
    group: function group(_group, members) {
      if (_group.isIgnored(_transformerNames.PMSpecTransformerName)) {
        ignoredGroups.add(_group.group);
        return undefined;
      }
      nodeGroupMap[_group.group] = _group.members.filter(function (node) {
        return !node.isIgnored(_transformerNames.PMSpecTransformerName);
      }).flatMap(function (node) {
        return (0, _getNodeNames.getNodeNames)(node);
      });
      return {
        group: _group.group,
        members: members.filter(function (m) {
          return m && !m.node.isIgnored(_transformerNames.PMSpecTransformerName);
        })
      };
    },
    $or: function $or(children) {
      var expr = [];
      var marks = new Set();
      var contentTypes = [];
      var _iterator = _createForOfIteratorHelper(children),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var child = _step.value;
          if (isGroupReturnValue(child)) {
            /**
             * Flatten pseudo groups
             */
            if (_pseudoGroups.PSEUDO_GROUPS.has(child.group)) {
              var _iterator2 = _createForOfIteratorHelper(child.members),
                _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var member = _step2.value;
                  expr.push(member.node.getType());
                  contentTypes.push.apply(contentTypes, (0, _toConsumableArray2.default)((0, _getNodeNames.getNodeNames)(member.node)));
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            } else {
              expr.push(child.group);
            }
            // only include content types if group has members
            // e.g. blockRootOnly don't have members, so won't be included in contentTypes of doc
            if (child.members && child.members.length > 0 && !_pseudoGroups.PSEUDO_GROUPS.has(child.group)) {
              contentTypes.push(child.group);
            }
            var _iterator3 = _createForOfIteratorHelper(child.members),
              _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var _member = _step3.value;
                var _iterator4 = _createForOfIteratorHelper(_member.node.getMarksTypes()),
                  _step4;
                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                    var _mark = _step4.value;
                    marks.add(_mark);
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }
                if (_member.node.hasStage0()) {
                  var _iterator5 = _createForOfIteratorHelper(_member.node.getMarksTypes(true)),
                    _step5;
                  try {
                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                      var mark = _step5.value;
                      marks.add(mark);
                    }
                  } catch (err) {
                    _iterator5.e(err);
                  } finally {
                    _iterator5.f();
                  }
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          } else if (isNodeReturnValue(child)) {
            expr.push(child.node.getType());
            contentTypes.push.apply(contentTypes, (0, _toConsumableArray2.default)((0, _getNodeNames.getNodeNames)(child.node)));
            if (child.node.getMarks().length) {
              var _iterator6 = _createForOfIteratorHelper(child.node.getMarksTypes()),
                _step6;
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  var _mark2 = _step6.value;
                  marks.add(_mark2);
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            }
            if (child.node.hasStage0()) {
              var _iterator7 = _createForOfIteratorHelper(child.node.getMarksTypes(true)),
                _step7;
              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  var _mark3 = _step7.value;
                  marks.add(_mark3);
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return {
        expr: expr,
        marks: Array.from(marks),
        contentTypes: contentTypes
      };
    },
    $onePlus: function $onePlus(child) {
      return {
        // PM Spec does not have concept of variants, so we will have duplicate content types
        expr: [(0, _buildContentExpression.buildContentExpression)(Array.from(new Set(child.expr)), '+')],
        marks: child.marks,
        contentTypes: child.contentTypes
      };
    },
    $zeroPlus: function $zeroPlus(child) {
      return {
        // PM Spec does not have concept of variants, so we will have duplicate content types
        expr: [(0, _buildContentExpression.buildContentExpression)(Array.from(new Set(child.expr)), '*')],
        marks: child.marks,
        contentTypes: child.contentTypes
      };
    },
    $range: function $range(item, child) {
      return {
        // PM Spec does not have concept of variants, so we will have duplicate content types
        expr: [(0, _buildContentExpression.buildContentExpression)(Array.from(new Set(child.expr)), "{".concat(item.min, ",").concat(item.max, "}"))],
        marks: child.marks,
        contentTypes: child.contentTypes
      };
    }
  });

  /**
   * Remove ignored groups from nodeSpecRes.
   */
  for (var _i = 0, _Object$values = Object.values(nodeResMap); _i < _Object$values.length; _i++) {
    var _nodeSpecRes$pmNodeSp;
    var nodeSpecRes = _Object$values[_i];
    if (!nodeSpecRes.pmNodeSpec.group) {
      continue;
    }
    nodeSpecRes.pmNodeSpec.group = ((_nodeSpecRes$pmNodeSp = nodeSpecRes.pmNodeSpec.group.split(' ')) !== null && _nodeSpecRes$pmNodeSp !== void 0 ? _nodeSpecRes$pmNodeSp : []).filter(function (group) {
      return !ignoredGroups.has(group);
    }).join(' ');
    if (!nodeSpecRes.pmNodeSpec.group) {
      delete nodeSpecRes.pmNodeSpec.group;
    }
  }
  return {
    nodeGroupMap: nodeGroupMap,
    markResMap: markResMap,
    nodeResMap: nodeResMap
  };
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function adfToPm(adfNode) {
  try {
    var _transform = transform(adfNode),
      nodeGroupMap = _transform.nodeGroupMap,
      markResMap = _transform.markResMap,
      nodeResMap = _transform.nodeResMap;
    return {
      pmNodeGroups: (0, _pmNodeGroupsCodeGen.pmNodeGroupsCodeGen)(nodeGroupMap),
      pmMarks: (0, _pmMarksCodeGen.pmMarksCodeGen)(markResMap),
      pmNodes: (0, _pmNodesCodeGen.pmNodesCodeGen)(nodeResMap)
    };
  } catch (e) {
    // eslint-disable-next-line no-console
    console.error(e);
  }
}