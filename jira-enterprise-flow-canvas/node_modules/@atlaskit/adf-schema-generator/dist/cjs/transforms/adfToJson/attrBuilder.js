"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildAttrs = buildAttrs;
exports.buildAttrsSet = buildAttrsSet;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _isAnyOf = require("../../utils/isAnyOf");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function buildAttrs(nodeAttrs) {
  if (!nodeAttrs || Object.keys(nodeAttrs).length === 0) {
    return {};
  }
  return {
    attrs: buildAttributesMap(nodeAttrs)
  };
}
function buildAttributesMap(nodeAttrs) {
  // If anyOf, we need account for each item in the "anyOf" list
  if (nodeAttrs && (0, _isAnyOf.isAnyOf)(nodeAttrs)) {
    var anyOfAttrsSets = [];
    nodeAttrs.anyOf.forEach(function (attrsSet) {
      anyOfAttrsSets.push(buildAttrsSet(attrsSet));
    });
    return {
      anyOf: anyOfAttrsSets
    };
  }
  return buildAttrsSet(nodeAttrs);
}
function buildAttrsSet(attrsSet) {
  var jsonAttrs = {};
  var required = [];
  Object.entries(attrsSet).forEach(function (_ref) {
    var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
      key = _ref2[0],
      attr = _ref2[1];
    // Make a copy so we don't change the original attribute
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var builtAttr = _objectSpread({}, attr);

    // Attributes starting with underscores are omitted from the JSON Schema
    if (key[0] === '_') {
      return;
    }
    if (!attr.optional) {
      required.push(key);
    }
    if (builtAttr.type === 'object' && builtAttr.properties) {
      builtAttr.properties = buildAttributesMap(builtAttr.properties).properties;
    }
    if (attr.type === 'array' && attr.items.type === 'object' && attr.items.properties) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      builtAttr.items = buildAttributesMap(attr.items.properties);
    }

    // Enum formatting is different in the JSON Schema
    if (builtAttr.type === 'enum') {
      delete builtAttr.type;
      builtAttr['enum'] = builtAttr.values;
      delete builtAttr.values;
    }
    // "validatorFn" is a specific property for the validator only
    // See: https://product-fabric.atlassian.net/wiki/spaces/CPMT/pages/2973303550/ADF+Change+58+bring+back+url+and+link+validation
    else if (builtAttr.type === 'string') {
      delete builtAttr.validatorFn;
    }
    delete builtAttr.optional;
    delete builtAttr.default;

    // Data and parameters attrs do not have type in JSON Schema
    // This also applies for an empty properties object. The general pattern is to return an empty object.
    if (builtAttr.type === 'object' && Object.keys(builtAttr).length === 1) {
      delete builtAttr.type;
    }
    jsonAttrs[key] = builtAttr;
  });
  var json = {
    type: 'object',
    properties: jsonAttrs,
    required: required,
    additionalProperties: false
  };

  // delete required entry if there are no required fields
  if (required.length === 0) {
    delete json.required;
  }
  return json;
}