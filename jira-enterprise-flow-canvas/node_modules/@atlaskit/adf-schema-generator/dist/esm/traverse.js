function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
import { ADFNode } from './adfNode';
/**
 * Implements post-order traversal of an ADF DSL tree.
 *
 * Traverse accepts a root node of the ADF DSL tree and a visitor object.
 * Visitor is a pattern that is commonly used in tree traversal algorithms.
 * It allows to separate the traversal logic from the actual processing logic.
 *
 * The visitor object should have the following methods:
 * - node(node, children, cycle) - called for each node in the tree
 *   - node - the node being visited
 *   - children - an array of processed children of the node
 *   - cycle - a flag indicating that the node is being visited again due to a cycle
 * - group(group, nodes) - called for each group in the tree
 *   - group - the group being visited
 *   - nodes - an array of processed nodes in the group
 * - $or(content) - called for each $or content in the tree
 *   - content - an array of processed nodes or groups
 * - $onePlus(content) - called for each $one+ content in the tree
 *   - content - the processed content
 * - $zeroPlus(content) - called for each $zero+ content in the tree
 *   - content - the processed content
 * - $range(item, content) - called for each $range content in the tree
 *   - item - the range content item, includes the range metadata â€“ min and max
 *   - content - the processed content
 *
 * How does it deal with cycles?
 *
 * In order to deal with cyclic structure we stop processing children if the node was seen before.
 * That allows us to still return something meaningful to a parent node without falling into a cycle.
 *
 * Example usage:
 * const doc = adfNode('doc').definine({root: true});
 *
 * traverse(doc, {
 *    node(node, children) {},
 *    group(group, nodes) {},
 *    $or(content) {},
 *    $onePlus(content) {},
 *    $zeroPlus(content) {},
 *    $range(item, content) {},
 * })
 */
export function traverse(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
node, visitor) {
  var visited = new Set();
  if (!node.isRoot()) {
    // eslint-disable-next-line no-console
    console.log('root', node.getSpec());
    throw new Error("Cannot start traverse from a node that is not a root node. Node type: ".concat(node.getType()));
  }
  traverseNode(node, visitor, visited);
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function traverseNode(node, visitor, visited) {
  var _node$getSpec, _visitor$node2;
  if (visited.has(node.getName())) {
    var _visitor$node;
    // in order to break a cycle, once we visit the same node again,
    // we are then just processing the node itself, without its children
    // also we are passing a cycle flag to the visitor, so the logic can be adjusted accordingly
    return visitor === null || visitor === void 0 || (_visitor$node = visitor.node) === null || _visitor$node === void 0 ? void 0 : _visitor$node.call(visitor, node, [], true);
  }
  if (!node.isDefined()) {
    throw new Error("Cannot traverse a node that was not defined, call node.define(spec) first. Node type: ".concat(node.getType()));
  }
  var children = [];
  visited.add(node.getName());
  if ((_node$getSpec = node.getSpec()) !== null && _node$getSpec !== void 0 && _node$getSpec.content) {
    var _node$getSpec$content, _node$getSpec2;
    var _iterator = _createForOfIteratorHelper((_node$getSpec$content = (_node$getSpec2 = node.getSpec()) === null || _node$getSpec2 === void 0 ? void 0 : _node$getSpec2.content) !== null && _node$getSpec$content !== void 0 ? _node$getSpec$content : []),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var child = _step.value;
        children.push(traverseNodeContent(child, visitor, visited));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  return visitor === null || visitor === void 0 || (_visitor$node2 = visitor.node) === null || _visitor$node2 === void 0 ? void 0 : _visitor$node2.call(visitor, node, children);
}
function traverseNodeContent(item, visitor, visited) {
  if (item.type === '$or' && Array.isArray(item.content)) {
    var _visitor$$or;
    var children = [];
    var _iterator2 = _createForOfIteratorHelper(item.content),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var child = _step2.value;
        if (child instanceof ADFNode) {
          children.push(traverseNode(child, visitor, visited));
        } else {
          children.push(traverseGroup(child, visitor, visited));
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return (_visitor$$or = visitor.$or) === null || _visitor$$or === void 0 ? void 0 : _visitor$$or.call(visitor, children);
  }
  if (!Array.isArray(item.content)) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var _child = traverseNodeContent(item.content, visitor, visited);
    if (item.type === '$one+') {
      var _visitor$$onePlus;
      return visitor === null || visitor === void 0 || (_visitor$$onePlus = visitor.$onePlus) === null || _visitor$$onePlus === void 0 ? void 0 : _visitor$$onePlus.call(visitor, _child);
    }
    if (item.type === '$zero+') {
      var _visitor$$zeroPlus;
      return visitor === null || visitor === void 0 || (_visitor$$zeroPlus = visitor.$zeroPlus) === null || _visitor$$zeroPlus === void 0 ? void 0 : _visitor$$zeroPlus.call(visitor, _child);
    }
    if (item.type === '$range') {
      var _visitor$$range;
      return visitor === null || visitor === void 0 || (_visitor$$range = visitor.$range) === null || _visitor$$range === void 0 ? void 0 : _visitor$$range.call(visitor, item, _child);
    }
  }
}
function traverseGroup(group, visitor, visited) {
  var _visitor$group;
  var children = [];
  var _iterator3 = _createForOfIteratorHelper(group.members),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var child = _step3.value;
      if (child instanceof ADFNode) {
        children.push(traverseNode(child, visitor, visited));
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return visitor === null || visitor === void 0 || (_visitor$group = visitor.group) === null || _visitor$group === void 0 ? void 0 : _visitor$group.call(visitor, group, children);
}