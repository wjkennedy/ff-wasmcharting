import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import camelCase from 'lodash/camelCase';
import { _codeBlock, _functionCallToVariable, _interface, _namedImport, _namedTypeImport, _type, buildADFAttributesTypes, convertTypeToTypeName, stringifyWithUndefined } from './codeGenHelpers';
import { isAnyOf } from '../../utils/isAnyOf';
import { adfToPmAutogeneratedMessage } from './adfToPmAutogeneratedMessage';
import { objectToSortedArray } from './objectToSortedArray';
export var _nodeInterfaces = function _nodeInterfaces(nodeName, nodeTypeDefinitionName, nodeTypeDefinition) {
  var _nodeTypeDefinition$c, _nodeTypeDefinition$m, _nodeTypeDefinition$a;
  var additionalAttributeTypes = [];
  var _attrs = function _attrs(name, attrs) {
    if (!attrs || !Object.keys(attrs).length) {
      return null;
    }
    return "".concat(name, ": {").concat(buildADFAttributesTypes(attrs).join(';'), "},");
  };
  var _anyOfAttrs = function _anyOfAttrs(name, anyOf) {
    if (!anyOf) {
      return null;
    }
    var additionalAttributeName = function additionalAttributeName(index) {
      return "".concat(nodeName, "Attributes").concat(index);
    };
    anyOf.forEach(function (attr, index) {
      additionalAttributeTypes.push(_interface(additionalAttributeName(index), buildADFAttributesTypes(attr).join(';')));
    });
    return "".concat(name, ": ").concat(anyOf.map(function (_, index) {
      return additionalAttributeName(index);
    }).join('|'));
  };
  var _string = function _string(name, value) {
    if (!value) {
      return null;
    }
    return "".concat(name, ": '").concat(value, "'");
  };
  var _contentTypes = function _contentTypes(name, value) {
    if (!value || value.length === 0) {
      return null;
    }
    var types = value.map(function (v) {
      return convertTypeToTypeName(v, '');
    });
    return "".concat(name, ": Array<").concat(types.sort().join('|'), ">");
  };
  var _nodeMarks = function _nodeMarks(name, value) {
    if (!value || value.length === 0) {
      return null;
    }
    return "".concat(name, ": Array<").concat(value.sort().join('|'), ">");
  };
  var type = _string('type', nodeTypeDefinition.type);
  var content = _contentTypes('content', (_nodeTypeDefinition$c = nodeTypeDefinition.content) !== null && _nodeTypeDefinition$c !== void 0 ? _nodeTypeDefinition$c : []);
  var marks = _nodeMarks('marks', (_nodeTypeDefinition$m = nodeTypeDefinition.marks) !== null && _nodeTypeDefinition$m !== void 0 ? _nodeTypeDefinition$m : []);
  var attrs = isAnyOf(nodeTypeDefinition.attrs) ? _anyOfAttrs('attrs', (_nodeTypeDefinition$a = nodeTypeDefinition.attrs) === null || _nodeTypeDefinition$a === void 0 ? void 0 : _nodeTypeDefinition$a.anyOf) : _attrs('attrs', nodeTypeDefinition.attrs);
  var body = [type, content, marks, attrs].filter(function (v) {
    return !!v;
  }).join(',');
  return [].concat(additionalAttributeTypes, [_interface(nodeTypeDefinitionName, body), _type(nodeName, "PMNode & ".concat(nodeTypeDefinitionName))]).join('\n\n');
};
export var buildNodeMarksForImport = function buildNodeMarksForImport(nodeResMap) {
  var markTypes = [];
  Object.values(nodeResMap).forEach(function (_ref) {
    var marks = _ref.nodeTypeDefinition.marks;
    markTypes.push.apply(markTypes, _toConsumableArray(marks !== null && marks !== void 0 ? marks : []));
  });
  return _toConsumableArray(new Set(markTypes));
};
export function pmNodesCodeGen(nodeResMap) {
  return _codeBlock(adfToPmAutogeneratedMessage, _namedImport('../../schema/createPMSpecFactory', 'createPMNodeSpecFactory'), _namedTypeImport('@atlaskit/editor-prosemirror/model', 'Node as PMNode'), _namedTypeImport.apply(void 0, ['./nodeGroupTypes'].concat(['InlineDefinition', 'BlockDefinition', 'BlockRootOnlyDefinition'])), _namedTypeImport.apply(void 0, ['./markTypes'].concat(_toConsumableArray(buildNodeMarksForImport(nodeResMap).sort()))), objectToSortedArray(nodeResMap).map(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
      key = _ref3[0],
      _ref3$ = _ref3[1],
      nodeTypeDefinition = _ref3$.nodeTypeDefinition,
      pmNodeSpec = _ref3$.pmNodeSpec;
    var functionName = camelCase(key);
    var nodeName = convertTypeToTypeName(key, 'Node');
    var nodeTypeDefinitionName = convertTypeToTypeName(key, 'Definition');
    return _codeBlock(
    // build node types
    _nodeInterfaces(nodeName, nodeTypeDefinitionName, nodeTypeDefinition),
    // build node speec
    _functionCallToVariable(functionName, "createPMNodeSpecFactory<".concat(nodeName, ">"), [stringifyWithUndefined(pmNodeSpec)]));
  }).join('\n\n'));
}