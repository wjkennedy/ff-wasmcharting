import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { capitalize } from '../../utils/capitalize';
export var convertTypeToTypeName = function convertTypeToTypeName(type) {
  var suffix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Definition';
  return "".concat(type.split('_').map(capitalize).join('')).concat(suffix);
};
export var _codeBlock = function _codeBlock() {
  for (var _len = arguments.length, blocks = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    blocks[_key2] = arguments[_key2];
  }
  return blocks.filter(function (b) {
    return b !== '';
  }).join('\n\n');
};
function escape(str) {
  // handle special characters: \n
  return str.replace(/\n/g, '\\n');
}
var buildADFAttributesType = function buildADFAttributesType(attrKey, attrValue) {
  var key = "".concat(attrKey).concat(attrValue.optional ? '?' : '');
  switch (attrValue.type) {
    case 'string':
    case 'number':
    case 'boolean':
      return ["".concat(key, ": ").concat(attrValue.type)];
    case 'enum':
      return ["".concat(key, ": ").concat(attrValue.values.map(function (v) {
        return "\"".concat(escape(v), "\"");
      }).join('|'))];
    case 'array':
      return ["".concat(key, ": Array<").concat(attrValue.items.type, ">")];
    case 'object':
      return ["".concat(key, ": Record<string, unknown>")];
    default:
      throw new Error("Unknown type for \"".concat(attrKey, "\". ADF Attributes must have a type defined in the DSL."));
  }
};
export var buildADFAttributesTypes = function buildADFAttributesTypes(attrs) {
  return Object.entries(attrs).flatMap(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      attrKey = _ref2[0],
      attrValue = _ref2[1];
    return buildADFAttributesType(attrKey, attrValue);
  });
};
export var _interface = function _interface(name, body) {
  return "export interface ".concat(name, " {").concat(body, "}");
};
export var _type = function _type(name, body) {
  return "export type ".concat(name, " = ").concat(body);
};
export var _functionCallToVariable = function _functionCallToVariable(variableName, functionName, args) {
  return "export const ".concat(variableName, " = ").concat(functionName, "(").concat(args.join(','), ")");
};
export var _namedImport = function _namedImport(pkg) {
  for (var _len2 = arguments.length, names = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
    names[_key3 - 1] = arguments[_key3];
  }
  return "import { ".concat(names.join(', '), " } from '").concat(pkg, "'");
};
export var _namedTypeImport = function _namedTypeImport(pkg) {
  for (var _len3 = arguments.length, names = new Array(_len3 > 1 ? _len3 - 1 : 0), _key4 = 1; _key4 < _len3; _key4++) {
    names[_key4 - 1] = arguments[_key4];
  }
  return "import type { ".concat(names.join(', '), " } from '").concat(pkg, "'");
};

/**
 * This helper function is used to keep undefined in the generated code,
 * because JSON.stringify will strip out undefined key-value pair by default.
 * @param obj object
 * @returns
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function stringifyWithUndefined(obj) {
  return JSON.stringify(obj, function (_key, value) {
    return value !== undefined ? value : 'undefined';
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  }).replace(/"undefined"/g, undefined);
}