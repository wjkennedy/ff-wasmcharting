import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
import unset from 'lodash/unset';
import set from 'lodash/set';
import has from 'lodash/has';
import { traverse } from '../../traverse';
import { ValidatorSpecTransformerName } from '../transformerNames';
import { buildAttrs } from './buildAttrs';
import { buildContent } from './buildContent';
import { buildMarks } from './buildMarks';
function isNodeReturnValue(value) {
  return value && 'node' in value;
}
function isGroupReturnValue(value) {
  return value && 'group' in value;
}
function transform(adf) {
  var result = {};
  traverse(adf, buildVisitor(result, buildNode));
  var formattedResult = {};
  Object.entries(result).sort(function (_ref, _ref2) {
    var _ref3 = _slicedToArray(_ref, 1),
      keyA = _ref3[0];
    var _ref4 = _slicedToArray(_ref2, 1),
      keyB = _ref4[0];
    return keyA.localeCompare(keyB);
  }).forEach(function (_ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
      key = _ref6[0],
      value = _ref6[1];
    formattedResult[key] = value;
  });
  return formattedResult;
}
export function adfToValidatorSpec(adf) {
  return transform(adf);
}
export var buildNode = function buildNode(node, content) {
  var _base$getSpec, _node$getSpec$DANGERO;
  var json = {
    props: {}
  };
  var base = node.getBase();
  var isBaseVariant = !base;
  var baseSpec = (_base$getSpec = base === null || base === void 0 ? void 0 : base.getSpec()) !== null && _base$getSpec !== void 0 ? _base$getSpec : {};
  var nodeSpec = node.getSpec(node.hasStage0());
  var nodeType = node.getType();

  // Only base variant has type
  if (isBaseVariant) {
    json.props.type = {
      type: 'enum',
      values: [nodeType]
    };
  }
  if (nodeSpec.attrs !== baseSpec.attrs && nodeSpec.attrs && Object.keys(nodeSpec.attrs).length > 0) {
    json.props.attrs = buildAttrs(nodeSpec.attrs);
    if (nodeSpec.attrs.anyOf) {
      json.required = ['attrs'];
    }
  }

  // Text is a special node in PM and it has a text property
  if (node.getName() === 'text') {
    json.props.text = {
      type: 'string',
      minLength: 1
    };
  }
  if (nodeSpec.version) {
    json.props.version = {
      type: 'enum',
      values: [nodeSpec.version]
    };
  }
  if (content.length && nodeSpec.content !== baseSpec.content) {
    json.props.content = buildContent(node, content);
  }
  if (nodeSpec.marks !== baseSpec.marks) {
    var _nodeSpec$marks;
    var marks = buildMarks((_nodeSpec$marks = nodeSpec.marks) !== null && _nodeSpec$marks !== void 0 ? _nodeSpec$marks : [], nodeSpec.noMarks, nodeSpec.hasEmptyMarks);
    if (marks) {
      json.props.marks = marks;
    }
  }
  var overrides = ((_node$getSpec$DANGERO = node.getSpec().DANGEROUS_MANUAL_OVERRIDE) === null || _node$getSpec$DANGERO === void 0 ? void 0 : _node$getSpec$DANGERO['validator-spec']) || {};
  for (var _i = 0, _Object$entries = Object.entries(overrides); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      key = _Object$entries$_i[0],
      override = _Object$entries$_i[1];
    if (override.remove) {
      if (!has(json, key)) {
        throw new Error("Cannot delete non-existing property: ".concat(key, " for node ").concat(node.getName()));
      }
      unset(json, key);
    } else {
      set(json, key, override.value);
    }
  }
  var customJson = applyCompatibilityExceptions(node, json, content);
  if (customJson) {
    return customJson;
  }

  // In validator spec if it's not a base variant,
  // the spec extends the base variant.
  // Which is represented as ['base_variant_name', {...variant_specific_spec}]
  if (!isBaseVariant) {
    return [base.getName(), json];
  }
  return json;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
var buildMarkValidatorSpec = function buildMarkValidatorSpec(mark) {
  var json = {
    props: {}
  };
  var markSpec = mark.getSpec();
  json.props = {
    type: {
      type: 'enum',
      values: [mark.getType()]
    }
  };
  if (markSpec !== null && markSpec !== void 0 && markSpec.attrs && Object.keys(markSpec.attrs).length > 0) {
    json.props.attrs = buildAttrs(markSpec.attrs);
  }
  return json;
};
var buildVisitor = function buildVisitor(res, buildNode) {
  return {
    node: function node(_node, content, cycle) {
      if (_node.getType() === 'doc') {
        rewriteDocNodeContent(content);
      }
      var processedNode = {
        node: _node,
        json: buildNode(_node, content.filter(function (item) {
          return item.contentTypes.length;
        }))
      };
      if (cycle) {
        return processedNode;
      }
      if (!_node.isIgnored(ValidatorSpecTransformerName)) {
        res[_node.getName()] = processedNode;
      }
      return processedNode;
    },
    group: function group(_group, members) {
      if (_group.isIgnored(ValidatorSpecTransformerName)) {
        return undefined;
      }
      var groupName = _group.group;
      res[groupName] = {
        json: _group.members.filter(function (member) {
          return !member.isIgnored(ValidatorSpecTransformerName);
        }).map(function (member) {
          return member.getName();
        })
      };
      return {
        group: groupName,
        members: members
      };
    },
    $onePlus: function $onePlus(child) {
      return {
        contentTypes: child.contentTypes,
        marks: child.marks,
        minItems: 1,
        hasUnsupportedBlock: child.hasUnsupportedBlock,
        hasUnsupportedInline: child.hasUnsupportedInline
      };
    },
    $zeroPlus: function $zeroPlus(child) {
      return {
        contentTypes: child.contentTypes,
        marks: child.marks,
        minItems: 0,
        optional: true,
        hasUnsupportedBlock: child.hasUnsupportedBlock,
        hasUnsupportedInline: child.hasUnsupportedInline
      };
    },
    $range: function $range(item, child) {
      return {
        contentTypes: child.contentTypes,
        marks: child.marks,
        minItems: item.min,
        maxItems: item.max,
        hasUnsupportedBlock: child.hasUnsupportedBlock,
        hasUnsupportedInline: child.hasUnsupportedInline
      };
    },
    $or: function $or(children) {
      var marks = new Set();
      var contentTypes = [];
      var hasUnsupportedInline = false;
      var hasUnsupportedBlock = false;
      var hasNodes = children.some(function (item) {
        if (isNodeReturnValue(item)) {
          return !item.node.isIgnored(ValidatorSpecTransformerName);
        }
        return false;
      });
      var _iterator = _createForOfIteratorHelper(children),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var child = _step.value;
          if (isGroupReturnValue(child)) {
            // only include content types if group has members
            // e.g. blockRootOnly don't have members, so won't be included in contentTypes of doc
            if (child.members && child.members.length > 0 && !hasNodes) {
              contentTypes.push(child.group);
            }
            var _iterator2 = _createForOfIteratorHelper(child.members),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var member = _step2.value;
                if (!member) {
                  continue;
                }

                // If $or has nodes, we are flattening the group,
                // this is a limitation of validator.
                if (hasNodes && !member.node.isIgnored(ValidatorSpecTransformerName)) {
                  contentTypes.push(member.node.getName());
                }
                if (member.node.isIgnored(ValidatorSpecTransformerName)) {
                  if (member.node.getType() === 'unsupportedInline') {
                    hasUnsupportedInline = true;
                  }
                  if (member.node.getType() === 'unsupportedBlock') {
                    hasUnsupportedBlock = true;
                  }
                  continue;
                }
                var _iterator3 = _createForOfIteratorHelper(member.node.getMarks(member.node.hasStage0())),
                  _step3;
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    var mark = _step3.value;
                    if (!mark.isIgnored(ValidatorSpecTransformerName)) {
                      marks.add(mark.getType());
                    }
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          } else if (isNodeReturnValue(child)) {
            if (child.node.isIgnored(ValidatorSpecTransformerName)) {
              if (child.node.getType() === 'unsupportedInline') {
                hasUnsupportedInline = true;
              }
              if (child.node.getType() === 'unsupportedBlock') {
                hasUnsupportedBlock = true;
              }
              continue;
            }
            contentTypes.push(child.node.getName());
            var _iterator4 = _createForOfIteratorHelper(child.node.getMarks(child.node.hasStage0())),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var _mark = _step4.value;
                if (!_mark.isIgnored(ValidatorSpecTransformerName)) {
                  marks.add(_mark.getType());
                  res[_mark.getType()] = {
                    mark: _mark,
                    json: buildMarkValidatorSpec(_mark)
                  };
                }
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return {
        marks: Array.from(marks),
        contentTypes: contentTypes,
        minItems: 0,
        hasUnsupportedInline: hasUnsupportedInline,
        hasUnsupportedBlock: hasUnsupportedBlock
      };
    }
  };
};

/**
 * @DSLCompatibilityException
 *
 * Doc node is special and flattens some of the grpups inside of the content expression.
 * It also doesn't include layoutSection in the content expression. But we need it to output the validator spec.
 */
function rewriteDocNodeContent(content) {
  // Filter out layoutSection as it's not included in the doc content in validator spec
  content[0].contentTypes = content[0].contentTypes.filter(function (nodeName) {
    return nodeName !== 'layoutSection';
  });
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function filterItemsFromContent(json, itemsToRemove) {
  var _json$props$content;
  if (!json) {
    return;
  }
  if ((_json$props$content = json.props.content) !== null && _json$props$content !== void 0 && _json$props$content.items && Array.isArray(json.props.content.items[0])) {
    for (var i = 0; i < json.props.content.items.length; i++) {
      json.props.content.items[i] = json.props.content.items[i].filter(function (item) {
        return !itemsToRemove.includes(item);
      });
    }
  }
}

// @DSLCompatibilityException
// Nested expand content is a pseudo group that has a unique output format.
function handleNestedExpandContent(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
node,
// eslint-disable-next-line @typescript-eslint/no-explicit-any
json, content) {
  if (node.getName() !== 'nestedExpand_content') {
    return;
  }
  json.props.content = buildContent(node, content);
  var props = json.props;
  delete json.props;
  Object.assign(json, props.content);
}

// @DSLCompatibilityException
// Apply compatibility exceptions to a node.
function applyCompatibilityExceptions(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
node, json, content) {
  // @DSLCompatibilityException
  // tableCell_content is a pseudo group and needs to be ignored in the validator spec.
  if (node.getName() === 'tableRow') {
    filterItemsFromContent(json, ['tableCell_content']);
  }

  // @DSLCompatibilityException
  // nestedExpand_content is a pseudo group and needs to be ignored in the validator spec.
  if (node.getName() === 'tableCell' || node.getName() === 'tableHeader' || node.getName() === 'tableCellContent') {
    filterItemsFromContent(json, ['nestedExpand_content']);
  }
  if (node.getName() === 'nestedExpand_content' && content.length) {
    handleNestedExpandContent(node, json, content);
    return json;
  }
}