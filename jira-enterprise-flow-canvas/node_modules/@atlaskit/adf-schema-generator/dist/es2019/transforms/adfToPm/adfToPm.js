import { traverse } from '../../traverse';
import { pmNodeGroupsCodeGen } from './pmNodeGroupsCodeGen';
import { pmNodesCodeGen } from './pmNodesCodeGen';
import { pmMarksCodeGen } from './pmMarksCodeGen';
import { buildMarkSpec, buildNodeSpec } from './buildPmSpec';
import { buildContentExpression } from './buildContentExpression';
import { buildNodeTypeDefinition } from './buildPmNodeTypes';
import { PMSpecTransformerName } from '../transformerNames';
import { PSEUDO_GROUPS } from './pseudoGroups';
import { getNodeNames } from './getNodeNames';
function isNodeReturnValue(value) {
  return value && 'node' in value;
}
function isGroupReturnValue(value) {
  return value && 'group' in value;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function transform(adf) {
  const nodeResMap = {};
  const markResMap = {};
  const nodeGroupMap = {};
  const ignoredGroups = new Set(Array.from(PSEUDO_GROUPS));
  traverse(adf, {
    node: (node, content, cycle) => {
      if (node.isIgnored(PMSpecTransformerName)) {
        return undefined;
      }
      function processNode(node, stage0 = false) {
        const nodeName = node.getName(stage0);
        const nodeSpec = node.getSpec(stage0);
        const marks = node.getMarks(stage0);

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        marks.forEach(mark => {
          if (!markResMap[mark.getType()]) {
            markResMap[mark.getType()] = {
              mark,
              pmMarkSpec: buildMarkSpec(mark)
            };
          }
        });
        if (!cycle) {
          var _nodeSpec$marks$map, _nodeSpec$marks;
          nodeResMap[nodeName] = {
            pmNodeSpec: buildNodeSpec(node.getType(), nodeSpec, node.getGroups(), content),
            nodeTypeDefinition: buildNodeTypeDefinition(nodeSpec, node.getType(), (_nodeSpec$marks$map = (_nodeSpec$marks = nodeSpec.marks) === null || _nodeSpec$marks === void 0 ? void 0 : _nodeSpec$marks.map(m => m.getType())) !== null && _nodeSpec$marks$map !== void 0 ? _nodeSpec$marks$map : [], content)
          };
        }
      }
      if (node.isStage0Only()) {
        // Entire node is stage0
        processNode(node, true);
      } else {
        // Partial override of node spec in stage0
        if (node.hasStage0()) {
          processNode(node, true);
        }

        // In case of partial override, need to generate node spec for base node as well
        processNode(node);
      }
      return {
        node
      };
    },
    group: (group, members) => {
      if (group.isIgnored(PMSpecTransformerName)) {
        ignoredGroups.add(group.group);
        return undefined;
      }
      nodeGroupMap[group.group] = group.members.filter(node => !node.isIgnored(PMSpecTransformerName)).flatMap(node => getNodeNames(node));
      return {
        group: group.group,
        members: members.filter(m => m && !m.node.isIgnored(PMSpecTransformerName))
      };
    },
    $or(children) {
      const expr = [];
      const marks = new Set();
      const contentTypes = [];
      for (const child of children) {
        if (isGroupReturnValue(child)) {
          /**
           * Flatten pseudo groups
           */
          if (PSEUDO_GROUPS.has(child.group)) {
            for (const member of child.members) {
              expr.push(member.node.getType());
              contentTypes.push(...getNodeNames(member.node));
            }
          } else {
            expr.push(child.group);
          }
          // only include content types if group has members
          // e.g. blockRootOnly don't have members, so won't be included in contentTypes of doc
          if (child.members && child.members.length > 0 && !PSEUDO_GROUPS.has(child.group)) {
            contentTypes.push(child.group);
          }
          for (const member of child.members) {
            for (const mark of member.node.getMarksTypes()) {
              marks.add(mark);
            }
            if (member.node.hasStage0()) {
              for (const mark of member.node.getMarksTypes(true)) {
                marks.add(mark);
              }
            }
          }
        } else if (isNodeReturnValue(child)) {
          expr.push(child.node.getType());
          contentTypes.push(...getNodeNames(child.node));
          if (child.node.getMarks().length) {
            for (const mark of child.node.getMarksTypes()) {
              marks.add(mark);
            }
          }
          if (child.node.hasStage0()) {
            for (const mark of child.node.getMarksTypes(true)) {
              marks.add(mark);
            }
          }
        }
      }
      return {
        expr,
        marks: Array.from(marks),
        contentTypes
      };
    },
    $onePlus(child) {
      return {
        // PM Spec does not have concept of variants, so we will have duplicate content types
        expr: [buildContentExpression(Array.from(new Set(child.expr)), '+')],
        marks: child.marks,
        contentTypes: child.contentTypes
      };
    },
    $zeroPlus(child) {
      return {
        // PM Spec does not have concept of variants, so we will have duplicate content types
        expr: [buildContentExpression(Array.from(new Set(child.expr)), '*')],
        marks: child.marks,
        contentTypes: child.contentTypes
      };
    },
    $range(item, child) {
      return {
        // PM Spec does not have concept of variants, so we will have duplicate content types
        expr: [buildContentExpression(Array.from(new Set(child.expr)), `{${item.min},${item.max}}`)],
        marks: child.marks,
        contentTypes: child.contentTypes
      };
    }
  });

  /**
   * Remove ignored groups from nodeSpecRes.
   */
  for (const nodeSpecRes of Object.values(nodeResMap)) {
    var _nodeSpecRes$pmNodeSp;
    if (!nodeSpecRes.pmNodeSpec.group) {
      continue;
    }
    nodeSpecRes.pmNodeSpec.group = ((_nodeSpecRes$pmNodeSp = nodeSpecRes.pmNodeSpec.group.split(' ')) !== null && _nodeSpecRes$pmNodeSp !== void 0 ? _nodeSpecRes$pmNodeSp : []).filter(group => !ignoredGroups.has(group)).join(' ');
    if (!nodeSpecRes.pmNodeSpec.group) {
      delete nodeSpecRes.pmNodeSpec.group;
    }
  }
  return {
    nodeGroupMap,
    markResMap,
    nodeResMap
  };
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function adfToPm(adfNode) {
  try {
    const {
      nodeGroupMap,
      markResMap,
      nodeResMap
    } = transform(adfNode);
    return {
      pmNodeGroups: pmNodeGroupsCodeGen(nodeGroupMap),
      pmMarks: pmMarksCodeGen(markResMap),
      pmNodes: pmNodesCodeGen(nodeResMap)
    };
  } catch (e) {
    // eslint-disable-next-line no-console
    console.error(e);
  }
}