import camelCase from 'lodash/camelCase';
import { _codeBlock, _functionCallToVariable, _interface, _namedImport, _namedTypeImport, _type, buildADFAttributesTypes, convertTypeToTypeName, stringifyWithUndefined } from './codeGenHelpers';
import { isAnyOf } from '../../utils/isAnyOf';
import { adfToPmAutogeneratedMessage } from './adfToPmAutogeneratedMessage';
import { objectToSortedArray } from './objectToSortedArray';
export const _nodeInterfaces = (nodeName, nodeTypeDefinitionName, nodeTypeDefinition) => {
  var _nodeTypeDefinition$c, _nodeTypeDefinition$m, _nodeTypeDefinition$a;
  const additionalAttributeTypes = [];
  const _attrs = (name, attrs) => {
    if (!attrs || !Object.keys(attrs).length) {
      return null;
    }
    return `${name}: {${buildADFAttributesTypes(attrs).join(';')}},`;
  };
  const _anyOfAttrs = (name, anyOf) => {
    if (!anyOf) {
      return null;
    }
    const additionalAttributeName = index => `${nodeName}Attributes${index}`;
    anyOf.forEach((attr, index) => {
      additionalAttributeTypes.push(_interface(additionalAttributeName(index), buildADFAttributesTypes(attr).join(';')));
    });
    return `${name}: ${anyOf.map((_, index) => additionalAttributeName(index)).join('|')}`;
  };
  const _string = (name, value) => {
    if (!value) {
      return null;
    }
    return `${name}: '${value}'`;
  };
  const _contentTypes = (name, value) => {
    if (!value || value.length === 0) {
      return null;
    }
    const types = value.map(v => {
      return convertTypeToTypeName(v, '');
    });
    return `${name}: Array<${types.sort().join('|')}>`;
  };
  const _nodeMarks = (name, value) => {
    if (!value || value.length === 0) {
      return null;
    }
    return `${name}: Array<${value.sort().join('|')}>`;
  };
  const type = _string('type', nodeTypeDefinition.type);
  const content = _contentTypes('content', (_nodeTypeDefinition$c = nodeTypeDefinition.content) !== null && _nodeTypeDefinition$c !== void 0 ? _nodeTypeDefinition$c : []);
  const marks = _nodeMarks('marks', (_nodeTypeDefinition$m = nodeTypeDefinition.marks) !== null && _nodeTypeDefinition$m !== void 0 ? _nodeTypeDefinition$m : []);
  const attrs = isAnyOf(nodeTypeDefinition.attrs) ? _anyOfAttrs('attrs', (_nodeTypeDefinition$a = nodeTypeDefinition.attrs) === null || _nodeTypeDefinition$a === void 0 ? void 0 : _nodeTypeDefinition$a.anyOf) : _attrs('attrs', nodeTypeDefinition.attrs);
  const body = [type, content, marks, attrs].filter(v => !!v).join(',');
  return [...additionalAttributeTypes, _interface(nodeTypeDefinitionName, body), _type(nodeName, `PMNode & ${nodeTypeDefinitionName}`)].join('\n\n');
};
export const buildNodeMarksForImport = nodeResMap => {
  const markTypes = [];
  Object.values(nodeResMap).forEach(({
    nodeTypeDefinition: {
      marks
    }
  }) => {
    markTypes.push(...(marks !== null && marks !== void 0 ? marks : []));
  });
  return [...new Set(markTypes)];
};
export function pmNodesCodeGen(nodeResMap) {
  return _codeBlock(adfToPmAutogeneratedMessage, _namedImport('../../schema/createPMSpecFactory', 'createPMNodeSpecFactory'), _namedTypeImport('@atlaskit/editor-prosemirror/model', 'Node as PMNode'), _namedTypeImport('./nodeGroupTypes', ...['InlineDefinition', 'BlockDefinition', 'BlockRootOnlyDefinition']), _namedTypeImport('./markTypes', ...buildNodeMarksForImport(nodeResMap).sort()), objectToSortedArray(nodeResMap).map(([key, {
    nodeTypeDefinition,
    pmNodeSpec
  }]) => {
    const functionName = camelCase(key);
    const nodeName = convertTypeToTypeName(key, 'Node');
    const nodeTypeDefinitionName = convertTypeToTypeName(key, 'Definition');
    return _codeBlock(
    // build node types
    _nodeInterfaces(nodeName, nodeTypeDefinitionName, nodeTypeDefinition),
    // build node speec
    _functionCallToVariable(functionName, `createPMNodeSpecFactory<${nodeName}>`, [stringifyWithUndefined(pmNodeSpec)]));
  }).join('\n\n'));
}