import unset from 'lodash/unset';
import set from 'lodash/set';
import has from 'lodash/has';
import { traverse } from '../../traverse';
import { ValidatorSpecTransformerName } from '../transformerNames';
import { buildAttrs } from './buildAttrs';
import { buildContent } from './buildContent';
import { buildMarks } from './buildMarks';
function isNodeReturnValue(value) {
  return value && 'node' in value;
}
function isGroupReturnValue(value) {
  return value && 'group' in value;
}
function transform(adf) {
  const result = {};
  traverse(adf, buildVisitor(result, buildNode));
  const formattedResult = {};
  Object.entries(result).sort(([keyA], [keyB]) => keyA.localeCompare(keyB)).forEach(([key, value]) => {
    formattedResult[key] = value;
  });
  return formattedResult;
}
export function adfToValidatorSpec(adf) {
  return transform(adf);
}
export const buildNode = (node, content) => {
  var _base$getSpec, _node$getSpec$DANGERO;
  const json = {
    props: {}
  };
  const base = node.getBase();
  const isBaseVariant = !base;
  const baseSpec = (_base$getSpec = base === null || base === void 0 ? void 0 : base.getSpec()) !== null && _base$getSpec !== void 0 ? _base$getSpec : {};
  const nodeSpec = node.getSpec(node.hasStage0());
  const nodeType = node.getType();

  // Only base variant has type
  if (isBaseVariant) {
    json.props.type = {
      type: 'enum',
      values: [nodeType]
    };
  }
  if (nodeSpec.attrs !== baseSpec.attrs && nodeSpec.attrs && Object.keys(nodeSpec.attrs).length > 0) {
    json.props.attrs = buildAttrs(nodeSpec.attrs);
    if (nodeSpec.attrs.anyOf) {
      json.required = ['attrs'];
    }
  }

  // Text is a special node in PM and it has a text property
  if (node.getName() === 'text') {
    json.props.text = {
      type: 'string',
      minLength: 1
    };
  }
  if (nodeSpec.version) {
    json.props.version = {
      type: 'enum',
      values: [nodeSpec.version]
    };
  }
  if (content.length && nodeSpec.content !== baseSpec.content) {
    json.props.content = buildContent(node, content);
  }
  if (nodeSpec.marks !== baseSpec.marks) {
    var _nodeSpec$marks;
    const marks = buildMarks((_nodeSpec$marks = nodeSpec.marks) !== null && _nodeSpec$marks !== void 0 ? _nodeSpec$marks : [], nodeSpec.noMarks, nodeSpec.hasEmptyMarks);
    if (marks) {
      json.props.marks = marks;
    }
  }
  const overrides = ((_node$getSpec$DANGERO = node.getSpec().DANGEROUS_MANUAL_OVERRIDE) === null || _node$getSpec$DANGERO === void 0 ? void 0 : _node$getSpec$DANGERO['validator-spec']) || {};
  for (const [key, override] of Object.entries(overrides)) {
    if (override.remove) {
      if (!has(json, key)) {
        throw new Error(`Cannot delete non-existing property: ${key} for node ${node.getName()}`);
      }
      unset(json, key);
    } else {
      set(json, key, override.value);
    }
  }
  const customJson = applyCompatibilityExceptions(node, json, content);
  if (customJson) {
    return customJson;
  }

  // In validator spec if it's not a base variant,
  // the spec extends the base variant.
  // Which is represented as ['base_variant_name', {...variant_specific_spec}]
  if (!isBaseVariant) {
    return [base.getName(), json];
  }
  return json;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const buildMarkValidatorSpec = mark => {
  const json = {
    props: {}
  };
  const markSpec = mark.getSpec();
  json.props = {
    type: {
      type: 'enum',
      values: [mark.getType()]
    }
  };
  if (markSpec !== null && markSpec !== void 0 && markSpec.attrs && Object.keys(markSpec.attrs).length > 0) {
    json.props.attrs = buildAttrs(markSpec.attrs);
  }
  return json;
};
const buildVisitor = (res, buildNode) => {
  return {
    node: (node, content, cycle) => {
      if (node.getType() === 'doc') {
        rewriteDocNodeContent(content);
      }
      const processedNode = {
        node,
        json: buildNode(node, content.filter(item => item.contentTypes.length))
      };
      if (cycle) {
        return processedNode;
      }
      if (!node.isIgnored(ValidatorSpecTransformerName)) {
        res[node.getName()] = processedNode;
      }
      return processedNode;
    },
    group: (group, members) => {
      if (group.isIgnored(ValidatorSpecTransformerName)) {
        return undefined;
      }
      const groupName = group.group;
      res[groupName] = {
        json: group.members.filter(member => !member.isIgnored(ValidatorSpecTransformerName)).map(member => member.getName())
      };
      return {
        group: groupName,
        members: members
      };
    },
    $onePlus(child) {
      return {
        contentTypes: child.contentTypes,
        marks: child.marks,
        minItems: 1,
        hasUnsupportedBlock: child.hasUnsupportedBlock,
        hasUnsupportedInline: child.hasUnsupportedInline
      };
    },
    $zeroPlus(child) {
      return {
        contentTypes: child.contentTypes,
        marks: child.marks,
        minItems: 0,
        optional: true,
        hasUnsupportedBlock: child.hasUnsupportedBlock,
        hasUnsupportedInline: child.hasUnsupportedInline
      };
    },
    $range(item, child) {
      return {
        contentTypes: child.contentTypes,
        marks: child.marks,
        minItems: item.min,
        maxItems: item.max,
        hasUnsupportedBlock: child.hasUnsupportedBlock,
        hasUnsupportedInline: child.hasUnsupportedInline
      };
    },
    $or(children) {
      const marks = new Set();
      const contentTypes = [];
      let hasUnsupportedInline = false;
      let hasUnsupportedBlock = false;
      const hasNodes = children.some(item => {
        if (isNodeReturnValue(item)) {
          return !item.node.isIgnored(ValidatorSpecTransformerName);
        }
        return false;
      });
      for (const child of children) {
        if (isGroupReturnValue(child)) {
          // only include content types if group has members
          // e.g. blockRootOnly don't have members, so won't be included in contentTypes of doc
          if (child.members && child.members.length > 0 && !hasNodes) {
            contentTypes.push(child.group);
          }
          for (const member of child.members) {
            if (!member) {
              continue;
            }

            // If $or has nodes, we are flattening the group,
            // this is a limitation of validator.
            if (hasNodes && !member.node.isIgnored(ValidatorSpecTransformerName)) {
              contentTypes.push(member.node.getName());
            }
            if (member.node.isIgnored(ValidatorSpecTransformerName)) {
              if (member.node.getType() === 'unsupportedInline') {
                hasUnsupportedInline = true;
              }
              if (member.node.getType() === 'unsupportedBlock') {
                hasUnsupportedBlock = true;
              }
              continue;
            }
            for (const mark of member.node.getMarks(member.node.hasStage0())) {
              if (!mark.isIgnored(ValidatorSpecTransformerName)) {
                marks.add(mark.getType());
              }
            }
          }
        } else if (isNodeReturnValue(child)) {
          if (child.node.isIgnored(ValidatorSpecTransformerName)) {
            if (child.node.getType() === 'unsupportedInline') {
              hasUnsupportedInline = true;
            }
            if (child.node.getType() === 'unsupportedBlock') {
              hasUnsupportedBlock = true;
            }
            continue;
          }
          contentTypes.push(child.node.getName());
          for (const mark of child.node.getMarks(child.node.hasStage0())) {
            if (!mark.isIgnored(ValidatorSpecTransformerName)) {
              marks.add(mark.getType());
              res[mark.getType()] = {
                mark: mark,
                json: buildMarkValidatorSpec(mark)
              };
            }
          }
        }
      }
      return {
        marks: Array.from(marks),
        contentTypes,
        minItems: 0,
        hasUnsupportedInline,
        hasUnsupportedBlock
      };
    }
  };
};

/**
 * @DSLCompatibilityException
 *
 * Doc node is special and flattens some of the grpups inside of the content expression.
 * It also doesn't include layoutSection in the content expression. But we need it to output the validator spec.
 */
function rewriteDocNodeContent(content) {
  // Filter out layoutSection as it's not included in the doc content in validator spec
  content[0].contentTypes = content[0].contentTypes.filter(nodeName => nodeName !== 'layoutSection');
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function filterItemsFromContent(json, itemsToRemove) {
  var _json$props$content;
  if (!json) {
    return;
  }
  if ((_json$props$content = json.props.content) !== null && _json$props$content !== void 0 && _json$props$content.items && Array.isArray(json.props.content.items[0])) {
    for (let i = 0; i < json.props.content.items.length; i++) {
      json.props.content.items[i] = json.props.content.items[i].filter(item => {
        return !itemsToRemove.includes(item);
      });
    }
  }
}

// @DSLCompatibilityException
// Nested expand content is a pseudo group that has a unique output format.
function handleNestedExpandContent(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
node,
// eslint-disable-next-line @typescript-eslint/no-explicit-any
json, content) {
  if (node.getName() !== 'nestedExpand_content') {
    return;
  }
  json.props.content = buildContent(node, content);
  const props = json.props;
  delete json.props;
  Object.assign(json, props.content);
}

// @DSLCompatibilityException
// Apply compatibility exceptions to a node.
function applyCompatibilityExceptions(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
node, json, content) {
  // @DSLCompatibilityException
  // tableCell_content is a pseudo group and needs to be ignored in the validator spec.
  if (node.getName() === 'tableRow') {
    filterItemsFromContent(json, ['tableCell_content']);
  }

  // @DSLCompatibilityException
  // nestedExpand_content is a pseudo group and needs to be ignored in the validator spec.
  if (node.getName() === 'tableCell' || node.getName() === 'tableHeader' || node.getName() === 'tableCellContent') {
    filterItemsFromContent(json, ['nestedExpand_content']);
  }
  if (node.getName() === 'nestedExpand_content' && content.length) {
    handleNestedExpandContent(node, json, content);
    return json;
  }
}