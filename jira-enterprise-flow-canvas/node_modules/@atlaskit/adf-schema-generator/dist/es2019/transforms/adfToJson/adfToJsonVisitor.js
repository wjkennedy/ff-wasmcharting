import { JSONSchemaTransformerName } from '../transformerNames';
import { resolveName } from './nameResolver';
import { buildMarks } from './marksBuilder';

// Lots of placeholder code for now

export function isNodeReturnValue(value) {
  return value && 'node' in value;
}
export function isGroupReturnValue(value) {
  return value && 'group' in value;
}
export const buildVisitor = (res, buildJson, fullSchema) => {
  return {
    node: (node, content, cycle) => {
      var _node$getSpec$marks;
      if (node.isStage0Only() && fullSchema) {
        return undefined;
      }
      if (node.isIgnored(JSONSchemaTransformerName)) {
        return undefined;
      }
      const json = buildJson(node, content, fullSchema);
      const processedNode = {
        node,
        json
      };
      if (cycle) {
        return processedNode;
      }
      res[resolveName(node.getName())] = {
        json
      };
      const marks = buildMarks((_node$getSpec$marks = node.getSpec().marks) !== null && _node$getSpec$marks !== void 0 ? _node$getSpec$marks : []);
      Object.entries(marks).forEach(([key, value]) => {
        res[key] = value;
      });
      return processedNode;
    },
    group: (group, members) => {
      if (group.isIgnored(JSONSchemaTransformerName)) {
        return undefined;
      }
      res[resolveName(group.group)] = {
        json: {
          anyOf: group.members.filter(m => !m.isIgnored(JSONSchemaTransformerName) && !(m.isStage0Only() && fullSchema)).map(m => ({
            $ref: `#/definitions/${resolveName(m.getName())}`
          }))
        }
      };
      return {
        group: group.group,
        members
      };
    },
    $or(children) {
      const contentTypes = [];
      for (const child of children) {
        if (isGroupReturnValue(child)) {
          // only include content types if group has members
          // e.g. blockRootOnly don't have members, so won't be included in contentTypes of doc
          if (child.members && child.members.length > 0) {
            contentTypes.push(child.group);
          }
        } else if (isNodeReturnValue(child)) {
          contentTypes.push(child.node.getName());
        }
      }
      return {
        type: '$or',
        minItems: 1,
        contentTypes
      };
    },
    $onePlus(child) {
      return {
        type: '$onePlus',
        minItems: 1,
        contentTypes: child.contentTypes
      };
    },
    $zeroPlus(child) {
      return {
        type: '$zeroPlus',
        minItems: 0,
        contentTypes: child.contentTypes
      };
    },
    $range(range, child) {
      return {
        type: '$range',
        contentTypes: child.contentTypes,
        range
      };
    }
  };
};