import { traverse } from '../../traverse';
import { buildNode } from './nodeBuilder';
import { buildVisitor } from './adfToJsonVisitor';
import flow from 'lodash/flow';
export function transform(adf, fullSchema) {
  const result = {};
  traverse(adf, buildVisitor(result, buildNode, fullSchema));
  return formatResult(result);
}
function formatResult(result) {
  const formattedResult = {};
  Object.entries(result).sort(([keyA], [keyB]) => keyA.localeCompare(keyB)).forEach(([key, value]) => {
    formattedResult[key] = value.json;
  });
  const finalResult = {
    $ref: '#/definitions/doc_node',
    description: 'Schema for Atlassian Document Format.',
    $schema: 'http://json-schema.org/draft-04/schema#',
    definitions: formattedResult
  };
  return finalResult;
}
export function adfToJSON(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
adf, shouldGenerateFullSchema = false) {
  return flow(transform, fixCommonCompatibilityIssues, shouldGenerateFullSchema ? json => json : fixCompatibilityIssuesForStageZero)(adf, shouldGenerateFullSchema);
}

// Compatibility issues are grouped by nodes
function fixCommonCompatibilityIssues(json) {
  var _json$definitions, _json$definitions$doc, _json$definitions2, _json$definitions2$la, _json$definitions3, _json$definitions3$la, _json$definitions4, _json$definitions4$me, _json$definitions4$me2, _json$definitions5, _json$definitions5$me, _json$definitions5$me2, _json$definitions5$me3, _json$definitions6, _json$definitions$tab, _json$definitions7, _json$definitions7$ta, _json$definitions8, _json$definitions8$ta, _json$definitions9, _json$definitions9$ta;
  // Extra properties
  // @DSLCompatibilityException Despite being oneplus, doc has no minItems field
  (_json$definitions = json.definitions) === null || _json$definitions === void 0 ? true : (_json$definitions$doc = _json$definitions.doc_node.properties) === null || _json$definitions$doc === void 0 ? true : delete _json$definitions$doc.content.minItems;
  /**
   * @DSLCompatibilityException Skips including this node in content for the node or groups specified in JSON Schema.
   * The following nodes are present in the content for the PM Spec but not in the JSON Schema. During cleanup we need to align the JSON
   * Schema with the PM Spec to remove these exceptions.
   */
  // @ts-expect-error anyOf is not on items in the JSON Schema type but is available in the JSON schema
  json.definitions.doc_node.properties.content.items.anyOf =
  // @ts-expect-error anyOf is not on items in the JSON Schema type but is available in the JSON schema
  json.definitions.doc_node.properties.content.items.anyOf.filter(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  v => !['bodiedExtension_node', 'extension_node', 'heading_node', 'layoutSection_node', 'mediaSingle_node', 'paragraph_node'].map(v => `#/definitions/${v}`).includes(v.$ref));

  // @DSLCompatibilityException These needs to be added to the JSON Schema to match PM Spec
  if (json.definitions && json.definitions.inline_node && Array.isArray(json.definitions.inline_node.anyOf)) {
    json.definitions.inline_node.anyOf = json.definitions.inline_node.anyOf.filter(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    v => !['#/definitions/confluenceJiraIssue_node', '#/definitions/confluenceUnsupportedInline_node', '#/definitions/image_node', '#/definitions/inlineExtension_node', '#/definitions/text_link_inline_node', '#/definitions/text_node', '#/definitions/unsupportedInline_node'].includes(v.$ref));
  }

  // @DSLCompatibilityException layoutSection in JSON schema is a "base" spec,
  // where majority of the restrictions are applied in variants which extend the base spec.
  // Hence things like minItems and maxItems are actually lifted to variants and need to be removed
  // from the base spec. Need to get rid of the base + extends pattern for layout.
  (_json$definitions2 = json.definitions) === null || _json$definitions2 === void 0 ? true : (_json$definitions2$la = _json$definitions2.layoutSection_node.properties) === null || _json$definitions2$la === void 0 ? true : delete _json$definitions2$la.content.minItems;
  (_json$definitions3 = json.definitions) === null || _json$definitions3 === void 0 ? true : (_json$definitions3$la = _json$definitions3.layoutSection_node.properties) === null || _json$definitions3$la === void 0 ? true : delete _json$definitions3$la.content.maxItems;

  // @DSLCompatibilityException Despite having required attributes, mediaSingle has no attrs required
  if (json.definitions && json.definitions.mediaSingle_node) {
    json.definitions.mediaSingle_node.required = json.definitions.mediaSingle_node.required.filter(v => v !== 'attrs');
    // @DSLCompatibilityException Find out why mediaSingle has additionalproperties
    json.definitions.mediaSingle_node.additionalProperties = true;
  }

  // @DSLCompatibilityException mediaInline node does not have url in JSON Schema. Should add it into JSON Schema
  (_json$definitions4 = json.definitions) === null || _json$definitions4 === void 0 ? true : (_json$definitions4$me = _json$definitions4.mediaInline_node.properties) === null || _json$definitions4$me === void 0 ? true : (_json$definitions4$me2 = _json$definitions4$me.attrs.properties) === null || _json$definitions4$me2 === void 0 ? true : delete _json$definitions4$me2.url;
  // @DSLCompatibilityException Find out why mediaInline has data in json but not in pm spec
  if ((_json$definitions5 = json.definitions) !== null && _json$definitions5 !== void 0 && (_json$definitions5$me = _json$definitions5.mediaInline_node) !== null && _json$definitions5$me !== void 0 && (_json$definitions5$me2 = _json$definitions5$me.properties) !== null && _json$definitions5$me2 !== void 0 && (_json$definitions5$me3 = _json$definitions5$me2.attrs) !== null && _json$definitions5$me3 !== void 0 && _json$definitions5$me3.properties) {
    json.definitions.mediaInline_node.properties.attrs.properties.data = {};
  }

  // @DSLCompatibilityException nestedExpand_content is the content for nestedExpand but as a separate entry
  if (json.definitions && Array.isArray(json.definitions.nestedExpand_content.allOf)) {
    const objectDef = json.definitions.nestedExpand_content.allOf.find(v => v.type === 'object');
    if (objectDef && objectDef.properties && objectDef.properties.content) {
      json.definitions.nestedExpand_content = objectDef.properties.content;
    }
  }

  // @DSLCompatibilityException nested expand references nestedExpand_content in JSON schema
  if ((_json$definitions6 = json.definitions) !== null && _json$definitions6 !== void 0 && _json$definitions6.nestedExpand_node.properties) {
    json.definitions.nestedExpand_node.properties.content = {
      $ref: '#/definitions/nestedExpand_content'
    };
  }
  // @DSLCompatibilityException Despite having no required attributes, nestedExpand has attrs required
  if (json.definitions) {
    json.definitions.nestedExpand_node.required.push('attrs');
  }

  // @DSLCompatibilityException table header and table cell refers to table cell content
  // However, the list of references are duplicated in the DSL. We should follow the DSL and replace this reference with its content
  if (json.definitions && (_json$definitions$tab = json.definitions.table_cell_content) !== null && _json$definitions$tab !== void 0 && _json$definitions$tab.properties) {
    json.definitions.table_cell_content = json.definitions.table_cell_content.properties.content;
  }

  // @DSLCompatibilityException nestedExpand.use('content') is not an actual node, but used as a reference for nestedExpand*
  // Since this is only used in tableCell and tableHeader, we put it in table cell content so the definition is generated alongside where it's used.
  // @ts-expect-error anyOf is not on items in the JSON Schema type but is available in the JSON schema
  json.definitions.table_cell_content.items.anyOf =
  // @ts-expect-error anyOf is not on items in the JSON Schema type but is available in the JSON schema
  json.definitions.table_cell_content.items.anyOf.filter(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  v => v.$ref !== '#/definitions/nestedExpand_content');
  if ((_json$definitions7 = json.definitions) !== null && _json$definitions7 !== void 0 && (_json$definitions7$ta = _json$definitions7.table_cell_node) !== null && _json$definitions7$ta !== void 0 && _json$definitions7$ta.properties) {
    json.definitions.table_cell_node.properties.content = {
      $ref: `#/definitions/table_cell_content`
    };
  }
  if ((_json$definitions8 = json.definitions) !== null && _json$definitions8 !== void 0 && (_json$definitions8$ta = _json$definitions8.table_header_node) !== null && _json$definitions8$ta !== void 0 && _json$definitions8$ta.properties) {
    json.definitions.table_header_node.properties.content = {
      $ref: `#/definitions/table_cell_content`
    };
  }
  // @DSLCompatibilityException Table cell content is not an actual content of table row
  // Only used as a ref for table header and cell node.
  // Once table cell content is no longer used, we can remove this.
  // @ts-expect-error anyOf is not on items in the JSON Schema type but is available in the JSON schema
  json.definitions.table_row_node.properties.content.items.anyOf =
  // @ts-expect-error anyOf is not on items in the JSON Schema type but is available in the JSON schema
  json.definitions.table_row_node.properties.content.items.anyOf.filter(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  v => v.$ref !== '#/definitions/table_cell_content');

  // @DSLCompatibilityException Despite being oneplus, tableRow has no minItems field
  (_json$definitions9 = json.definitions) === null || _json$definitions9 === void 0 ? true : (_json$definitions9$ta = _json$definitions9.table_row_node.properties) === null || _json$definitions9$ta === void 0 ? true : delete _json$definitions9$ta.content.minItems;
  return json;
}
function fixCompatibilityIssuesForStageZero(json) {
  var _json$definitions0, _json$definitions0$mu;
  // @DSLCompatibilityException Despite being oneplus, multiBodiedExtension_node has no minItems field
  (_json$definitions0 = json.definitions) === null || _json$definitions0 === void 0 ? true : (_json$definitions0$mu = _json$definitions0.multiBodiedExtension_node.properties) === null || _json$definitions0$mu === void 0 ? true : delete _json$definitions0$mu.content.minItems;
  return json;
}