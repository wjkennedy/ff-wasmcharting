import { JSONSchemaTransformerName } from '../transformerNames';
import { buildAttrs } from './attrBuilder';
import { buildContent } from './contentBuilder';
import { resolveName } from './nameResolver';
import { buildRequired, buildVariantRequired } from './requiredBuilder';
export const buildNode = (node, content, fullSchema
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) => {
  var _nodeSpec$marks, _content$, _content$2, _content$2$range;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const json = {};
  const isStage0 = !fullSchema && node.hasStage0();
  const nodeSpec = node.getSpec(isStage0);
  const jsonContent = buildContent(content, node.getName(), nodeSpec, fullSchema);
  const nodeMarks = ((_nodeSpec$marks = nodeSpec.marks) === null || _nodeSpec$marks === void 0 ? void 0 : _nodeSpec$marks.map(mark => {
    if (mark.isIgnored(JSONSchemaTransformerName)) {
      return;
    }
    return mark.getType();
  }).filter(Boolean)) || [];
  const marks = buildNodeMarks(nodeMarks, {
    hasNoMarks: !!nodeSpec.noMarks,
    hasEmptyMarks: !!nodeSpec.hasEmptyMarks,
    marksMaxItems: nodeSpec.marksMaxItems
  });
  const attrs = buildAttrs(node.getSpec().attrs);
  const version = nodeSpec.version;
  const jsonVersion = version ? {
    version: {
      enum: [version]
    }
  } : {};
  const required = buildRequired(nodeSpec.attrs, ((_content$ = content[0]) === null || _content$ === void 0 ? void 0 : _content$.minItems) === 1 || Boolean((_content$2 = content[0]) === null || _content$2 === void 0 ? void 0 : (_content$2$range = _content$2.range) === null || _content$2$range === void 0 ? void 0 : _content$2$range.type), node.getName());
  if (node.getVariant() === 'base' || nodeSpec.noExtend || node.hasAttributeOverride()) {
    json.type = 'object';
    json.properties = {
      type: {
        enum: [node.getType()]
      },
      ...marks,
      ...attrs,
      ...jsonContent,
      ...jsonVersion
    };
    json.additionalProperties = false;
    json.required = required;

    // Text is a special node in PM and it has a text property
    if (node.getName() === 'text') {
      json.properties.text = {
        minLength: 1,
        type: 'string'
      };
      json.required.push('text');
    }
  } else {
    const required = buildVariantRequired(content);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const allOfItem = {
      type: 'object',
      properties: {
        ...marks,
        ...jsonContent
      },
      ...required,
      additionalProperties: true
    };
    json.allOf = [{
      // @ts-expect-error
      $ref: `#/definitions/${resolveName(node.getBase().getName())}`
    }, allOfItem];
  }
  return json;
};
export function buildNodeMarks(nodeMarks, opts) {
  const {
    hasNoMarks,
    hasEmptyMarks,
    marksMaxItems
  } = opts;
  if (hasNoMarks) {
    return {
      marks: {
        type: 'array',
        maxItems: marksMaxItems !== null && marksMaxItems !== void 0 ? marksMaxItems : 0
      }
    };
  }
  if (hasEmptyMarks) {
    return {
      marks: {
        type: 'array',
        maxItems: marksMaxItems
      }
    };
  }
  if (nodeMarks.length === 0) {
    return {};
  }
  if (nodeMarks.length === 1) {
    return {
      marks: {
        type: 'array',
        items: {
          $ref: `#/definitions/${nodeMarks[0]}_mark`
        },
        maxItems: marksMaxItems
      }
    };
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const markDefinitions = [];
  nodeMarks.forEach(markName => {
    markDefinitions.push({
      $ref: `#/definitions/${markName}_mark`
    });
  });
  const jsonMarks = {
    marks: {
      type: 'array',
      items: {
        anyOf: markDefinitions
      },
      maxItems: marksMaxItems
    }
  };
  return jsonMarks;
}