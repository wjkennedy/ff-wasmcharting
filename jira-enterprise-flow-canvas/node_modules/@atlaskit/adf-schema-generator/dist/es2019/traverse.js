import { ADFNode } from './adfNode';
/**
 * Implements post-order traversal of an ADF DSL tree.
 *
 * Traverse accepts a root node of the ADF DSL tree and a visitor object.
 * Visitor is a pattern that is commonly used in tree traversal algorithms.
 * It allows to separate the traversal logic from the actual processing logic.
 *
 * The visitor object should have the following methods:
 * - node(node, children, cycle) - called for each node in the tree
 *   - node - the node being visited
 *   - children - an array of processed children of the node
 *   - cycle - a flag indicating that the node is being visited again due to a cycle
 * - group(group, nodes) - called for each group in the tree
 *   - group - the group being visited
 *   - nodes - an array of processed nodes in the group
 * - $or(content) - called for each $or content in the tree
 *   - content - an array of processed nodes or groups
 * - $onePlus(content) - called for each $one+ content in the tree
 *   - content - the processed content
 * - $zeroPlus(content) - called for each $zero+ content in the tree
 *   - content - the processed content
 * - $range(item, content) - called for each $range content in the tree
 *   - item - the range content item, includes the range metadata â€“ min and max
 *   - content - the processed content
 *
 * How does it deal with cycles?
 *
 * In order to deal with cyclic structure we stop processing children if the node was seen before.
 * That allows us to still return something meaningful to a parent node without falling into a cycle.
 *
 * Example usage:
 * const doc = adfNode('doc').definine({root: true});
 *
 * traverse(doc, {
 *    node(node, children) {},
 *    group(group, nodes) {},
 *    $or(content) {},
 *    $onePlus(content) {},
 *    $zeroPlus(content) {},
 *    $range(item, content) {},
 * })
 */
export function traverse(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
node, visitor) {
  const visited = new Set();
  if (!node.isRoot()) {
    // eslint-disable-next-line no-console
    console.log('root', node.getSpec());
    throw new Error(`Cannot start traverse from a node that is not a root node. Node type: ${node.getType()}`);
  }
  traverseNode(node, visitor, visited);
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function traverseNode(node, visitor, visited) {
  var _node$getSpec, _visitor$node2;
  if (visited.has(node.getName())) {
    var _visitor$node;
    // in order to break a cycle, once we visit the same node again,
    // we are then just processing the node itself, without its children
    // also we are passing a cycle flag to the visitor, so the logic can be adjusted accordingly
    return visitor === null || visitor === void 0 ? void 0 : (_visitor$node = visitor.node) === null || _visitor$node === void 0 ? void 0 : _visitor$node.call(visitor, node, [], true);
  }
  if (!node.isDefined()) {
    throw new Error(`Cannot traverse a node that was not defined, call node.define(spec) first. Node type: ${node.getType()}`);
  }
  const children = [];
  visited.add(node.getName());
  if ((_node$getSpec = node.getSpec()) !== null && _node$getSpec !== void 0 && _node$getSpec.content) {
    for (const child of (_node$getSpec$content = (_node$getSpec2 = node.getSpec()) === null || _node$getSpec2 === void 0 ? void 0 : _node$getSpec2.content) !== null && _node$getSpec$content !== void 0 ? _node$getSpec$content : []) {
      var _node$getSpec$content, _node$getSpec2;
      children.push(traverseNodeContent(child, visitor, visited));
    }
  }
  return visitor === null || visitor === void 0 ? void 0 : (_visitor$node2 = visitor.node) === null || _visitor$node2 === void 0 ? void 0 : _visitor$node2.call(visitor, node, children);
}
function traverseNodeContent(item, visitor, visited) {
  if (item.type === '$or' && Array.isArray(item.content)) {
    var _visitor$$or;
    const children = [];
    for (const child of item.content) {
      if (child instanceof ADFNode) {
        children.push(traverseNode(child, visitor, visited));
      } else {
        children.push(traverseGroup(child, visitor, visited));
      }
    }
    return (_visitor$$or = visitor.$or) === null || _visitor$$or === void 0 ? void 0 : _visitor$$or.call(visitor, children);
  }
  if (!Array.isArray(item.content)) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const child = traverseNodeContent(item.content, visitor, visited);
    if (item.type === '$one+') {
      var _visitor$$onePlus;
      return visitor === null || visitor === void 0 ? void 0 : (_visitor$$onePlus = visitor.$onePlus) === null || _visitor$$onePlus === void 0 ? void 0 : _visitor$$onePlus.call(visitor, child);
    }
    if (item.type === '$zero+') {
      var _visitor$$zeroPlus;
      return visitor === null || visitor === void 0 ? void 0 : (_visitor$$zeroPlus = visitor.$zeroPlus) === null || _visitor$$zeroPlus === void 0 ? void 0 : _visitor$$zeroPlus.call(visitor, child);
    }
    if (item.type === '$range') {
      var _visitor$$range;
      return visitor === null || visitor === void 0 ? void 0 : (_visitor$$range = visitor.$range) === null || _visitor$$range === void 0 ? void 0 : _visitor$$range.call(visitor, item, child);
    }
  }
}
function traverseGroup(group, visitor, visited) {
  var _visitor$group;
  const children = [];
  for (const child of group.members) {
    if (child instanceof ADFNode) {
      children.push(traverseNode(child, visitor, visited));
    }
  }
  return visitor === null || visitor === void 0 ? void 0 : (_visitor$group = visitor.group) === null || _visitor$group === void 0 ? void 0 : _visitor$group.call(visitor, group, children);
}