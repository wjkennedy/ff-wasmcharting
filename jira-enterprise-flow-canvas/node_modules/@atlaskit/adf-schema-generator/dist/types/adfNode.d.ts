import type { TransformerNames } from './transforms/transformerNames';
import type { ADFNodeSpec } from './types/ADFNodeSpec';
export declare class ADFNode<TVariantsNames extends Array<unknown> = [], TNodeSpecType extends ADFNodeSpec = ADFNodeSpec> {
    #private;
    constructor(type: string);
    /**
     * Returns true if the node has been defined, e.g. node.define() method was called.
     */
    isDefined(): boolean;
    /**
     * Returns true if the node is a root node.
     * Which marks the top level of the DSL schema tree.
     */
    isRoot(): boolean;
    /**
     * Checks whether the node is ignored by a given transformer.
     */
    isIgnored(transformerName: TransformerNames): boolean | undefined;
    /**
     * If true, the node doesn't allow marks to be set.
     * This is stricter than simply having an empty marks list.
     */
    hasNoMarks(): boolean | undefined;
    /**
     * Define a node.
     *
     * Assigns NodeSpec to the node. If node was not defined and can't be part of the schema tree.
     */
    define<T extends TNodeSpecType>(spec: T): ADFNode<TVariantsNames, TNodeSpecType>;
    /**
     * Define a variant of the node.
     *
     * There is quite often a need to define a slightly different version of the node. E.g.:
     * - A feature flag to enable/disable a feature
     * - Stricter validation for a specific use case, like allowing certain marks on a top level node,
     *   and not allowing them on a nested variant of the same node.
     *
     * Variant allows for this use case.
     *
     * Each variant shallowly overrides the base node spec. And then can be used via node.use('variant_name') method.
     */
    variant<Name extends string, T extends ADFNodeSpec>(name: Name, spec: T): ADFNode<[...TVariantsNames, Name], TNodeSpecType & T>;
    /**
     * Private method to set the base node. Used in variant creation so there is a link between the base and the variant.
     */
    setBase(base: ADFNode<any, any>): any;
    /**
     * For a variant node, returns the base node from which the variant was created.
     */
    getBase(): ADFNode<TVariantsNames, TNodeSpecType> | null;
    getType(): string;
    /**
     * A full name of the node which includes node type and variant name.
     */
    getName(stage0?: boolean): string;
    getSpec(stage0?: boolean): TNodeSpecType;
    /**
     * Return true if the node has a stage0 spec.
     * It's true for both cases:
     * - full node stage 0
     * - partial stage 0 override for a node
     */
    hasStage0(): boolean;
    /**
     * Return true if the node is stage0 only.
     */
    isStage0Only(): boolean;
    getMarks(stage0?: boolean): import("./adfMark").ADFMark<import("./types/ADFMarkSpec").ADFMarkSpec>[];
    getMarksTypes(stage0?: boolean): string[];
    /**
     * Returns the name of the variant.
     */
    getVariant(): string;
    /**
     * Returns all variants of the node.
     */
    getVariants(): Map<ToLiteralUnion<TVariantsNames>, ADFNode<any, TNodeSpecType>>;
    /**
     * Returns true if variant has attributes that don't match base spec.
     */
    hasAttributeOverride(): boolean;
    /**
     * Private method to set the variant name. Used when creating a variant.
     */
    setVariant(variant: string): this;
    use(variantName: ToLiteralUnion<TVariantsNames>): ADFNode;
    setGroup(group: string): this;
    getGroups(): string[];
}
export declare function adfNode<Variant extends string, NodeSpecType extends ADFNodeSpec>(type: string): ADFNode<[Variant], NodeSpecType>;
type ToLiteralUnion<T extends Array<unknown>> = {
    [K in keyof T]: string extends T[K] ? never : T[K];
}[number];
export {};
