/* flyout-menu-item-content.tsx generated by @compiled/babel-plugin v0.38.1 */
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import "./flyout-menu-item-content.compiled.css";
import { ax, ix } from "@compiled/react/runtime";
import React, { forwardRef, useCallback, useContext, useEffect, useId, useMemo, useRef, useState } from 'react';
import { useAnalyticsEvents } from '@atlaskit/analytics-next';
import mergeRefs from '@atlaskit/ds-lib/merge-refs';
import { fg } from '@atlaskit/platform-feature-flags';
import { PopupContent } from '@atlaskit/popup/experimental';
import { OnCloseContext, SetIsOpenContext, TitleIdContextProvider } from './flyout-menu-item-context';
/**
 * The vertical offset in px to ensure the flyout container does not exceed the bounds of
 * the window. This matches the padding of the content container, and it's position within
 * the viewport.
 *
 * - FlyoutMenuItemContent: paddingBlock: token('space.100'); â€“ 8px top, 8px bottom
 * - Position: 5px top, 5px bottom
 *
 * Total vertical padding:
 * 		(8px [content top] + 8px [content bottom]) +
 * 		(5px [position top] + 5px [position bottom]) = 26px
 */
var FLYOUT_MENU_VERTICAL_OFFSET_PX = 26;

/**
 * The maximum height of the flyout menu in pixels, following the Confluence standard maximum
 * height of 760px.
 */
var FLYOUT_MENU_MAX_HEIGHT_PX = 760;
var flyoutMenuItemContentStyles = {
  root: "_1q51u2gc _85i5u2gc _bozgu2gc _y4tiu2gc _14b51kdj"
};
var flyoutMenuItemContentContainerStyles = {
  container: "_1e0c1txw _4t3i1osq _2lx21bp4"
};
/**
 * __FlyoutMenuItemContent__
 *
 * The content that appears when the flyout menu is open.
 */
export var FlyoutMenuItemContent = /*#__PURE__*/forwardRef(function (_ref, forwardedRef) {
  var children = _ref.children,
    containerTestId = _ref.containerTestId,
    onClose = _ref.onClose,
    autoFocus = _ref.autoFocus,
    _ref$maxHeight = _ref.maxHeight,
    maxHeight = _ref$maxHeight === void 0 ? FLYOUT_MENU_MAX_HEIGHT_PX : _ref$maxHeight;
  var setIsOpen = useContext(SetIsOpenContext);
  var onCloseRef = useContext(OnCloseContext);
  var _useAnalyticsEvents = useAnalyticsEvents(),
    createAnalyticsEvent = _useAnalyticsEvents.createAnalyticsEvent;

  // The source of the close is not accessible to the consumer, it is determined within the
  // handleClose function, or passed in as a parameter in FlyoutMenuItemTrigger (outside-click),
  // or FlyoutHeader (close-button).
  var handleClose = useCallback(function (event, source) {
    if (fg('platform_dst_nav4_flyout_menu_slots_close_button')) {
      // Use the passed source if provided, otherwise determine from event
      var determinedSource = source || 'other';
      if (!source) {
        if (event instanceof KeyboardEvent) {
          var keyboardEvent = event;
          if (keyboardEvent.key === 'Escape' || keyboardEvent.key === 'Esc') {
            determinedSource = 'escape-key';
          }
        } else if (event instanceof MouseEvent) {
          if (event && 'type' in event && event.type === 'click') {
            determinedSource = 'outside-click';
          }
        }
      }

      // When flyout menu is closed, fire analytics event
      var navigationAnalyticsEvent = createAnalyticsEvent({
        source: 'sideNav',
        actionSubject: 'flyoutMenu',
        action: 'closed',
        attributes: {
          closeSource: determinedSource
        }
      });
      navigationAnalyticsEvent.fire('navigation');
    }
    onClose === null || onClose === void 0 || onClose();
    setIsOpen(false);
  }, [setIsOpen, onClose, createAnalyticsEvent]);

  // Register handleClose in the ref to allow the FlyoutMenuItemTrigger to access it
  useEffect(function () {
    onCloseRef.current = handleClose;
  }, [handleClose, onCloseRef]);
  var titleId = useId();
  var computedMaxHeight = useMemo(function () {
    return (
      /**
       * The max height of the flyout menu needs to factor in the top nav and banner, as it will be layered
       * beneath them and would otherwise be clipped.
       *
       * We can remove these navigation variables once layering has been addressed holistically (e.g. using Top Layer).
       *
       * Not using the UNSAFE_MAIN_BLOCK_START_FOR_LEGACY_PAGES_ONLY variable from `@atlaskit/navigation-system`
       * to avoid a circular dependency, as that package imports this one for re-exporting components.
       */
      fg('platform-dst-side-nav-layering-fixes') ? "min(calc(100vh - ".concat(FLYOUT_MENU_VERTICAL_OFFSET_PX, "px - var(--n_tNvM, 0px) - var(--n_bnrM, 0px)), ").concat(maxHeight, "px)") : "min(calc(100vh - ".concat(FLYOUT_MENU_VERTICAL_OFFSET_PX, "px), ").concat(maxHeight, "px)")
    );
  }, [maxHeight]);
  return /*#__PURE__*/React.createElement(PopupContent, {
    appearance: "UNSAFE_modal-below-sm",
    onClose: handleClose,
    placement: "right-start"
    // Using a capture event listener so that we are more resilient against
    // code that stops events. We _really_ want to close the flyout whenever
    // user user clicks outside the flyout content
    ,
    shouldUseCaptureOnOutsideClick: true,
    shouldFitViewport: true,
    testId: containerTestId,
    xcss: flyoutMenuItemContentStyles.root,
    autoFocus: autoFocus,
    role: fg('platform_dst_nav4_flyout_menu_slots_close_button') ? 'dialog' : undefined,
    titleId: fg('platform_dst_nav4_flyout_menu_slots_close_button') ? titleId : undefined
    /**
     * Disabling GPU acceleration removes the use of `transform` by popper.js for this popup.
     *
     * This allows makers to use popups with `shouldRenderToParent` inside the flyout.
     *
     * Without this, the `transform` makes the flyout the containing element for fixed positioning.
     * Because the flyout is also a scroll container then any nested, layered element is unable to
     * escape the flyout.
     *
     * Disabling the `transform` is the simplest way to resolve this layering issue,
     * and should have negligible performance impacts, because the flyout menus should rarely
     * need to be repositioned.
     */,
    shouldDisableGpuAcceleration: true,
    shouldRenderToParent: fg('platform_dst_nav4_flyoutmenuitem_render_to_parent')
  }, function (_ref2) {
    var update = _ref2.update;
    return /*#__PURE__*/React.createElement(UpdatePopperOnContentResize, {
      ref: forwardedRef,
      update: update
    }, fg('platform_dst_nav4_flyout_menu_slots_close_button') ? /*#__PURE__*/React.createElement(TitleIdContextProvider, {
      value: titleId
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        maxHeight: computedMaxHeight
      },
      "data-testid": containerTestId ? "".concat(containerTestId, "--container") : undefined,
      className: ax([flyoutMenuItemContentContainerStyles.container])
    }, children)) : children);
  });
});
function createResizeObserver(update) {
  return new ResizeObserver(update);
}

/**
 * Will call the Popper.js `update()` method to recalculate positioning, when the flyout menu changes size.
 * This is the size of the scroll container, NOT the scroll content.
 *
 * We could potentially bake this into `@atlaskit/popup` or `@atlaskit/popper` but there are a few
 * reasons to keep it scoped to flyout menus for now:
 *
 * 1. It's easier to unwind
 * 2. We've only had bug reports for flyout menus
 * 3. Popup exposes the `update` function so consumers can already do this themselves if necessary
 * 4. Flyout menus are a lot more restricted to other popups, it might not make sense more generally
 */
var UpdatePopperOnContentResize = /*#__PURE__*/forwardRef(function (_ref3, forwardedRef) {
  var update = _ref3.update,
    children = _ref3.children;
  /**
   * Storing our `update` function in a ref so that we have a stable reference to it.
   * We need this because our `ResizeObserver` callback cannot be changed after creating it.
   */
  var updateRef = useRef(update);
  useEffect(function () {
    updateRef.current = update;
  }, [update]);

  /**
   * Stable function that calls the latest `update` function by calling it through the stable ref.
   */
  var triggerUpdate = useCallback(function () {
    var _updateRef$current;
    (_updateRef$current = updateRef.current) === null || _updateRef$current === void 0 || _updateRef$current.call(updateRef);
  }, []);
  var _useState = useState(function () {
      return createResizeObserver(triggerUpdate);
    }),
    _useState2 = _slicedToArray(_useState, 1),
    resizeObserver = _useState2[0];

  /**
   * This is a callback ref that will update which `HTMLElement` we are observing,
   * if or when the underlying `HTMLElement` changes or unmounts.
   */
  var observeCallbackRef = useCallback(function (element) {
    /**
     * Unobserves all observed elements.
     * Allows us to cleanup without needing to store a reference to the previous element.
     */
    resizeObserver.disconnect();
    if (!element) {
      return;
    }
    resizeObserver.observe(element);
  }, [resizeObserver]);

  /**
   * We need to memoize the ref otherwise `triggerUpdate` is repeatedly called.
   *
   * This stems from ResizeObserver firing once after calling `.observe()` even if there
   * was no resize.
   *
   * Without memoizing the ref, the update causes a rerender, which causes the ref to
   * get recreated, which triggers an update and so on in a loop.
   */
  var ref = useMemo(function () {
    return mergeRefs([forwardedRef, observeCallbackRef]);
  }, [forwardedRef, observeCallbackRef]);
  return /*#__PURE__*/React.createElement("div", {
    ref: ref
  }, children);
});