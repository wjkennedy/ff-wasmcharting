import { traverse } from '../traverse/traverse';
import { extension } from '../builders';
import { NodeNestingTransformError } from './errors';
const NESTED_TABLE_EXTENSION_TYPE = 'com.atlassian.confluence.migration',
  NESTED_TABLE_EXTENSION_KEY = 'nested-table';
export const isNestedTableExtension = extensionNode => {
  var _extensionNode$attrs, _extensionNode$attrs2;
  return ((_extensionNode$attrs = extensionNode.attrs) === null || _extensionNode$attrs === void 0 ? void 0 : _extensionNode$attrs.extensionType) === NESTED_TABLE_EXTENSION_TYPE && ((_extensionNode$attrs2 = extensionNode.attrs) === null || _extensionNode$attrs2 === void 0 ? void 0 : _extensionNode$attrs2.extensionKey) === NESTED_TABLE_EXTENSION_KEY;
};
const transformNestedTableExtension = nestedTableExtension => {
  var _nestedTableExtension, _nestedTableExtension2;
  // No content - drop the extension node
  if (!((_nestedTableExtension = nestedTableExtension.attrs) !== null && _nestedTableExtension !== void 0 && (_nestedTableExtension2 = _nestedTableExtension.parameters) !== null && _nestedTableExtension2 !== void 0 && _nestedTableExtension2.adf)) {
    return false;
  }
  try {
    var _nestedTableExtension3, _nestedTableExtension4;
    const adf = JSON.parse((_nestedTableExtension3 = nestedTableExtension.attrs) === null || _nestedTableExtension3 === void 0 ? void 0 : (_nestedTableExtension4 = _nestedTableExtension3.parameters) === null || _nestedTableExtension4 === void 0 ? void 0 : _nestedTableExtension4.adf);
    if (!adf.content || adf.content.length === 0) {
      return false;
    }
    return adf.content[0];
  } catch (e) {
    throw new NodeNestingTransformError('Failed to parse nested table content');
  }
};
export const transformNestedTablesIncomingDocument = adf => {
  let isTransformed = false;
  const transformedAdf = traverse(adf, {
    extension: node => {
      if (isNestedTableExtension(node)) {
        isTransformed = true;
        return transformNestedTableExtension(node);
      }
      return;
    }
  });
  return {
    transformedAdf,
    isTransformed
  };
};
export const transformNestedTableNodeOutgoingDocument = tableCellNode => {
  try {
    var _tableCellNode$conten;
    return {
      ...tableCellNode,
      content: (_tableCellNode$conten = tableCellNode.content) === null || _tableCellNode$conten === void 0 ? void 0 : _tableCellNode$conten.map(childNode => {
        // wrap nested table in an extension node
        if ((childNode === null || childNode === void 0 ? void 0 : childNode.type) === 'table') {
          return extension({
            extensionType: NESTED_TABLE_EXTENSION_TYPE,
            extensionKey: NESTED_TABLE_EXTENSION_KEY,
            parameters: {
              adf: JSON.stringify({
                type: 'doc',
                version: 1,
                content: [childNode]
              })
            }
          });
        }
        return childNode;
      })
    };
  } catch (e) {
    throw new NodeNestingTransformError('Failed to encode nested table node');
  }
};