"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractAllowedContent = extractAllowedContent;
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
function extractAllowedContent(validatorSpecs, entity) {
  // Filter out content type + irrelevant nodes
  var potentialAllowedContent = Object.entries(validatorSpecs).filter(function (item) {
    var _item = (0, _slicedToArray2.default)(item, 2),
      node = _item[0],
      value = _item[1];
    if (isValidatorSpec(value)) {
      return node === entity.type;
    }
    var _ref = [value[0], value[1]],
      nodeName = _ref[0],
      spec = _ref[1];
    if (typeof spec === 'string' || (0, _typeof2.default)(spec) !== 'object') {
      return false;
    }
    return nodeName === entity.type;
  });

  // Keep types such as `mediaSingle_full` which contain additional spec information
  var contentArray = potentialAllowedContent.map(function (allowedContent) {
    if (isValidatorSpec(allowedContent)) {
      return undefined;
    }
    var value = allowedContent[1];
    return !isValidatorSpec(value) ? [[value[0], value[1]]] : undefined;
  });
  return contentArray.filter(function (x) {
    return !!x;
  });
}
function isValidatorSpec(spec) {
  return spec.props !== undefined || spec.required !== undefined || spec.maxItems !== undefined || spec.minItems !== undefined;
}