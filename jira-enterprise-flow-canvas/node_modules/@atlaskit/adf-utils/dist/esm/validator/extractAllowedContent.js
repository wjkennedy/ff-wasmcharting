import _typeof from "@babel/runtime/helpers/typeof";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
export function extractAllowedContent(validatorSpecs, entity) {
  // Filter out content type + irrelevant nodes
  var potentialAllowedContent = Object.entries(validatorSpecs).filter(function (item) {
    var _item = _slicedToArray(item, 2),
      node = _item[0],
      value = _item[1];
    if (isValidatorSpec(value)) {
      return node === entity.type;
    }
    var _ref = [value[0], value[1]],
      nodeName = _ref[0],
      spec = _ref[1];
    if (typeof spec === 'string' || _typeof(spec) !== 'object') {
      return false;
    }
    return nodeName === entity.type;
  });

  // Keep types such as `mediaSingle_full` which contain additional spec information
  var contentArray = potentialAllowedContent.map(function (allowedContent) {
    if (isValidatorSpec(allowedContent)) {
      return undefined;
    }
    var value = allowedContent[1];
    return !isValidatorSpec(value) ? [[value[0], value[1]]] : undefined;
  });
  return contentArray.filter(function (x) {
    return !!x;
  });
}
function isValidatorSpec(spec) {
  return spec.props !== undefined || spec.required !== undefined || spec.maxItems !== undefined || spec.minItems !== undefined;
}