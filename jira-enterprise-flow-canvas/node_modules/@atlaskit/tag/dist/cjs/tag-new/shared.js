/* shared.tsx generated by @compiled/babel-plugin v0.38.1 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LinkWrapper = LinkWrapper;
exports.RemovableWrapper = RemovableWrapper;
exports.noop = exports.iconTokenVar = exports.iconColorVar = exports.defaultBeforeRemoveAction = exports.borderTokenVar = exports.TagStatus = void 0;
exports.useButtonInteraction = useButtonInteraction;
exports.useLink = useLink;
exports.useRemoveButton = useRemoveButton;
exports.useTagRemoval = useTagRemoval;
var _react = _interopRequireWildcard(require("react"));
var React = _react;
var _runtime = require("@compiled/react/runtime");
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _noop = _interopRequireDefault(require("@atlaskit/ds-lib/noop"));
var _link = _interopRequireDefault(require("@atlaskit/link"));
var _motion = require("@atlaskit/motion");
var _removeButton = _interopRequireDefault(require("../tag/internal/removable/remove-button"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
/**
 * Shared utilities for TagNew and AvatarTag components.
 * Note: CSS styles cannot be shared due to Compiled CSS static analysis requirements.
 */
// CSS variable names for dynamic color values
var iconColorVar = exports.iconColorVar = '--ds-tag-icon';
var borderTokenVar = exports.borderTokenVar = '--tag-border-token';
var iconTokenVar = exports.iconTokenVar = '--tag-icon-token';

// Tag status enum
var TagStatus = exports.TagStatus = /*#__PURE__*/function (TagStatus) {
  TagStatus["Showing"] = "showing";
  TagStatus["Removing"] = "removing";
  TagStatus["Removed"] = "removed";
  return TagStatus;
}({});
var defaultBeforeRemoveAction = exports.defaultBeforeRemoveAction = function defaultBeforeRemoveAction() {
  return true;
};
var noop = exports.noop = _noop.default;

// Shared hook for tag removal logic
// TODO: Fill in the hook {description}.
/**
 * {description}.
 */
function useTagRemoval(text, onBeforeRemoveAction, onAfterRemoveAction) {
  var _useState = (0, _react.useState)(TagStatus.Showing),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    status = _useState2[0],
    setStatus = _useState2[1];
  var handleRemoveComplete = (0, _react.useCallback)(function () {
    (onAfterRemoveAction !== null && onAfterRemoveAction !== void 0 ? onAfterRemoveAction : noop)(text);
    setStatus(TagStatus.Removed);
  }, [onAfterRemoveAction, text]);
  var handleRemoveRequest = (0, _react.useCallback)(function () {
    var beforeAction = onBeforeRemoveAction !== null && onBeforeRemoveAction !== void 0 ? onBeforeRemoveAction : defaultBeforeRemoveAction;
    if (beforeAction()) {
      handleRemoveComplete();
    }
  }, [handleRemoveComplete, onBeforeRemoveAction]);
  var onKeyPress = (0, _react.useCallback)(function (e) {
    var spacebarOrEnter = e.key === ' ' || e.key === 'Enter';
    if (spacebarOrEnter) {
      e.stopPropagation();
      handleRemoveRequest();
    }
  }, [handleRemoveRequest]);
  var removingTag = (0, _react.useCallback)(function () {
    return setStatus(TagStatus.Removing);
  }, []);
  var showingTag = (0, _react.useCallback)(function () {
    return setStatus(TagStatus.Showing);
  }, []);
  return {
    status: status,
    handleRemoveRequest: handleRemoveRequest,
    onKeyPress: onKeyPress,
    removingTag: removingTag,
    showingTag: showingTag
  };
}

// useLink hook
/**
 * Shared hook for link handling
 */
function useLink(href, linkComponent) {
  var isLink = Boolean(href);
  var LinkComponent = linkComponent !== null && linkComponent !== void 0 ? linkComponent : _link.default;
  return {
    isLink: isLink,
    LinkComponent: LinkComponent
  };
}
/**
 * Hook for tracking link/button hover/focus state (replaces CSS :has() selectors in this component)
 */
function useButtonInteraction() {
  var _useState3 = (0, _react.useState)(false),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    isLinkHovered = _useState4[0],
    setIsLinkHovered = _useState4[1];
  var _useState5 = (0, _react.useState)(false),
    _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
    isOverButton = _useState6[0],
    setIsOverButton = _useState6[1];
  var _useState7 = (0, _react.useState)(false),
    _useState8 = (0, _slicedToArray2.default)(_useState7, 2),
    isButtonFocused = _useState8[0],
    setIsButtonFocused = _useState8[1];
  var _useState9 = (0, _react.useState)(false),
    _useState0 = (0, _slicedToArray2.default)(_useState9, 2),
    isLinkFocused = _useState0[0],
    setIsLinkFocused = _useState0[1];
  // Track if last interaction was via mouse (to determine keyboard vs mouse focus)
  var hadMouseDownRef = (0, _react.useRef)(false);

  // Button handlers
  var buttonHandlers = (0, _react.useMemo)(function () {
    return {
      onMouseEnter: function onMouseEnter() {
        return setIsOverButton(true);
      },
      onMouseLeave: function onMouseLeave() {
        return setIsOverButton(false);
      },
      onMouseDown: function onMouseDown() {
        hadMouseDownRef.current = true;
      },
      onFocus: function onFocus() {
        // Only track keyboard focus for focus ring styles
        // If mousedown happened just before focus, it's mouse focus (not keyboard)
        if (!hadMouseDownRef.current) {
          setIsButtonFocused(true);
        }
        hadMouseDownRef.current = false;
      },
      onBlur: function onBlur() {
        return setIsButtonFocused(false);
      }
    };
  }, []);

  // Link handlers - includes hover tracking
  var linkHandlers = (0, _react.useMemo)(function () {
    return {
      onMouseEnter: function onMouseEnter() {
        return setIsLinkHovered(true);
      },
      onMouseLeave: function onMouseLeave() {
        return setIsLinkHovered(false);
      },
      onMouseDown: function onMouseDown() {
        hadMouseDownRef.current = true;
      },
      onFocus: function onFocus() {
        // Only track keyboard focus for focus ring styles
        // If mousedown happened just before focus, it's mouse focus (not keyboard)
        if (!hadMouseDownRef.current) {
          setIsLinkFocused(true);
        }
        hadMouseDownRef.current = false;
      },
      onBlur: function onBlur() {
        return setIsLinkFocused(false);
      }
    };
  }, []);
  return {
    isLinkHovered: isLinkHovered,
    isOverButton: isOverButton,
    isButtonFocused: isButtonFocused,
    isLinkFocused: isLinkFocused,
    buttonHandlers: buttonHandlers,
    linkHandlers: linkHandlers
  };
}

// Props for the remove button hook

// Shared hook for remove button creation
// TODO: Fill in the hook {description}.
/**
 * {description}.
 */
function useRemoveButton(_ref) {
  var isRemovable = _ref.isRemovable,
    tagText = _ref.tagText,
    removeButtonLabel = _ref.removeButtonLabel,
    testId = _ref.testId,
    handleRemoveRequest = _ref.handleRemoveRequest,
    removingTag = _ref.removingTag,
    showingTag = _ref.showingTag,
    onKeyPress = _ref.onKeyPress,
    _ref$shape = _ref.shape,
    shape = _ref$shape === void 0 ? 'default' : _ref$shape,
    buttonHandlers = _ref.buttonHandlers;
  var handleFocus = (0, _react.useCallback)(function () {
    removingTag();
    buttonHandlers === null || buttonHandlers === void 0 || buttonHandlers.onFocus();
  }, [removingTag, buttonHandlers]);
  var handleBlur = (0, _react.useCallback)(function () {
    showingTag();
    buttonHandlers === null || buttonHandlers === void 0 || buttonHandlers.onBlur();
  }, [showingTag, buttonHandlers]);
  return (0, _react.useMemo)(function () {
    if (!isRemovable) {
      return undefined;
    }
    return /*#__PURE__*/React.createElement(_removeButton.default, {
      "aria-label": "".concat(removeButtonLabel || 'Remove', " ").concat(tagText),
      onClick: handleRemoveRequest,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyPress: onKeyPress,
      onMouseEnter: buttonHandlers === null || buttonHandlers === void 0 ? void 0 : buttonHandlers.onMouseEnter,
      onMouseLeave: buttonHandlers === null || buttonHandlers === void 0 ? void 0 : buttonHandlers.onMouseLeave,
      onMouseDown: buttonHandlers === null || buttonHandlers === void 0 ? void 0 : buttonHandlers.onMouseDown,
      testId: testId ? "close-button-".concat(testId) : undefined,
      shape: shape
    });
  }, [isRemovable, removeButtonLabel, tagText, handleRemoveRequest, handleFocus, handleBlur, onKeyPress, buttonHandlers, testId, shape]);
}

// Props for the removable wrapper

// Shared component for motion wrapper
function RemovableWrapper(_ref2) {
  var isRemovable = _ref2.isRemovable,
    status = _ref2.status,
    children = _ref2.children;
  if (isRemovable) {
    return /*#__PURE__*/React.createElement(_motion.ExitingPersistence, null, !(status === TagStatus.Removed) && /*#__PURE__*/React.createElement(_motion.ShrinkOut, null, function (motion) {
      return /*#__PURE__*/React.createElement("span", {
        ref: motion.ref
      }, children);
    }));
  }
  return children;
}

// Props for the link wrapper

// Shared component for conditional link wrapping
function LinkWrapper(_ref3) {
  var isLink = _ref3.isLink,
    href = _ref3.href,
    LinkComponent = _ref3.LinkComponent,
    testId = _ref3.testId,
    children = _ref3.children,
    linkHandlers = _ref3.linkHandlers;
  if (isLink && href) {
    return /*#__PURE__*/React.createElement(LinkComponent, {
      href: href,
      testId: testId ? "".concat(testId, "--link") : undefined,
      onMouseEnter: linkHandlers === null || linkHandlers === void 0 ? void 0 : linkHandlers.onMouseEnter,
      onMouseLeave: linkHandlers === null || linkHandlers === void 0 ? void 0 : linkHandlers.onMouseLeave,
      onMouseDown: linkHandlers === null || linkHandlers === void 0 ? void 0 : linkHandlers.onMouseDown,
      onFocus: linkHandlers === null || linkHandlers === void 0 ? void 0 : linkHandlers.onFocus,
      onBlur: linkHandlers === null || linkHandlers === void 0 ? void 0 : linkHandlers.onBlur
    }, children);
  }
  return /*#__PURE__*/React.createElement(_react.Fragment, null, children);
}