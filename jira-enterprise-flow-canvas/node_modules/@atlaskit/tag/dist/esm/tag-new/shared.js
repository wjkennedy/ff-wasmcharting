/* shared.tsx generated by @compiled/babel-plugin v0.38.1 */
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import * as React from 'react';
import { ax, ix } from "@compiled/react/runtime";
/**
 * Shared utilities for TagNew and AvatarTag components.
 * Note: CSS styles cannot be shared due to Compiled CSS static analysis requirements.
 */
import { Fragment, useCallback, useMemo, useRef, useState } from 'react';
import __noop from '@atlaskit/ds-lib/noop';
import Link from '@atlaskit/link';
import { ExitingPersistence, ShrinkOut } from '@atlaskit/motion';
import RemoveButton from '../tag/internal/removable/remove-button';

// CSS variable names for dynamic color values
export var iconColorVar = '--ds-tag-icon';
export var borderTokenVar = '--tag-border-token';
export var iconTokenVar = '--tag-icon-token';

// Tag status enum
export var TagStatus = /*#__PURE__*/function (TagStatus) {
  TagStatus["Showing"] = "showing";
  TagStatus["Removing"] = "removing";
  TagStatus["Removed"] = "removed";
  return TagStatus;
}({});
export var defaultBeforeRemoveAction = function defaultBeforeRemoveAction() {
  return true;
};
export var noop = __noop;

// Shared hook for tag removal logic
// TODO: Fill in the hook {description}.
/**
 * {description}.
 */
export function useTagRemoval(text, onBeforeRemoveAction, onAfterRemoveAction) {
  var _useState = useState(TagStatus.Showing),
    _useState2 = _slicedToArray(_useState, 2),
    status = _useState2[0],
    setStatus = _useState2[1];
  var handleRemoveComplete = useCallback(function () {
    (onAfterRemoveAction !== null && onAfterRemoveAction !== void 0 ? onAfterRemoveAction : noop)(text);
    setStatus(TagStatus.Removed);
  }, [onAfterRemoveAction, text]);
  var handleRemoveRequest = useCallback(function () {
    var beforeAction = onBeforeRemoveAction !== null && onBeforeRemoveAction !== void 0 ? onBeforeRemoveAction : defaultBeforeRemoveAction;
    if (beforeAction()) {
      handleRemoveComplete();
    }
  }, [handleRemoveComplete, onBeforeRemoveAction]);
  var onKeyPress = useCallback(function (e) {
    var spacebarOrEnter = e.key === ' ' || e.key === 'Enter';
    if (spacebarOrEnter) {
      e.stopPropagation();
      handleRemoveRequest();
    }
  }, [handleRemoveRequest]);
  var removingTag = useCallback(function () {
    return setStatus(TagStatus.Removing);
  }, []);
  var showingTag = useCallback(function () {
    return setStatus(TagStatus.Showing);
  }, []);
  return {
    status: status,
    handleRemoveRequest: handleRemoveRequest,
    onKeyPress: onKeyPress,
    removingTag: removingTag,
    showingTag: showingTag
  };
}

// useLink hook
/**
 * Shared hook for link handling
 */
export function useLink(href, linkComponent) {
  var isLink = Boolean(href);
  var LinkComponent = linkComponent !== null && linkComponent !== void 0 ? linkComponent : Link;
  return {
    isLink: isLink,
    LinkComponent: LinkComponent
  };
}
/**
 * Hook for tracking link/button hover/focus state (replaces CSS :has() selectors in this component)
 */
export function useButtonInteraction() {
  var _useState3 = useState(false),
    _useState4 = _slicedToArray(_useState3, 2),
    isLinkHovered = _useState4[0],
    setIsLinkHovered = _useState4[1];
  var _useState5 = useState(false),
    _useState6 = _slicedToArray(_useState5, 2),
    isOverButton = _useState6[0],
    setIsOverButton = _useState6[1];
  var _useState7 = useState(false),
    _useState8 = _slicedToArray(_useState7, 2),
    isButtonFocused = _useState8[0],
    setIsButtonFocused = _useState8[1];
  var _useState9 = useState(false),
    _useState0 = _slicedToArray(_useState9, 2),
    isLinkFocused = _useState0[0],
    setIsLinkFocused = _useState0[1];
  // Track if last interaction was via mouse (to determine keyboard vs mouse focus)
  var hadMouseDownRef = useRef(false);

  // Button handlers
  var buttonHandlers = useMemo(function () {
    return {
      onMouseEnter: function onMouseEnter() {
        return setIsOverButton(true);
      },
      onMouseLeave: function onMouseLeave() {
        return setIsOverButton(false);
      },
      onMouseDown: function onMouseDown() {
        hadMouseDownRef.current = true;
      },
      onFocus: function onFocus() {
        // Only track keyboard focus for focus ring styles
        // If mousedown happened just before focus, it's mouse focus (not keyboard)
        if (!hadMouseDownRef.current) {
          setIsButtonFocused(true);
        }
        hadMouseDownRef.current = false;
      },
      onBlur: function onBlur() {
        return setIsButtonFocused(false);
      }
    };
  }, []);

  // Link handlers - includes hover tracking
  var linkHandlers = useMemo(function () {
    return {
      onMouseEnter: function onMouseEnter() {
        return setIsLinkHovered(true);
      },
      onMouseLeave: function onMouseLeave() {
        return setIsLinkHovered(false);
      },
      onMouseDown: function onMouseDown() {
        hadMouseDownRef.current = true;
      },
      onFocus: function onFocus() {
        // Only track keyboard focus for focus ring styles
        // If mousedown happened just before focus, it's mouse focus (not keyboard)
        if (!hadMouseDownRef.current) {
          setIsLinkFocused(true);
        }
        hadMouseDownRef.current = false;
      },
      onBlur: function onBlur() {
        return setIsLinkFocused(false);
      }
    };
  }, []);
  return {
    isLinkHovered: isLinkHovered,
    isOverButton: isOverButton,
    isButtonFocused: isButtonFocused,
    isLinkFocused: isLinkFocused,
    buttonHandlers: buttonHandlers,
    linkHandlers: linkHandlers
  };
}

// Props for the remove button hook

// Shared hook for remove button creation
// TODO: Fill in the hook {description}.
/**
 * {description}.
 */
export function useRemoveButton(_ref) {
  var isRemovable = _ref.isRemovable,
    tagText = _ref.tagText,
    removeButtonLabel = _ref.removeButtonLabel,
    testId = _ref.testId,
    handleRemoveRequest = _ref.handleRemoveRequest,
    removingTag = _ref.removingTag,
    showingTag = _ref.showingTag,
    onKeyPress = _ref.onKeyPress,
    _ref$shape = _ref.shape,
    shape = _ref$shape === void 0 ? 'default' : _ref$shape,
    buttonHandlers = _ref.buttonHandlers;
  var handleFocus = useCallback(function () {
    removingTag();
    buttonHandlers === null || buttonHandlers === void 0 || buttonHandlers.onFocus();
  }, [removingTag, buttonHandlers]);
  var handleBlur = useCallback(function () {
    showingTag();
    buttonHandlers === null || buttonHandlers === void 0 || buttonHandlers.onBlur();
  }, [showingTag, buttonHandlers]);
  return useMemo(function () {
    if (!isRemovable) {
      return undefined;
    }
    return /*#__PURE__*/React.createElement(RemoveButton, {
      "aria-label": "".concat(removeButtonLabel || 'Remove', " ").concat(tagText),
      onClick: handleRemoveRequest,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyPress: onKeyPress,
      onMouseEnter: buttonHandlers === null || buttonHandlers === void 0 ? void 0 : buttonHandlers.onMouseEnter,
      onMouseLeave: buttonHandlers === null || buttonHandlers === void 0 ? void 0 : buttonHandlers.onMouseLeave,
      onMouseDown: buttonHandlers === null || buttonHandlers === void 0 ? void 0 : buttonHandlers.onMouseDown,
      testId: testId ? "close-button-".concat(testId) : undefined,
      shape: shape
    });
  }, [isRemovable, removeButtonLabel, tagText, handleRemoveRequest, handleFocus, handleBlur, onKeyPress, buttonHandlers, testId, shape]);
}

// Props for the removable wrapper

// Shared component for motion wrapper
export function RemovableWrapper(_ref2) {
  var isRemovable = _ref2.isRemovable,
    status = _ref2.status,
    children = _ref2.children;
  if (isRemovable) {
    return /*#__PURE__*/React.createElement(ExitingPersistence, null, !(status === TagStatus.Removed) && /*#__PURE__*/React.createElement(ShrinkOut, null, function (motion) {
      return /*#__PURE__*/React.createElement("span", {
        ref: motion.ref
      }, children);
    }));
  }
  return children;
}

// Props for the link wrapper

// Shared component for conditional link wrapping
export function LinkWrapper(_ref3) {
  var isLink = _ref3.isLink,
    href = _ref3.href,
    LinkComponent = _ref3.LinkComponent,
    testId = _ref3.testId,
    children = _ref3.children,
    linkHandlers = _ref3.linkHandlers;
  if (isLink && href) {
    return /*#__PURE__*/React.createElement(LinkComponent, {
      href: href,
      testId: testId ? "".concat(testId, "--link") : undefined,
      onMouseEnter: linkHandlers === null || linkHandlers === void 0 ? void 0 : linkHandlers.onMouseEnter,
      onMouseLeave: linkHandlers === null || linkHandlers === void 0 ? void 0 : linkHandlers.onMouseLeave,
      onMouseDown: linkHandlers === null || linkHandlers === void 0 ? void 0 : linkHandlers.onMouseDown,
      onFocus: linkHandlers === null || linkHandlers === void 0 ? void 0 : linkHandlers.onFocus,
      onBlur: linkHandlers === null || linkHandlers === void 0 ? void 0 : linkHandlers.onBlur
    }, children);
  }
  return /*#__PURE__*/React.createElement(Fragment, null, children);
}