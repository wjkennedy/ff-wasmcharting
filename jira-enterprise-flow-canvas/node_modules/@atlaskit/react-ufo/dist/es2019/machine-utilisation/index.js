const BUFFER_MAX_LENGTH = 1000; // ensure we don't blow up this buffer
let pressureRecordBuffer = [];
let pressureObserver = null;
let memoryRecordBuffer = [];
let memoryInterval;
export function resetPressureRecordBuffer() {
  pressureRecordBuffer.length = 0;
}
export function resetMemoryRecordBuffer() {
  memoryRecordBuffer.length = 0;
}
export function removeOldPressureBufferRecords(filter) {
  pressureRecordBuffer = pressureRecordBuffer.filter(({
    time
  }) => time > filter);
}
export function removeOldMemoryBufferRecords(filter) {
  memoryRecordBuffer = memoryRecordBuffer.filter(({
    time
  }) => time > filter);
}
export function createPressureStateReport(start, end) {
  try {
    // To differentiate between the API not available, vs no PressureRecords added
    if (!('PressureObserver' in globalThis)) {
      return null;
    }
    const pressureStateCount = pressureRecordBuffer.reduce((pressureReport, {
      time,
      state
    }) => {
      if (time >= start && time <= end) {
        pressureReport[state] += 1;
      }
      return pressureReport;
    }, {
      nominal: 0,
      fair: 0,
      serious: 0,
      critical: 0
    });
    const pressureStateTotal = Object.values(pressureStateCount).reduce((total, count) => total + count) || 1;
    removeOldPressureBufferRecords(end);
    return {
      count: pressureStateCount,
      percentage: {
        nominal: Math.round(pressureStateCount.nominal / pressureStateTotal * 100),
        fair: Math.round(pressureStateCount.fair / pressureStateTotal * 100),
        serious: Math.round(pressureStateCount.serious / pressureStateTotal * 100),
        critical: Math.round(pressureStateCount.critical / pressureStateTotal * 100)
      }
    };
  } catch {
    return null;
  }
}
function convertBytesToMegabytes(bytes) {
  return Math.round(Math.round(bytes / (1024 * 1024) * 100) / 100);
}
export function createMemoryStateReport(start, end) {
  try {
    if (!('memory' in performance)) {
      return null;
    }
    const accumulatedMemoryUsage = memoryRecordBuffer.reduce((acc, snapshot) => {
      if (snapshot.time >= start && snapshot.time <= end) {
        acc.totalJSHeapSize += snapshot.totalJSHeapSize;
        acc.usedJSHeapSize += snapshot.usedJSHeapSize;
        acc.snapshotCount += 1;
      }
      return acc;
    }, {
      totalJSHeapSize: 0,
      usedJSHeapSize: 0,
      snapshotCount: 0
    });
    const memoryStateReport = {
      jsHeapSizeLimitInMB: convertBytesToMegabytes(memoryRecordBuffer[0].jsHeapSizeLimit),
      // just use the first record, since this value always remains the same over time
      avgTotalJSHeapSizeInMB: convertBytesToMegabytes(accumulatedMemoryUsage.totalJSHeapSize / accumulatedMemoryUsage.snapshotCount),
      avgUsedJSHeapSizeInMB: convertBytesToMegabytes(accumulatedMemoryUsage.usedJSHeapSize / accumulatedMemoryUsage.snapshotCount)
    };
    removeOldMemoryBufferRecords(end);
    return memoryStateReport;
  } catch {
    return null;
  }
}
export function initialisePressureObserver() {
  try {
    if ('PressureObserver' in globalThis) {
      pressureObserver = new PressureObserver(records => {
        if (pressureRecordBuffer.length + records.length <= BUFFER_MAX_LENGTH) {
          pressureRecordBuffer.push(...records);
        }
      });
      pressureObserver.observe('cpu', {
        sampleInterval: 100
      }).catch(() => {
        // Silently handle permission policy restrictions or other observe failures
        // This prevents unhandled promise rejections from being reported to Sentry
      });
    }
  } catch {
    /* do nothing, this is a best efforts metric */
  }
}
export function initialiseMemoryObserver() {
  try {
    // only set up the interval if `performance.memory` is available in the browser
    if ('memory' in performance) {
      memoryInterval = setInterval(() => {
        // another check of `performance.memory` availability to satisfy typescript
        if ('memory' in performance) {
          const memory = performance.memory;
          if (memoryRecordBuffer.length <= BUFFER_MAX_LENGTH) {
            memoryRecordBuffer.push({
              time: performance.now(),
              jsHeapSizeLimit: memory.jsHeapSizeLimit,
              totalJSHeapSize: memory.totalJSHeapSize,
              usedJSHeapSize: memory.usedJSHeapSize
            });
          }
        }
      }, 100);
    }
  } catch {
    /* do nothing, this is a best efforts metric */
  }
}
export function disconnectMemoryObserver() {
  clearInterval(memoryInterval);
}
export function disconnectPressureObserver() {
  var _pressureObserver;
  (_pressureObserver = pressureObserver) === null || _pressureObserver === void 0 ? void 0 : _pressureObserver.disconnect();
}