import React, { Profiler, useCallback, useContext, useEffect, useMemo, useRef } from 'react';
import { unstable_NormalPriority as NormalPriority, unstable_scheduleCallback as scheduleCallback } from 'scheduler';
// eslint-disable-next-line @atlaskit/platform/prefer-crypto-random-uuid -- Use crypto.randomUUID instead
import { v4 as createUUID } from 'uuid';
import { fg } from '@atlaskit/platform-feature-flags';
import coinflip from '../coinflip';
import { getConfig, getDoNotAbortActivePressInteraction, getInteractionRate, getMinorInteractions } from '../config';
import { getActiveTrace, setInteractionActiveTrace } from '../experience-trace-id-context';
import UFOInteractionContext from '../interaction-context';
import UFOInteractionIDContext from '../interaction-id-context';
import { abortByNewInteraction, addApdex, addCustomData, addCustomTiming, addHold, addHoldByID, addMark, addNewInteraction, addProfilerTimings, addRequestInfo, addSegment, addSpan, getActiveInteraction, markFirstSegmentLoad, removeHoldByID, removeSegment, tryComplete } from '../interaction-metrics';
import UFORouteName from '../route-name-context';
import generateId from '../short-id';
import scheduleOnPaint from './schedule-on-paint';
import SsrRenderProfiler from './ssr-render-profiler';
let tryCompleteHandle;
let hasMarkedFirstSegmentLoad = false;

/** A portion of the page we apply measurement to */
export default function UFOSegment({
  name: segmentName,
  children,
  mode = 'single',
  type = 'first-party'
}) {
  const parentContext = useContext(UFOInteractionContext);
  const segmentIdMap = useMemo(() => {
    if (!(parentContext !== null && parentContext !== void 0 && parentContext.segmentIdMap)) {
      return new Map();
    }
    return parentContext.segmentIdMap;
  }, [parentContext]);
  const segmentId = useMemo(() => {
    if (mode === 'single') {
      return generateId();
    }
    if (segmentIdMap.has(segmentName)) {
      return segmentIdMap.get(segmentName);
    }
    const newSegmentId = generateId();
    segmentIdMap.set(segmentName, newSegmentId);
    return newSegmentId;
  }, [mode, segmentName, segmentIdMap]);
  const labelStack = useMemo(() => parentContext !== null && parentContext !== void 0 && parentContext.labelStack ? [...parentContext.labelStack, {
    name: segmentName,
    segmentId,
    ...(type !== 'first-party' ? {
      type
    } : {})
  } // Only pass non-default types (not 'first-party') in payload to reduce size
  ] : [{
    name: segmentName,
    segmentId,
    ...(type !== 'first-party' ? {
      type
    } : {})
  }], [parentContext, segmentName, segmentId, type]);
  const interactionId = useContext(UFOInteractionIDContext);
  if (interactionId.current != null && !hasMarkedFirstSegmentLoad) {
    markFirstSegmentLoad(interactionId.current, labelStack, performance.now());
    hasMarkedFirstSegmentLoad = true;
  }
  const interactionContext = useMemo(() => {
    let lastCompleteEndTime = 0;
    function complete(endTime = performance.now()) {
      if (interactionId.current) {
        if (parentContext) {
          parentContext.complete();
        } else {
          const capturedInteractionId = interactionId.current;
          if (endTime > lastCompleteEndTime) {
            lastCompleteEndTime = endTime;
          }
          if (tryCompleteHandle) {
            var _cancelAnimationFrame;
            (_cancelAnimationFrame = cancelAnimationFrame) === null || _cancelAnimationFrame === void 0 ? void 0 : _cancelAnimationFrame(tryCompleteHandle);
          }
          const onComplete = () => {
            if (capturedInteractionId === interactionId.current) {
              var _globalThis$document;
              const isPageVisible = (globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.visibilityState) === 'visible';
              const canDoRAF = typeof requestAnimationFrame !== 'undefined';
              if (isPageVisible && canDoRAF) {
                tryCompleteHandle = requestAnimationFrame(() => {
                  tryCompleteHandle = requestAnimationFrame(() => {
                    if (capturedInteractionId === interactionId.current) {
                      tryComplete(interactionId.current, lastCompleteEndTime);
                    }
                  });
                });
              } else {
                tryComplete(interactionId.current, lastCompleteEndTime);
              }
            }
          };
          scheduleCallback(NormalPriority, onComplete);
        }
      }
    }
    function _internalHold(labelStack, name, experimental = false) {
      if (interactionId.current != null) {
        if (parentContext) {
          return parentContext._internalHold(labelStack, name, experimental);
        } else {
          const capturedInteractionId = interactionId.current;
          const disposeHold = addHold(interactionId.current, labelStack, name, experimental);
          return () => {
            if (capturedInteractionId === interactionId.current) {
              disposeHold();
            }
          };
        }
      }
    }
    function _internalHoldByID(labelStack, id, name, remove) {
      if (interactionId.current != null) {
        if (parentContext) {
          parentContext._internalHoldByID(labelStack, name, id, remove);
          return;
        }
        if (!remove) {
          addHoldByID(interactionId.current, labelStack, name, id);
        } else {
          removeHoldByID(interactionId.current, id);
        }
      }
    }
    if (parentContext) {
      return {
        ...parentContext,
        labelStack,
        complete
      };
    }
    return {
      labelStack,
      segmentIdMap: segmentIdMap,
      hold(name = 'unknown') {
        return this._internalHold(this.labelStack, name);
      },
      holdExperimental(name = 'unknown') {
        return this._internalHold(this.labelStack, name, true);
      },
      addHoldByID(labelStack, id, name = 'unknown') {
        this._internalHoldByID(labelStack, id, name, false);
      },
      removeHoldByID(labelStack, id, name = 'unknown') {
        this._internalHoldByID(labelStack, id, name, true);
      },
      tracePress(name = 'unknown', timestamp) {
        var _getDoNotAbortActiveP, _getMinorInteractions;
        const minorInteractions = [...((_getDoNotAbortActiveP = getDoNotAbortActivePressInteraction()) !== null && _getDoNotAbortActiveP !== void 0 ? _getDoNotAbortActiveP : []), ...((_getMinorInteractions = getMinorInteractions()) !== null && _getMinorInteractions !== void 0 ? _getMinorInteractions : [])];
        if (minorInteractions.includes(name)) {
          var _activeInteraction$mi;
          const activeInteraction = getActiveInteraction();
          activeInteraction === null || activeInteraction === void 0 ? void 0 : (_activeInteraction$mi = activeInteraction.minorInteractions) === null || _activeInteraction$mi === void 0 ? void 0 : _activeInteraction$mi.push({
            name,
            startTime: timestamp !== null && timestamp !== void 0 ? timestamp : performance.now()
          });
          return;
        } else if (interactionId.current != null) {
          abortByNewInteraction(interactionId.current, name);
        }
        const rate = getInteractionRate(name, 'press');
        if (coinflip(rate)) {
          const startTimestamp = timestamp !== null && timestamp !== void 0 ? timestamp : performance.now();
          // eslint-disable-next-line @atlaskit/platform/prefer-crypto-random-uuid -- Use crypto.randomUUID instead
          const newId = createUUID();
          interactionId.current = newId;
          // covered experiences with tracing instrumentation:
          // inline-result.global-issue.create-modal.submit
          // inline-result.global-issue.create-modal-subsequent
          setInteractionActiveTrace(newId, 'press');
          addNewInteraction(newId, name, 'press', startTimestamp, rate, this.labelStack, UFORouteName.current, getActiveTrace());
        }
      },
      retainQuery(info) {
        if (interactionId.current != null) {
          addRequestInfo(interactionId.current, this.labelStack, info);
        }
      },
      addPreload(moduleId, timestamp) {
        if (interactionId.current != null) {
          addMark(interactionId.current, 'bundle_preload', moduleId, this.labelStack, timestamp);
        }
      },
      addLoad(identifier, start, end) {
        if (interactionId.current != null) {
          const {
            labelStack = []
          } = this;
          addSpan(interactionId.current, 'bundle_load', identifier, labelStack, start, end);
        }
      },
      addMark(name, timestamp
      // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
      ) {
        if (interactionId.current != null) {
          const time = timestamp !== null && timestamp !== void 0 ? timestamp : performance.now();
          addMark(interactionId.current, 'custom', name, this.labelStack, time);
        }
      },
      addCustomData(customData) {
        if (interactionId.current != null) {
          addCustomData(interactionId.current, this.labelStack, customData);
        }
      },
      addCustomTimings(customTimings) {
        if (interactionId.current != null) {
          addCustomTiming(interactionId.current, this.labelStack, customTimings);
        }
      },
      addApdex(apdexInfo) {
        if (interactionId.current != null) {
          const {
            key,
            stopTime,
            startTime
          } = apdexInfo;
          addApdex(interactionId.current, {
            key,
            stopTime,
            startTime,
            labelStack: this.labelStack
          });
        }
      },
      onRender(phase, actualDuration, baseDuration, startTime, commitTime) {
        if (interactionId.current !== null) {
          addProfilerTimings(interactionId.current, this.labelStack, phase, actualDuration, baseDuration, startTime, commitTime);
          scheduleOnPaint(() => {
            const paintedTime = performance.now();
            this.complete(paintedTime);
          });
        }
      },
      _internalHold,
      _internalHoldByID,
      complete
    };
  }, [parentContext, labelStack, segmentIdMap, interactionId]);
  const hasMounted = useRef(false);
  const onRender = useCallback((_id, phase, actualDuration, baseDuration, startTime, commitTime) => {
    var _getConfig;
    // Manually keep track of mount-phase, and ensure that every segment is always mounted at least once
    if ((_getConfig = getConfig()) !== null && _getConfig !== void 0 && _getConfig.manuallyTrackReactProfilerMounts && !hasMounted.current) {
      interactionContext.onRender('mount', actualDuration, baseDuration, startTime, commitTime);
      hasMounted.current = true;
    } else {
      interactionContext.onRender(phase, actualDuration, baseDuration, startTime, commitTime);
    }
  }, [interactionContext]);
  useEffect(() => {
    addSegment(labelStack);
    return () => {
      removeSegment(labelStack);
    };
  }, [interactionId, parentContext, interactionContext, labelStack]);
  const reactProfilerId = useMemo(() => labelStack.map(l => l.name).join('/'), [labelStack]);
  const ufoSegment = /*#__PURE__*/React.createElement(UFOInteractionContext.Provider, {
    value: interactionContext
  }, /*#__PURE__*/React.createElement(Profiler, {
    id: reactProfilerId,
    onRender: onRender
  }, children));
  if (fg('platform_ufo_ssr_render_profiler')) {
    return /*#__PURE__*/React.createElement(SsrRenderProfiler, {
      labelStack: labelStack,
      onRender: interactionContext.onRender
    }, ufoSegment);
  }
  return ufoSegment;
}
UFOSegment.displayName = 'UFOSegment';