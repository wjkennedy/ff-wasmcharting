import coinflip from '../../coinflip';
import { getConfig, getMostRecentVCRevision, getVCRawDataInteractionRate } from '../../config';
import { interactionExtraMetrics, postInteractionLog } from '../../interaction-metrics';
import getInteractionStatus from './get-interaction-status';
import getPageVisibilityUpToTTAI from './get-page-visibility-up-to-ttai';
import getSSRDoneTimeValue from './get-ssr-done-time-value';
async function getVCMetrics(interaction, include3p = false, excludeSmartAnswersInSearch = false) {
  var _config$vc, _config$vc$ssrWhiteli, _interaction$apdex, _interaction$apdex$, _config$vc2, _config$vc3, _result$ufoVcRev;
  const config = getConfig();
  if (!(config !== null && config !== void 0 && (_config$vc = config.vc) !== null && _config$vc !== void 0 && _config$vc.enabled)) {
    return {};
  }
  if (interaction.type !== 'page_load' && interaction.type !== 'transition' && interaction.type !== 'press') {
    return {};
  }
  const interactionStatus = getInteractionStatus(interaction);
  const pageVisibilityUpToTTAI = getPageVisibilityUpToTTAI(interaction);
  const isPageVisible = pageVisibilityUpToTTAI === 'visible';
  const shouldReportVCMetrics = interactionStatus.originalInteractionStatus === 'SUCCEEDED' && isPageVisible;

  // Use per-interaction VC observer if available, otherwise fall back to global
  const observer = interaction.vcObserver;
  if (!observer) {
    return {};
  }
  const includeRawData = coinflip(getVCRawDataInteractionRate(interaction.ufoName, interaction.type));
  const isSSREnabled = interaction.type === 'page_load' && ((config === null || config === void 0 ? void 0 : config.ssr) || (config === null || config === void 0 ? void 0 : (_config$vc$ssrWhiteli = config.vc.ssrWhitelist) === null || _config$vc$ssrWhiteli === void 0 ? void 0 : _config$vc$ssrWhiteli.includes(interaction.ufoName)));
  const ssr = interaction.type === 'page_load' && isSSREnabled ? {
    ssr: getSSRDoneTimeValue(config)
  } : null;
  postInteractionLog.setVCObserverSSRConfig(ssr);
  const tti = (_interaction$apdex = interaction.apdex) === null || _interaction$apdex === void 0 ? void 0 : (_interaction$apdex$ = _interaction$apdex[0]) === null || _interaction$apdex$ === void 0 ? void 0 : _interaction$apdex$.stopTime;
  const prefix = 'ufo';
  const result = await observer.getVCResult({
    start: interaction.start,
    stop: interaction.end,
    // Use end3p when available to capture raw data observations during 3p holds
    rawDataStopTime: interaction.end3p,
    tti,
    prefix,
    includeSSRInV3: (_config$vc2 = config.vc) === null || _config$vc2 === void 0 ? void 0 : _config$vc2.includeSSRInV3,
    vc: interaction.vc,
    isEventAborted: interactionStatus.originalInteractionStatus !== 'SUCCEEDED',
    experienceKey: interaction.ufoName,
    interactionId: interaction.id,
    includeSSRRatio: (_config$vc3 = config.vc) === null || _config$vc3 === void 0 ? void 0 : _config$vc3.includeSSRRatio,
    ...ssr,
    include3p,
    excludeSmartAnswersInSearch,
    interactionType: interaction.type,
    isPageVisible,
    includeRawData
  });
  observer.stop(interaction.ufoName);
  if (!include3p) {
    // For Post Interaction, last interaction should be without 3p
    postInteractionLog.setLastInteractionFinishVCResult(result);
    interactionExtraMetrics.setLastInteractionFinishVCResult(result);
  }
  const mostRecentVCRevision = getMostRecentVCRevision(interaction.ufoName);
  const mostRecentVCRevisionPayload = result === null || result === void 0 ? void 0 : (_result$ufoVcRev = result['ufo:vc:rev']) === null || _result$ufoVcRev === void 0 ? void 0 : _result$ufoVcRev.find(({
    revision
  }) => revision === mostRecentVCRevision);
  if (!shouldReportVCMetrics || !(mostRecentVCRevisionPayload !== null && mostRecentVCRevisionPayload !== void 0 && mostRecentVCRevisionPayload.clean)) {
    return result;
  }
  return {
    ...result,
    'metric:vc90': mostRecentVCRevisionPayload['metric:vc90']
  };
}
export default getVCMetrics;