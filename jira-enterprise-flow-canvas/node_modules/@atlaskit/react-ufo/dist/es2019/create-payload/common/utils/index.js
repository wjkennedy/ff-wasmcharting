import { fg } from '@atlaskit/platform-feature-flags';
import { getConfig } from '../../../config';
import { getReactUFOPayloadVersion } from '../../utils/get-react-ufo-payload-version';
export function sanitizeUfoName(name) {
  return name.replace(/_/g, '-');
}
export function isSegmentLabel(obj) {
  return obj && typeof obj.name === 'string' && typeof obj.segmentId === 'string';
}
export function buildSegmentTree(labelStacks) {
  const r = {
    n: 'segment-tree-root',
    c: {}
  };
  const config = getConfig();
  const segmentThreshold = config === null || config === void 0 ? void 0 : config.segmentsThreshold;
  const addSegmentsMap = new Map();
  if (fg('platform_ufo_add_segments_count_threshold')) {
    labelStacks.forEach(labelStack => {
      const stringifiedLabelStack = stringifyLabelStackWithoutId(labelStack);
      let currentNode = r;
      for (const label of labelStack) {
        const isSegment = isSegmentLabel(label);
        const name = label.name;
        if (isSegment && segmentThreshold && segmentThreshold[name]) {
          const threshold = segmentThreshold[name];
          const count = addSegmentsMap.get(stringifiedLabelStack) || 0;
          if (count < threshold) {
            addSegmentsMap.set(stringifiedLabelStack, count + 1);
          } else {
            break;
          }
        }
        const id = isSegment ? label.segmentId : undefined;
        const key = id !== undefined ? id : name;
        const type = isSegment ? label.type : undefined;
        if (!currentNode.c) {
          currentNode.c = {};
        }
        if (!currentNode.c[key]) {
          currentNode.c[key] = {
            n: name,
            ...(type ? {
              t: type
            } : {})
          };
        }
        currentNode = currentNode.c[key];
      }
    });
  } else {
    labelStacks.forEach(labelStack => {
      let currentNode = r;
      labelStack.forEach(label => {
        const name = label.name;
        const id = isSegmentLabel(label) ? label.segmentId : undefined;
        const key = id !== undefined ? id : name;
        const type = isSegmentLabel(label) ? label.type : undefined;
        if (!currentNode.c) {
          currentNode.c = {};
        }
        if (!currentNode.c[key]) {
          currentNode.c[key] = {
            n: name,
            ...(type ? {
              t: type
            } : {})
          };
        }
        currentNode = currentNode.c[key];
      });
    });
  }
  return {
    r
  };
}
export function stringifyLabelStackFully(labelStack) {
  return labelStack.map(l => {
    if (isSegmentLabel(l)) {
      return `${l.name}:${l.segmentId}`;
    }
    return l.name;
  }).join('/');
}
export function stringifyLabelStackWithoutId(labelStack) {
  return labelStack.map(l => {
    if (isSegmentLabel(l)) {
      return `${l.name}:segment`;
    }
    return l.name;
  }).join('/');
}
function getLabelStackReference(labelStack) {
  return labelStack.map(l => isSegmentLabel(l) ? l.segmentId : l.name).join('/');
}
export function labelStackStartWith(labelStack, startWith) {
  return stringifyLabelStackFully(labelStack).startsWith(stringifyLabelStackFully(startWith));
}
export function optimizeLabelStack(labelStack, reactUFOVersion) {
  return reactUFOVersion === '2.0.0' ? getLabelStackReference(labelStack) : labelStack.map(ls => ({
    n: ls.name,
    ...(ls.segmentId ? {
      s: ls.segmentId
    } : {}),
    ...(ls.type ? {
      t: ls.type
    } : {})
  }));
}
export function getOldSegmentsLabelStack(segments, interactionType) {
  if (fg('platform_ufo_add_segments_count_threshold')) {
    const config = getConfig();
    const addSegmentsMap = new Map();
    const segmentThreshold = config === null || config === void 0 ? void 0 : config.segmentsThreshold;
    return segments.map(({
      labelStack,
      ...others
    }) => {
      const stringifiedLabelStack = stringifyLabelStackWithoutId(labelStack);
      const segmentsInfo = [];
      for (const ls of labelStack) {
        const isSegment = isSegmentLabel(ls);
        if (isSegment && segmentThreshold && segmentThreshold[ls.name]) {
          const threshold = segmentThreshold[ls.name];
          const count = addSegmentsMap.get(stringifiedLabelStack) || 0;
          if (count < threshold) {
            addSegmentsMap.set(stringifiedLabelStack, count + 1);
          } else {
            break;
          }
        }
        segmentsInfo.push({
          n: ls.name,
          ...(ls.segmentId ? {
            s: ls.segmentId
          } : {}),
          ...(ls.type ? {
            t: ls.type
          } : {})
        });
      }
      return {
        ...others,
        labelStack: segmentsInfo
      };
    });
  }
  return segments.map(({
    labelStack,
    ...others
  }) => ({
    ...others,
    labelStack: optimizeLabelStack(labelStack, getReactUFOPayloadVersion(interactionType))
  }));
}