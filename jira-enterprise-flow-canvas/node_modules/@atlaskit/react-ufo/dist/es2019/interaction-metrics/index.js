// eslint-disable-next-line @atlaskit/platform/prefer-crypto-random-uuid -- Use crypto.randomUUID instead
import { v4 as createUUID } from 'uuid';
import { fg } from '@atlaskit/platform-feature-flags';
import coinflip from '../coinflip';
import { getAwaitBM3TTIList, getCapabilityRate, getConfig, getExperimentalInteractionRate, getExtraInteractionRate, getFinishInteractionOnTransition, getInteractionTimeout, getPostInteractionRate, getReactHydrationStats, shouldUseRawDataThirdPartyBehavior } from '../config';
import { experimentalVC, getExperimentalVCMetrics, onExperimentalInteractionComplete } from '../create-experimental-interaction-metrics-payload';
import { onSearchPageInteractionComplete } from '../create-extra-search-page-interaction-payload';
import { sanitizeUfoName, stringifyLabelStackFully } from '../create-payload/common/utils';
import { clearActiveTrace } from '../experience-trace-id-context';
import { allFeatureFlagsAccessed, currentFeatureFlagsAccessed } from '../feature-flags-accessed';
import { getInteractionId } from '../interaction-id-context';
import { flushSsrRenderProfilerTraces } from '../segment/ssr-render-profiler';
import { newVCObserver } from '../vc';
import { interactions } from './common/constants';
import InteractionExtraMetrics from './interaction-extra-metrics';
import PostInteractionLog from './post-interaction-log';
export const PreviousInteractionLog = {
  id: undefined,
  name: undefined,
  type: undefined,
  isAborted: undefined,
  timestamp: undefined
};
export const postInteractionLog = new PostInteractionLog();
export const interactionExtraMetrics = new InteractionExtraMetrics();
const interactionQueue = [];
const segmentCache = new Map();
export const segmentUnmountCache = new Map(); // Temporarily store segment unmount counts

let firstSegmentLoadMarked = false;
const segmentObservers = [];
export function getActiveInteraction() {
  const interactionId = getInteractionId();
  if (!interactionId.current) {
    return;
  }
  return interactions.get(interactionId.current);
}
function isPerformanceTracingEnabled() {
  var _getConfig;
  return ((_getConfig = getConfig()) === null || _getConfig === void 0 ? void 0 : _getConfig.enableAdditionalPerformanceMarks) || window.__REACT_UFO_ENABLE_PERF_TRACING || process.env.NODE_ENV !== 'production';
}
let performanceEventObserver;
export const getPerformanceObserver = () => {
  performanceEventObserver = performanceEventObserver || new PerformanceObserver(entries => {
    const list = entries.getEntries();
    for (let entry of list) {
      if (entry.name === 'click') {
        setInteractionPerformanceEvent(entry);
      }
    }
  });
  return performanceEventObserver;
};
export const setInteractionPerformanceEvent = entry => {
  const interaction = getActiveInteraction();
  if ((interaction === null || interaction === void 0 ? void 0 : interaction.type) === 'press') {
    const responsiveness = interaction.responsiveness || {};
    // if happens there is another event interaction that has started after
    // the initial one, we don't want to replace the values if they have already
    // been set up
    responsiveness.experimentalInputToNextPaint = responsiveness.experimentalInputToNextPaint || entry.duration;
    responsiveness.inputDelay = responsiveness.experimentalInputToNextPaint || entry.processingStart - entry.startTime;
    interaction.responsiveness = responsiveness;
    // if the entry start time is lower than the one in the interaction
    // it means the interaction start time is not accurate, we assign
    // this value which will match the timestamp in the event
    if (entry.startTime < interaction.start) {
      interaction.start = entry.startTime;
    }
  }
};
function labelStackToString(labelStack, name) {
  var _stack$map;
  const stack = [...(labelStack !== null && labelStack !== void 0 ? labelStack : [])];
  if (name) {
    stack.push({
      name
    });
  }
  return (_stack$map = stack.map(l => l.name)) === null || _stack$map === void 0 ? void 0 : _stack$map.join('/');
}
function labelStackToIdString(labelStack) {
  var _labelStack$map;
  return labelStack === null || labelStack === void 0 ? void 0 : (_labelStack$map = labelStack.map(l => 'segmentId' in l ? `${l.name}:${l.segmentId}` : `${l.name}`)) === null || _labelStack$map === void 0 ? void 0 : _labelStack$map.join('/');
}
function addSegmentObserver(observer) {
  segmentObservers.push(observer);
  for (const segmentInfo of segmentCache.values()) {
    observer.onAdd(segmentInfo);
  }
}
function removeSegmentObserver(observer) {
  const index = segmentObservers.findIndex(obs => obs === observer);
  if (index !== -1) {
    segmentObservers.splice(index, 1);
  }
}
export function remove(interactionId) {
  interactions.delete(interactionId);
}
export function updatePageLoadInteractionName(ufoName, routeName = ufoName) {
  const interaction = getActiveInteraction();
  if (!interaction || interaction.type !== 'page_load' && interaction.type !== 'transition') {
    return;
  }
  interaction.ufoName = ufoName;
  interaction.routeName = routeName;
}
export function addMetadata(interactionId, data) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    Object.keys(data).forEach(key => {
      interaction.metaData[key] = data[key];
    });
  }
}
export function addCustomData(interactionId, labelStack, data) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    Object.keys(data).forEach(i => {
      interaction.customData.push({
        labelStack,
        data: {
          [i]: data[i]
        }
      });
    });
  }
}
export function addCohortingCustomData(interactionId, key, value) {
  const interaction = interactions.get(interactionId);
  if (interaction == null) {
    return;
  }

  // Allow null and undefined values
  if (value === null || value === undefined) {
    interaction.cohortingCustomData.set(key, value);
    return;
  }

  // Validate that the value is a primitive (number, boolean, or string)
  if (typeof value !== 'number' && typeof value !== 'boolean' && typeof value !== 'string') {
    return;
  }

  // Validate string length (max 50 characters)
  if (typeof value === 'string' && value.length > 50) {
    return;
  }
  interaction.cohortingCustomData.set(key, value);
}
export function addCustomTiming(interactionId, labelStack, data) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.customTimings.push({
      labelStack,
      data
    });
    if (isPerformanceTracingEnabled()) {
      for (const [key, timingData] of Object.entries(data)) {
        const {
          startTime,
          endTime
        } = timingData;
        try {
          // for Firefox 102 and older
          performance.measure(`ðŸ›¸ ${labelStackToString(labelStack, key)} [custom_timing]`, {
            start: startTime,
            end: endTime,
            detail: {
              devtools: {
                track: 'ðŸ›¸ reactUFO detailed timings',
                color: 'tertiary-light'
              }
            }
          });
        } catch {
          // do nothing
        }
      }
    }
  }
}
export function addMark(interactionId, type, name, labelStack, time = performance.now()) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.marks.push({
      type,
      name,
      labelStack,
      time
    });
  }
  if (isPerformanceTracingEnabled()) {
    performance.mark(`ðŸ›¸ ${labelStackToString(labelStack, name)} [${type}]`, {
      startTime: time
    });
  }
}
export function markFirstSegmentLoad(interactionId, labelStack, time = performance.now()) {
  if (!fg('platform_mark_ufo_segment_first_load')) {
    return;
  }
  const interaction = interactions.get(interactionId);
  if (interaction != null && !firstSegmentLoadMarked) {
    firstSegmentLoadMarked = true;
    interaction.marks.push({
      type: 'first_segment_load',
      name: 'first_segment_load',
      labelStack,
      time
    });
  }
}
export function addMarkToAll(type, name, labelStack, time = performance.now()) {
  interactions.forEach(interaction => {
    interaction.marks.push({
      type,
      name,
      labelStack,
      time
    });
  });
  if (isPerformanceTracingEnabled()) {
    performance.mark(`ðŸ›¸ ${labelStackToString(labelStack, name)} [${type}]`, {
      startTime: time
    });
  }
}
export function addSpan(interactionId, type, name, labelStack, start, end = performance.now(), size) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.spans.push({
      type,
      name,
      labelStack,
      start,
      end,
      size
    });
    if (isPerformanceTracingEnabled()) {
      try {
        // for Firefox 102 and older
        performance.measure(`ðŸ›¸ ${labelStackToString(labelStack, name)} [${type}]`, {
          start,
          end,
          detail: {
            devtools: {
              track: 'ðŸ›¸ reactUFO detailed timings',
              color: 'secondary'
            }
          }
        });
      } catch {
        // do nothing
      }
    }
  }
}
export function addSpanToAll(type, name, labelStack, start, end = performance.now(), size = 0) {
  interactions.forEach(interaction => {
    interaction.spans.push({
      type,
      name,
      labelStack,
      start,
      end,
      size
    });
  });
  if (isPerformanceTracingEnabled()) {
    try {
      // for Firefox 102 and older
      performance.measure(`ðŸ›¸ ${labelStackToString(labelStack, name)} [${type}]`, {
        start,
        end,
        detail: {
          devtools: {
            track: 'ðŸ›¸ reactUFO detailed timings',
            color: 'secondary'
          }
        }
      });
    } catch {
      // do nothing
    }
  }
}
export function addPreload(moduleId, timestamp) {
  addMarkToAll('bundle_preload', moduleId, null, timestamp);
}
export function addLoad(identifier, start, end) {
  addSpanToAll('bundle_load', identifier, null, start, end - start);
}
const moduleLoadingRequests = {};
export function extractModuleName(input) {
  let result = input !== null && input !== void 0 ? input : '';
  result = result.replace(/^\.\/src\/packages\//, '');
  result = result.replace(/^\.\/node_modules\//, '');
  result = result.replace(/(\/src)?\/(index|main)\.(tsx|ts|js|jsx)$/, '');
  return result;
}
function addHoldCriterion(id, labelStack, name, startTime) {
  var _window$__CRITERION__;
  if (!((_window$__CRITERION__ = window.__CRITERION__) !== null && _window$__CRITERION__ !== void 0 && _window$__CRITERION__.addUFOHold)) {
    return;
  }
  window.__CRITERION__.addUFOHold(id, labelStackToString(labelStack), name, startTime);
}
function removeHoldCriterion(id) {
  var _window$__CRITERION__2;
  if (!((_window$__CRITERION__2 = window.__CRITERION__) !== null && _window$__CRITERION__2 !== void 0 && _window$__CRITERION__2.removeUFOHold)) {
    return;
  }
  window.__CRITERION__.removeUFOHold(id);
}
export function addHold(interactionId, labelStack, name, experimental) {
  const interaction = interactions.get(interactionId);
  // eslint-disable-next-line @atlaskit/platform/prefer-crypto-random-uuid -- Use crypto.randomUUID instead
  const id = createUUID();
  if (!interaction && fg('platform_ufo_enable_late_holds_post_interaction')) {
    // add hold timestamp to post interaction log if interaction is complete
    postInteractionLog.addHoldInfo(labelStack, name, performance.now());
  }
  if (interaction != null) {
    const start = performance.now();
    const holdActive = {
      labelStack,
      name,
      start
    };
    if (fg('platform_ufo_enable_ttai_with_3p')) {
      const is3pHold = labelStack.some(l => 'type' in l && l.type === 'third-party');
      if (is3pHold) {
        if (!interaction.hold3pActive) {
          interaction.hold3pActive = new Map();
        }
        interaction.hold3pActive.set(id, {
          ...holdActive,
          start
        });
      } else {
        interaction.holdActive.set(id, {
          ...holdActive,
          start
        });
        addHoldCriterion(id, labelStack, name, start);
      }
    } else {
      var _getConfig2, _getConfig2$experimen;
      if ((_getConfig2 = getConfig()) !== null && _getConfig2 !== void 0 && (_getConfig2$experimen = _getConfig2.experimentalInteractionMetrics) !== null && _getConfig2$experimen !== void 0 && _getConfig2$experimen.enabled && experimental) {
        interaction.holdExpActive.set(id, {
          ...holdActive,
          start
        });
      }
      if (!experimental) {
        interaction.holdActive.set(id, {
          ...holdActive,
          start
        });
      }
      addHoldCriterion(id, labelStack, name, start);
    }
    return () => {
      const end = performance.now();
      if (isPerformanceTracingEnabled()) {
        try {
          // for Firefox 102 and older
          performance.measure(`ðŸ›¸ ${labelStackToString(labelStack, name)} [hold]`, {
            start,
            end,
            detail: {
              devtools: {
                track: 'ðŸ›¸ reactUFO detailed timings',
                color: 'secondary-light'
              }
            }
          });
        } catch {
          // do nothing
        }
      }
      removeHoldCriterion(id);
      const currentInteraction = interactions.get(interactionId);
      const currentHold = interaction.holdActive.get(id);
      const expHold = interaction.holdExpActive.get(id);
      if (currentInteraction != null) {
        if (currentHold != null) {
          currentInteraction.holdInfo.push({
            ...currentHold,
            end
          });
          interaction.holdActive.delete(id);
        }
        if (expHold != null) {
          currentInteraction.holdExpInfo.push({
            ...expHold,
            end
          });
          interaction.holdExpActive.delete(id);
        }
        if (fg('platform_ufo_enable_ttai_with_3p')) {
          if (interaction.hold3pActive) {
            const current3pHold = interaction.hold3pActive.get(id);
            if (current3pHold != null) {
              if (!currentInteraction.hold3pInfo) {
                currentInteraction.hold3pInfo = [];
              }
              currentInteraction.hold3pInfo.push({
                ...current3pHold,
                end
              });
              interaction.hold3pActive.delete(id);
            }
          }
        }
      }
    };
  }
  return () => {};
}
export function addHoldByID(interactionId, labelStack, name, id, ignoreOnSubmit) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    const start = performance.now();
    if (fg('platform_ufo_enable_ttai_with_3p')) {
      const is3pHold = labelStack.some(l => 'type' in l && l.type === 'third-party');
      if (is3pHold) {
        if (!interaction.hold3pActive) {
          interaction.hold3pActive = new Map();
        }
        interaction.hold3pActive.set(id, {
          labelStack,
          name,
          start,
          ignoreOnSubmit
        });
      } else {
        interaction.holdActive.set(id, {
          labelStack,
          name,
          start,
          ignoreOnSubmit
        });
        addHoldCriterion(id, labelStack, name, start);
      }
    } else {
      interaction.holdActive.set(id, {
        labelStack,
        name,
        start,
        ignoreOnSubmit
      });
      addHoldCriterion(id, labelStack, name, start);
    }
  }
  return () => {};
}
export function removeHoldByID(interactionId, id) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    const end = performance.now();
    const currentInteraction = interactions.get(interactionId);
    const currentHold = interaction.holdActive.get(id);
    if (currentInteraction != null && currentHold != null) {
      currentInteraction.holdInfo.push({
        ...currentHold,
        end
      });
      interaction.holdActive.delete(id);
      removeHoldCriterion(id);
    }
    if (fg('platform_ufo_enable_ttai_with_3p')) {
      if (interaction.hold3pActive) {
        const current3pHold = interaction.hold3pActive.get(id);
        if (currentInteraction != null && current3pHold != null) {
          if (!currentInteraction.hold3pInfo) {
            currentInteraction.hold3pInfo = [];
          }
          currentInteraction.hold3pInfo.push({
            ...current3pHold,
            end
          });
          interaction.hold3pActive.delete(id);
        }
      }
    }
  }
}
export function getCurrentInteractionType(interactionId) {
  const interaction = interactions.get(interactionId);
  if (interaction) {
    return interaction.type;
  }
  return null;
}
export const ModuleLoadingProfiler = {
  onPreload(moduleId, _priority) {
    addPreload(extractModuleName(moduleId), performance.now());
  },
  onLoadStart(info) {
    const timeoutId = setTimeout(() => {
      delete moduleLoadingRequests[info.identifier];
    }, 30000);
    const request = {
      start: performance.now(),
      timeoutId
    };
    moduleLoadingRequests[info.identifier] = request;
  },
  onLoadComplete(info) {
    const request = moduleLoadingRequests[info.identifier];
    if (request) {
      clearTimeout(request.timeoutId);
      delete moduleLoadingRequests[info.identifier];
      addLoad(extractModuleName(info.identifier), request.start, performance.now());
    }
  },
  placeholderFallBackMounted(id, moduleId) {
    const interactionId = getInteractionId();
    const currentInteractionId = interactionId.current;
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    addHoldByID(currentInteractionId, [], moduleId, id);
  },
  placeholderFallBackUnmounted(id) {
    const interactionId = getInteractionId();
    const currentInteractionId = interactionId.current;
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    removeHoldByID(currentInteractionId, id);
  }
};
export function addError(interactionId, name, labelStack, errorType, errorMessage, errorStack, forcedError, errorHash, errorStatusCode) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.errors.push({
      name,
      labelStack,
      errorType,
      errorMessage,
      errorStack,
      forcedError,
      errorHash,
      errorStatusCode
    });
  }
}
export function addErrorToAll(name, labelStack, errorType, errorMessage, errorStack, errorHash, errorStatusCode) {
  interactions.forEach(interaction => {
    interaction.errors.push({
      name,
      labelStack,
      errorType,
      errorMessage,
      errorStack,
      errorHash,
      errorStatusCode
    });
  });
}
export function addProfilerTimings(interactionId, labelStack, type, actualDuration, baseDuration, startTime, commitTime) {
  var _getConfig3, _getConfig3$postInter;
  if (isPerformanceTracingEnabled()) {
    try {
      // for Firefox 102 and older
      performance.measure(`ðŸ›¸ ${labelStackToString(labelStack)} [react-profiler] ${type}`, {
        start: startTime,
        duration: actualDuration,
        detail: {
          devtools: {
            track: 'ðŸ›¸ reactUFO detailed timings',
            color: 'secondary-dark'
          }
        }
      });
    } catch {
      // do nothing
    }
  }
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.reactProfilerTimings.push({
      labelStack,
      type,
      actualDuration,
      baseDuration,
      startTime,
      commitTime
    });
  } else if ((_getConfig3 = getConfig()) !== null && _getConfig3 !== void 0 && (_getConfig3$postInter = _getConfig3.postInteractionLog) !== null && _getConfig3$postInter !== void 0 && _getConfig3$postInter.enabled) {
    postInteractionLog.addProfilerTimings(labelStack, type, actualDuration, baseDuration, startTime, commitTime);
  }
}
function pushToQueue(id, data) {
  interactionQueue.push({
    id,
    data
  });
}
let handleInteraction = pushToQueue;
function callCleanUpCallbacks(interaction) {
  interaction.cleanupCallbacks.reverse().forEach(cleanUpCallback => {
    cleanUpCallback();
  });
}
function finishInteraction(id, data, endTime = performance.now()) {
  var _getConfig4, _getConfig4$vc;
  data.end = endTime;
  try {
    // for Firefox 102 and older
    performance.measure(`ðŸ›¸ [${data.type}] ${data.ufoName} [ttai]`, {
      start: data.start,
      end: data.end,
      detail: {
        devtools: {
          track: 'main metrics',
          trackGroup: 'ðŸ›¸ reactUFO metrics',
          color: 'tertiary'
        }
      }
    });
    performance.mark(`TTAI`, {
      startTime: data.end,
      detail: {
        devtools: {
          dataType: 'marker'
        }
      }
    });
  } catch {
    // do nothing
  }
  if (data.featureFlags) {
    data.featureFlags.during = Object.fromEntries(currentFeatureFlagsAccessed);
  }
  clearActiveTrace();
  callCleanUpCallbacks(data);
  flushSsrRenderProfilerTraces();
  if ((_getConfig4 = getConfig()) !== null && _getConfig4 !== void 0 && (_getConfig4$vc = _getConfig4.vc) !== null && _getConfig4$vc !== void 0 && _getConfig4$vc.stopVCAtInteractionFinish) {
    // Use per-interaction VC observer if available, otherwise fall back to global
    const observer = data.vcObserver;
    if (observer) {
      data.vc = observer.getVCRawData();
    }
  }
  if (data.type === 'page_load') {
    data.hydration = getReactHydrationStats();
  }

  // By this time, stop the post interaction log observer if coinflip rate is 0
  const sanitisedUfoName = sanitizeUfoName(data.ufoName);
  if (!coinflip(getPostInteractionRate(sanitisedUfoName, data.type))) {
    postInteractionLog.stopVCObserver();
  }
  if (fg('platform_ufo_enable_ttai_with_3p')) {
    const sanitisedUfoName = sanitizeUfoName(data.ufoName);
    if (!coinflip(getExtraInteractionRate(sanitisedUfoName, data.type))) {
      interactionExtraMetrics.stopAll(id);
    } else if (!data.hold3pActive || data.hold3pActive.size === 0) {
      var _getConfig5, _getConfig5$experimen;
      if (!((_getConfig5 = getConfig()) !== null && _getConfig5 !== void 0 && (_getConfig5$experimen = _getConfig5.experimentalInteractionMetrics) !== null && _getConfig5$experimen !== void 0 && _getConfig5$experimen.enabled)) {
        remove(id);
      }
    }
  } else {
    var _getConfig6, _getConfig6$experimen;
    if (!((_getConfig6 = getConfig()) !== null && _getConfig6 !== void 0 && (_getConfig6$experimen = _getConfig6.experimentalInteractionMetrics) !== null && _getConfig6$experimen !== void 0 && _getConfig6$experimen.enabled)) {
      remove(id);
    }
  }
  if (fg('platform_ufo_enable_terminal_errors')) {
    PreviousInteractionLog.id = data.id;
    PreviousInteractionLog.type = data.type;
    PreviousInteractionLog.timestamp = data.end;
  }
  PreviousInteractionLog.name = data.ufoName || 'unknown';
  PreviousInteractionLog.isAborted = data.abortReason != null;
  if (data.ufoName) {
    if (fg('platform_ufo_enable_ttai_with_3p')) {
      var _interactionExtraMetr;
      if (((_interactionExtraMetr = interactionExtraMetrics.finishedInteraction) === null || _interactionExtraMetr === void 0 ? void 0 : _interactionExtraMetr.id) !== id) {
        // If this same interaction was not already handled, handle it
        handleInteraction(id, data);
      }
    } else {
      handleInteraction(id, data);
    }
  }
  if (isPerformanceTracingEnabled()) {
    const profilerTimingMap = new Map();
    data.reactProfilerTimings.forEach(profilerTiming => {
      const labelStackId = labelStackToIdString(profilerTiming.labelStack);
      if (labelStackId) {
        var _profilerTimingMap$ge, _timing$start, _timing$end;
        const timing = (_profilerTimingMap$ge = profilerTimingMap.get(labelStackId)) !== null && _profilerTimingMap$ge !== void 0 ? _profilerTimingMap$ge : {
          labelStack: profilerTiming.labelStack
        };
        timing.start = profilerTiming.startTime < ((_timing$start = timing.start) !== null && _timing$start !== void 0 ? _timing$start : Number.MAX_SAFE_INTEGER) ? profilerTiming.startTime : timing.start;
        timing.end = profilerTiming.commitTime > ((_timing$end = timing.end) !== null && _timing$end !== void 0 ? _timing$end : Number.MIN_SAFE_INTEGER) ? profilerTiming.commitTime : timing.end;
        profilerTimingMap.set(labelStackId, timing);
      }
    });
    try {
      // for Firefox 102 and older
      for (const [, {
        labelStack,
        start,
        end
      }] of profilerTimingMap.entries()) {
        performance.measure(`ðŸ›¸ ${labelStackToString(labelStack)} [segment_ttai]`, {
          start,
          end,
          detail: {
            devtools: {
              track: 'ðŸ›¸ reactUFO detailed timings',
              color: 'secondary-dark'
            }
          }
        });
      }
    } catch {
      // do nothing
    }
  }
  try {
    // dispatch a global window event to notify the measure is completed
    window.dispatchEvent(new CustomEvent('UFO_FINISH_INTERACTION', {
      detail: data
    }));
  } catch {
    // do nothing
  }
}
export function sinkInteractionHandler(sinkFn) {
  if (handleInteraction === pushToQueue) {
    handleInteraction = sinkFn;
    interactionQueue.forEach(interaction => {
      sinkFn(interaction.id, interaction.data);
    });
    interactionQueue.length = 0;
  }
}
export function sinkPostInteractionLogHandler(sinkFn) {
  postInteractionLog.sinkHandler(sinkFn);
}

// a flag to prevent multiple submitting
let activeSubmitted = false;
export function tryComplete(interactionId, endTime) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    const noMoreActiveHolds = interaction.holdActive.size === 0;
    const noMoreExpHolds = interaction.holdExpActive.size === 0;
    const shouldUseRawDataThirdParty = shouldUseRawDataThirdPartyBehavior(interaction.ufoName, interaction.type);
    const postInteraction = async () => {
      var _getConfig7, _getConfig7$postInter;
      if ((_getConfig7 = getConfig()) !== null && _getConfig7 !== void 0 && (_getConfig7$postInter = _getConfig7.postInteractionLog) !== null && _getConfig7$postInter !== void 0 && _getConfig7$postInter.enabled) {
        var _getConfig8, _getConfig8$experimen;
        let experimentalVC90;
        let experimentalTTAI;
        if ((_getConfig8 = getConfig()) !== null && _getConfig8 !== void 0 && (_getConfig8$experimen = _getConfig8.experimentalInteractionMetrics) !== null && _getConfig8$experimen !== void 0 && _getConfig8$experimen.enabled) {
          var _await$getExperimenta;
          experimentalVC90 = (_await$getExperimenta = await getExperimentalVCMetrics(interaction)) === null || _await$getExperimenta === void 0 ? void 0 : _await$getExperimenta['metric:experimental:vc90'];
          const {
            start,
            end
          } = interaction;
          experimentalTTAI = !interaction.abortReason ? Math.round(end - start) : undefined;
        }
        postInteractionLog.onInteractionComplete({
          ...interaction,
          experimentalTTAI,
          experimentalVC90
        });
      }
      if (fg('platform_ufo_enable_ttai_with_3p')) {
        var _interactionExtraMetr2;
        if (((_interactionExtraMetr2 = interactionExtraMetrics.finishedInteraction) === null || _interactionExtraMetr2 === void 0 ? void 0 : _interactionExtraMetr2.id) !== interactionId) {
          var _getConfig9, _getConfig9$experimen;
          // If interactionExtraMetrics is not waiting for measuring this interaction
          if ((_getConfig9 = getConfig()) !== null && _getConfig9 !== void 0 && (_getConfig9$experimen = _getConfig9.experimentalInteractionMetrics) !== null && _getConfig9$experimen !== void 0 && _getConfig9$experimen.enabled) {
            remove(interactionId);
          }
        }
      } else {
        var _getConfig0, _getConfig0$experimen;
        if ((_getConfig0 = getConfig()) !== null && _getConfig0 !== void 0 && (_getConfig0$experimen = _getConfig0.experimentalInteractionMetrics) !== null && _getConfig0$experimen !== void 0 && _getConfig0$experimen.enabled) {
          remove(interactionId);
        }
      }
      activeSubmitted = false;
    };
    if (fg('platform_ufo_enable_ttai_with_3p')) {
      var _interaction$hold3pAc;
      const noMoreActive3pHolds = ((_interaction$hold3pAc = interaction.hold3pActive) === null || _interaction$hold3pAc === void 0 ? void 0 : _interaction$hold3pAc.size) === 0 || interaction.hold3pActive === undefined;

      // If using raw data third party behavior, wait for 3p holds to clear
      if (shouldUseRawDataThirdParty) {
        // If there are no non-3p holds active, mark the interaction as successful
        // but don't finish until 3p holds are cleared
        if (noMoreActiveHolds && !noMoreActive3pHolds) {
          // Mark interaction as successful by setting endTime, but don't finish yet
          if (endTime !== undefined && interaction.end === 0) {
            interaction.end = endTime;
          }
          // Wait for 3p holds to clear before finishing
          return;
        }

        // If all holds (including 3p) are cleared, finish the interaction
        if (noMoreActiveHolds && noMoreActive3pHolds) {
          if (!activeSubmitted) {
            var _getConfig1, _getConfig1$extraInte, _getConfig10, _getConfig10$extraSea, _getConfig11, _getConfig11$extraSea;
            // Set end3p to current time when 3p holds cleared, but ensure it's at least interaction.end
            const currentTime = endTime !== null && endTime !== void 0 ? endTime : performance.now();
            interaction.end3p = interaction.end !== 0 && currentTime < interaction.end ? interaction.end : currentTime;
            finishInteraction(interactionId, interaction, interaction.end !== 0 ? interaction.end : endTime);
            if ((_getConfig1 = getConfig()) !== null && _getConfig1 !== void 0 && (_getConfig1$extraInte = _getConfig1.extraInteractionMetrics) !== null && _getConfig1$extraInte !== void 0 && _getConfig1$extraInte.enabled) {
              interactionExtraMetrics.updateFinishedInteraction(interaction);
            }
            if ((_getConfig10 = getConfig()) !== null && _getConfig10 !== void 0 && (_getConfig10$extraSea = _getConfig10.extraSearchPageInteraction) !== null && _getConfig10$extraSea !== void 0 && _getConfig10$extraSea.enabled && interaction.ufoName === ((_getConfig11 = getConfig()) === null || _getConfig11 === void 0 ? void 0 : (_getConfig11$extraSea = _getConfig11.extraSearchPageInteraction) === null || _getConfig11$extraSea === void 0 ? void 0 : _getConfig11$extraSea.searchPageMetricName)) {
              onSearchPageInteractionComplete(interactionId, interaction);
            }
            activeSubmitted = true;
          }
          if (noMoreExpHolds) {
            var _getConfig12, _getConfig12$experime;
            if ((_getConfig12 = getConfig()) !== null && _getConfig12 !== void 0 && (_getConfig12$experime = _getConfig12.experimentalInteractionMetrics) !== null && _getConfig12$experime !== void 0 && _getConfig12$experime.enabled) {
              onExperimentalInteractionComplete(interactionId, interaction, endTime || interaction.end);
            }
            postInteraction();
          }
        }
        // Send separated third-party event even when feature flag is active
        if (noMoreActiveHolds && noMoreActive3pHolds) {
          const data = {
            ...interaction,
            end: endTime || interaction.end
          };
          interactionExtraMetrics.onInteractionComplete(interactionId, data);
        }
      } else {
        var _interactionExtraMetr3;
        // Original behavior when feature flag is not active
        if (noMoreActiveHolds && ((_interactionExtraMetr3 = interactionExtraMetrics.finishedInteraction) === null || _interactionExtraMetr3 === void 0 ? void 0 : _interactionExtraMetr3.id) !== interactionId) {
          // If it's not waiting for extra metrics to complete, finish the interaction as normal
          if (!activeSubmitted) {
            var _getConfig13, _getConfig13$extraInt, _getConfig14, _getConfig14$extraSea, _getConfig15, _getConfig15$extraSea;
            finishInteraction(interactionId, interaction, endTime);
            if ((_getConfig13 = getConfig()) !== null && _getConfig13 !== void 0 && (_getConfig13$extraInt = _getConfig13.extraInteractionMetrics) !== null && _getConfig13$extraInt !== void 0 && _getConfig13$extraInt.enabled) {
              interactionExtraMetrics.updateFinishedInteraction(interaction);
            }
            if ((_getConfig14 = getConfig()) !== null && _getConfig14 !== void 0 && (_getConfig14$extraSea = _getConfig14.extraSearchPageInteraction) !== null && _getConfig14$extraSea !== void 0 && _getConfig14$extraSea.enabled && interaction.ufoName === ((_getConfig15 = getConfig()) === null || _getConfig15 === void 0 ? void 0 : (_getConfig15$extraSea = _getConfig15.extraSearchPageInteraction) === null || _getConfig15$extraSea === void 0 ? void 0 : _getConfig15$extraSea.searchPageMetricName)) {
              onSearchPageInteractionComplete(interactionId, interaction);
            }
            activeSubmitted = true;
          }
          if (noMoreExpHolds) {
            var _getConfig16, _getConfig16$experime;
            if ((_getConfig16 = getConfig()) !== null && _getConfig16 !== void 0 && (_getConfig16$experime = _getConfig16.experimentalInteractionMetrics) !== null && _getConfig16$experime !== void 0 && _getConfig16$experime.enabled) {
              onExperimentalInteractionComplete(interactionId, interaction, endTime);
            }
            postInteraction();
          }
        }
        if (noMoreActiveHolds && noMoreActive3pHolds) {
          const data = {
            ...interaction,
            end: endTime
          };
          interactionExtraMetrics.onInteractionComplete(interactionId, data);
        }
      }
    } else {
      if (noMoreActiveHolds) {
        if (!activeSubmitted) {
          var _getConfig17, _getConfig17$extraSea, _getConfig18, _getConfig18$extraSea;
          finishInteraction(interactionId, interaction, endTime);
          if ((_getConfig17 = getConfig()) !== null && _getConfig17 !== void 0 && (_getConfig17$extraSea = _getConfig17.extraSearchPageInteraction) !== null && _getConfig17$extraSea !== void 0 && _getConfig17$extraSea.enabled && interaction.ufoName === ((_getConfig18 = getConfig()) === null || _getConfig18 === void 0 ? void 0 : (_getConfig18$extraSea = _getConfig18.extraSearchPageInteraction) === null || _getConfig18$extraSea === void 0 ? void 0 : _getConfig18$extraSea.searchPageMetricName)) {
            onSearchPageInteractionComplete(interactionId, interaction);
          }
          activeSubmitted = true;
        }
        if (noMoreExpHolds) {
          var _getConfig19, _getConfig19$experime;
          if ((_getConfig19 = getConfig()) !== null && _getConfig19 !== void 0 && (_getConfig19$experime = _getConfig19.experimentalInteractionMetrics) !== null && _getConfig19$experime !== void 0 && _getConfig19$experime.enabled) {
            onExperimentalInteractionComplete(interactionId, interaction, endTime);
          }
          postInteraction();
        }
      }
    }
  }
}
function callCancelCallbacks(interaction) {
  interaction.cancelCallbacks.reverse().forEach(cancelCallback => {
    cancelCallback();
  });
}
export function abort(interactionId, abortReason) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    const shouldUseRawDataThirdParty = shouldUseRawDataThirdPartyBehavior(interaction.ufoName, interaction.type);
    const noMoreActiveHolds = interaction.holdActive.size === 0;
    const has3pHoldsActive = interaction.hold3pActive && interaction.hold3pActive.size > 0;

    // If only third-party holds are active, finish as successful instead of aborting
    if (shouldUseRawDataThirdParty && noMoreActiveHolds && has3pHoldsActive) {
      const endTime = interaction.end !== 0 ? interaction.end : performance.now();
      interaction.end3p = performance.now();
      finishInteraction(interactionId, interaction, endTime);
      postInteractionLog.reset();
      postInteractionLog.stopVCObserver();
      if (fg('platform_ufo_enable_ttai_with_3p')) {
        interactionExtraMetrics.stopAll(interactionId);
      }
      if (coinflip(getExperimentalInteractionRate(interaction.ufoName, interaction.type))) {
        onExperimentalInteractionComplete(interactionId, interaction, endTime);
        remove(interactionId);
      }
      return;
    }
    callCancelCallbacks(interaction);
    interaction.abortReason = abortReason;
    finishInteraction(interactionId, interaction);
    postInteractionLog.reset();
    postInteractionLog.stopVCObserver();
    if (fg('platform_ufo_enable_ttai_with_3p')) {
      interactionExtraMetrics.stopAll(interactionId);
    }
    if (coinflip(getExperimentalInteractionRate(interaction.ufoName, interaction.type))) {
      onExperimentalInteractionComplete(interactionId, interaction);
      remove(interactionId);
    }
  }
}
export function abortByNewInteraction(interactionId, interactionName) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    const shouldUseRawDataThirdParty = shouldUseRawDataThirdPartyBehavior(interaction.ufoName, interaction.type);
    const noMoreActiveHolds = interaction.holdActive.size === 0;
    const has3pHoldsActive = interaction.hold3pActive && interaction.hold3pActive.size > 0;

    // If only third-party holds are active, finish as successful instead of aborting
    if (shouldUseRawDataThirdParty && noMoreActiveHolds && has3pHoldsActive) {
      const endTime = interaction.end !== 0 ? interaction.end : performance.now();
      // Set end3p to current time, but ensure it's at least interaction.end
      interaction.end3p = performance.now();
      finishInteraction(interactionId, interaction, endTime);
      postInteractionLog.reset();
      postInteractionLog.stopVCObserver();
      if (fg('platform_ufo_enable_ttai_with_3p')) {
        interactionExtraMetrics.stopAll(interactionId);
      }
      if (coinflip(getExperimentalInteractionRate(interaction.ufoName, interaction.type))) {
        onExperimentalInteractionComplete(interactionId, interaction, endTime);
        remove(interactionId);
      }
      return;
    }
    callCancelCallbacks(interaction);
    interaction.abortReason = 'new_interaction';
    interaction.abortedByInteractionName = interactionName;
    finishInteraction(interactionId, interaction);
    postInteractionLog.reset();
    postInteractionLog.stopVCObserver();
    if (fg('platform_ufo_enable_ttai_with_3p')) {
      interactionExtraMetrics.stopAll(interactionId);
    }
    if (coinflip(getExperimentalInteractionRate(interaction.ufoName, interaction.type))) {
      onExperimentalInteractionComplete(interactionId, interaction);
      remove(interactionId);
    }
  } else {
    if (fg('platform_reset_post_interaction_on_new_interaction')) {
      // post-interaction log is active after interaction is aborted by new one
      postInteractionLog.reset();
      postInteractionLog.stopVCObserver();
    }
  }
}
export function abortAll(abortReason, abortedByInteractionName) {
  const activeInteraction = getActiveInteraction();
  const finishInteractions = getFinishInteractionOnTransition();
  interactions.forEach((interaction, interactionId) => {
    const isActiveInteraction = activeInteraction === interaction;
    let hasFinished = interaction.holdActive.size === 0;
    if (isActiveInteraction && abortReason === 'transition' && interaction.type === 'press' && finishInteractions !== null && finishInteractions !== void 0 && finishInteractions.includes(interaction.ufoName) && fg('platform_ufo_enable_finish_interaction_transition')) {
      hasFinished = true;
    }
    const shouldUseRawDataThirdParty = shouldUseRawDataThirdPartyBehavior(interaction.ufoName, interaction.type);
    const noMoreActiveHolds = interaction.holdActive.size === 0;
    const has3pHoldsActive = interaction.hold3pActive && interaction.hold3pActive.size > 0;

    // If only third-party holds are active, finish as successful instead of aborting
    if (shouldUseRawDataThirdParty && noMoreActiveHolds && has3pHoldsActive) {
      const endTime = interaction.end !== 0 ? interaction.end : performance.now();
      interaction.end3p = performance.now();
      finishInteraction(interactionId, interaction, endTime);
      postInteractionLog.reset();
      postInteractionLog.stopVCObserver();
      if (fg('platform_ufo_enable_ttai_with_3p')) {
        interactionExtraMetrics.stopAll(interactionId);
      }
      if (coinflip(getExperimentalInteractionRate(interaction.ufoName, interaction.type))) {
        onExperimentalInteractionComplete(interactionId, interaction, endTime);
        remove(interactionId);
      }
      return;
    }
    if (!hasFinished) {
      callCancelCallbacks(interaction);
      interaction.abortReason = abortReason;
      if (abortedByInteractionName != null) {
        interaction.abortedByInteractionName = abortedByInteractionName;
      }
    }
    finishInteraction(interactionId, interaction);
    postInteractionLog.reset();
    postInteractionLog.stopVCObserver();
    if (fg('platform_ufo_enable_ttai_with_3p')) {
      interactionExtraMetrics.stopAll(interactionId);
    }
    if (coinflip(getExperimentalInteractionRate(interaction.ufoName, interaction.type))) {
      onExperimentalInteractionComplete(interactionId, interaction);
      remove(interactionId);
    }
  });
}
export function addOnCancelCallback(id, cancelCallback) {
  const interaction = interactions.get(id);
  interaction === null || interaction === void 0 ? void 0 : interaction.cancelCallbacks.push(cancelCallback);
}
export function addNewInteraction(interactionId, ufoName, type, startTime, rate, labelStack, routeName, trace = null) {
  var _config$extraSearchPa, _config$extraSearchPa2;
  interactionExtraMetrics.reset();
  postInteractionLog.reset();
  let vcObserver;
  let previousTime = startTime;
  let timeoutTime = getInteractionTimeout(ufoName);
  const timerID = setTimeout(() => {
    abort(interactionId, 'timeout');
  }, timeoutTime);
  function changeTimeout(newTime) {
    // we compare if the time left is lower than the new time to no
    // extend the timeout beyond the initial waiting time
    const currentTime = performance.now();
    const timeLeft = timeoutTime - (currentTime - previousTime);
    if (timeLeft < newTime) {
      return;
    }
    clearTimeout(this.timerID);
    const newTimerID = setTimeout(() => {
      abort(interactionId, 'timeout');
    }, newTime);
    timeoutTime = newTime;
    previousTime = currentTime;
    this.timerID = newTimerID;
  }
  const addFeatureFlagsToInteraction = coinflip(getCapabilityRate('feature_flag_access'));
  const config = getConfig();
  const searchPageConfig = fg('rovo_search_page_ttvc_ignoring_smart_answers_fix') ? {
    enableSmartAnswersMutations: config === null || config === void 0 ? void 0 : (_config$extraSearchPa = config.extraSearchPageInteraction) === null || _config$extraSearchPa === void 0 ? void 0 : _config$extraSearchPa.enabled,
    searchPageRoute: config === null || config === void 0 ? void 0 : (_config$extraSearchPa2 = config.extraSearchPageInteraction) === null || _config$extraSearchPa2 === void 0 ? void 0 : _config$extraSearchPa2.searchPageRoute
  } : undefined;
  if (config && config.vc) {
    const vcOptions = {
      heatmapSize: config.vc.heatmapSize,
      oldDomUpdates: config.vc.oldDomUpdates,
      devToolsEnabled: config.vc.devToolsEnabled,
      selectorConfig: config.vc.selectorConfig,
      ssrEnablePageLayoutPlaceholder: config.vc.ssrEnablePageLayoutPlaceholder,
      searchPageConfig
    };
    vcObserver = newVCObserver(vcOptions);
  }
  const priorAccessedFg = type === 'press' && fg('platform_ufo_drop_prior_fg_interactions') ? {} : Object.fromEntries(allFeatureFlagsAccessed);
  const metrics = {
    id: interactionId,
    start: startTime,
    end: 0,
    ufoName,
    type,
    previousInteractionName: PreviousInteractionLog.name,
    isPreviousInteractionAborted: PreviousInteractionLog.isAborted === true,
    marks: [],
    customData: [],
    cohortingCustomData: new Map(),
    customTimings: [],
    spans: [],
    requestInfo: [],
    reactProfilerTimings: [],
    holdInfo: [],
    holdExpInfo: [],
    holdActive: new Map(),
    holdExpActive: new Map(),
    // measure when we execute this code
    // from this, we can measure the input delay -
    // how long the browser took to hand execution back to JS)
    measureStart: performance.now(),
    rate,
    cancelCallbacks: [],
    metaData: {},
    errors: [],
    apdex: [],
    labelStack,
    routeName: routeName !== null && routeName !== void 0 ? routeName : ufoName,
    featureFlags: addFeatureFlagsToInteraction ? {
      prior: priorAccessedFg,
      during: {}
    } : undefined,
    knownSegments: [],
    cleanupCallbacks: [],
    awaitReactProfilerCount: 0,
    redirects: [],
    timerID,
    changeTimeout,
    trace,
    vcObserver,
    hold3pActive: new Map(),
    hold3pInfo: [],
    minorInteractions: []
  };
  if (addFeatureFlagsToInteraction) {
    currentFeatureFlagsAccessed.clear();
  }
  interactions.set(interactionId, metrics);
  const segmentObserver = {
    onAdd(segment) {
      metrics.knownSegments.push(segment);
    },
    onRemove() {}
  };
  addSegmentObserver(segmentObserver);
  metrics.cleanupCallbacks.push(() => {
    removeSegmentObserver(segmentObserver);
  });
  metrics.cleanupCallbacks.push(() => {
    clearTimeout(metrics.timerID);
  });
  // Add cleanup for per-interaction VC observer
  if (vcObserver) {
    metrics.cleanupCallbacks.push(() => {
      vcObserver.stop(ufoName);
    });
  }
  const awaitBM3TTIList = getAwaitBM3TTIList();
  if (awaitBM3TTIList.includes(ufoName)) {
    addHoldByID(interactionId, [], ufoName, ufoName, true);
  }
  if (type === 'transition' || type === 'page_load') {
    var _getConfig20, _getConfig20$postInte, _config$extraInteract;
    // Use per-interaction VC observer if available, otherwise fall back to global
    const observer = vcObserver;
    if (observer) {
      observer.start({
        startTime,
        experienceKey: ufoName
      });
    }
    // Start post interaction observer for all if config is enabled
    // in case ufoName is updated at later time
    if ((_getConfig20 = getConfig()) !== null && _getConfig20 !== void 0 && (_getConfig20$postInte = _getConfig20.postInteractionLog) !== null && _getConfig20$postInte !== void 0 && _getConfig20$postInte.enabled) {
      postInteractionLog.startVCObserver({
        startTime
      });
    }
    if (coinflip(getExperimentalInteractionRate(ufoName, type))) {
      experimentalVC.start({
        startTime
      });
    }
    if (config !== null && config !== void 0 && (_config$extraInteract = config.extraInteractionMetrics) !== null && _config$extraInteract !== void 0 && _config$extraInteract.enabled && fg('platform_ufo_enable_ttai_with_3p')) {
      interactionExtraMetrics.startVCObserver({
        startTime
      }, interactionId);
    }
  }
  if (type === 'press') {
    // Use per-interaction VC observer if available, otherwise fall back to global
    const observer = vcObserver;
    if (observer) {
      observer.start({
        startTime,
        experienceKey: ufoName
      });
    }
  }
}
export function addBrowserMetricEvent(event) {
  const interaction = getActiveInteraction();
  if (interaction) {
    var _event$config;
    interaction.legacyMetrics = interaction.legacyMetrics || [];
    interaction.legacyMetrics.push(event);
    if ((interaction.type === 'page_load' || interaction.type === 'transition') && ((_event$config = event.config) === null || _event$config === void 0 ? void 0 : _event$config.type) === 'PAGE_LOAD') {
      removeHoldByID(interaction.id, interaction.ufoName);
    }
  }
}
export function addApdexToAll(apdex) {
  interactions.forEach((interaction, key) => {
    interaction.apdex.push(apdex);
    try {
      var _apdex$startTime;
      // for Firefox 102 and older
      performance.measure(`ðŸ›¸ ${apdex.key} [bm3_tti]`, {
        start: (_apdex$startTime = apdex.startTime) !== null && _apdex$startTime !== void 0 ? _apdex$startTime : interaction.start,
        end: apdex.stopTime,
        detail: {
          devtools: {
            track: 'main metrics',
            trackGroup: 'ðŸ›¸ reactUFO metrics',
            color: 'primary-dark'
          }
        }
      });
      performance.mark(`[bm3] TTI`, {
        startTime: apdex.stopTime,
        detail: {
          devtools: {
            dataType: 'marker'
          }
        }
      });
    } catch {
      // do nothing
    }
    if (interaction.type === 'page_load' || interaction.type === 'transition') {
      removeHoldByID(key, interaction.ufoName);
    }
  });
}
export function addApdex(interactionId, apdexInfo) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.apdex.push(apdexInfo);
    try {
      var _apdexInfo$startTime;
      // for Firefox 102 and older
      performance.measure(`ðŸ›¸ ${apdexInfo.key} [bm3_tti]`, {
        start: (_apdexInfo$startTime = apdexInfo.startTime) !== null && _apdexInfo$startTime !== void 0 ? _apdexInfo$startTime : interaction.start,
        end: apdexInfo.stopTime,
        detail: {
          devtools: {
            track: 'main metrics',
            trackGroup: 'ðŸ›¸ reactUFO metrics',
            color: 'primary-dark'
          }
        }
      });
      performance.mark(`[bm3] TTI`, {
        startTime: apdexInfo.stopTime,
        detail: {
          devtools: {
            dataType: 'marker'
          }
        }
      });
    } catch {
      // do nothing
    }
    if (interaction.type === 'page_load' || interaction.type === 'transition') {
      removeHoldByID(interactionId, interaction.ufoName);
    }
  }
}
export function addRequestInfo(interactionId, labelStack, requestInfo) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.requestInfo.push({
      labelStack,
      ...requestInfo
    });
  }
}
function isSegmentLabel(obj) {
  return obj && typeof obj.name === 'string' && typeof obj.segmentId === 'string';
}
function getSegmentCacheKey(labelStack) {
  return labelStack.map(l => {
    if (isSegmentLabel(l)) {
      return `${l.name}_${l.segmentId}`;
    }
    return l.name;
  }).join('|');
}
export function addSegment(labelStack) {
  const key = getSegmentCacheKey(labelStack);
  const existingSegment = segmentCache.get(key);
  if (!existingSegment) {
    const segmentInfo = {
      labelStack
    };
    segmentCache.set(key, segmentInfo);
    segmentObservers.forEach(observer => {
      observer.onAdd(segmentInfo);
    });
  }
}
export function removeSegment(labelStack) {
  const key = getSegmentCacheKey(labelStack);
  const segmentInfo = segmentCache.get(key);
  if (segmentInfo) {
    segmentCache.delete(JSON.stringify(labelStack));
    if (fg('platform_ufo_segment_unmount_count')) {
      const cacheKey = stringifyLabelStackFully(labelStack);
      segmentUnmountCache.set(cacheKey, (segmentUnmountCache.get(cacheKey) || 0) + 1);
    }
    segmentObservers.forEach(observer => {
      observer.onRemove(segmentInfo);
    });
  }
}
export function addRedirect(interactionId, fromUfoName, nextUfoName, nextRouteName, time) {
  const interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.ufoName = nextUfoName;
    interaction.routeName = nextRouteName;
    interaction.redirects.push({
      fromInteractionName: fromUfoName,
      time
    });
    if (isPerformanceTracingEnabled()) {
      const prevRedirect = interaction.redirects.at(-2);
      try {
        var _prevRedirect$time;
        // for Firefox 102 and older
        performance.measure(`ðŸ›¸ ${nextUfoName} [redirect]`, {
          start: (_prevRedirect$time = prevRedirect === null || prevRedirect === void 0 ? void 0 : prevRedirect.time) !== null && _prevRedirect$time !== void 0 ? _prevRedirect$time : interaction.start,
          end: time,
          detail: {
            devtools: {
              track: 'ðŸ›¸ reactUFO detailed timings',
              color: 'tertiary'
            }
          }
        });
      } catch {
        // do nothing
      }
    }
  }
}
export const interactionSpans = [];
const defaultLabelStack = [{
  name: 'custom'
}];
export function addCustomSpans(name, start, end = performance.now(), size = 0, labelStack = defaultLabelStack) {
  const customSpan = {
    type: 'custom',
    name,
    start,
    end,
    labelStack,
    size
  };
  interactionSpans.push(customSpan);
}