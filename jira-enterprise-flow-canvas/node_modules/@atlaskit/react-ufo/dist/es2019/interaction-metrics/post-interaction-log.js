import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { getConfig } from '../config';
import { getPageVisibilityState } from '../hidden-timing';
import { VCObserverWrapper } from '../vc';
const POST_INTERACTION_LOG_SEND_DEFAULT_TIMEOUT = 3000;
export default class PostInteractionLog {
  constructor() {
    /**
     * Basic info about interaction that has just finished
     */
    _defineProperty(this, "lastInteractionFinish", null);
    /**
     * Array of observed react render timings
     */
    _defineProperty(this, "reactProfilerTimings", []);
    /**
     * Store the scheduled sink timeout Id so that it can be cancelled when needed
     */
    _defineProperty(this, "sinkTimeoutId", null);
    _defineProperty(this, "holdInfo", []);
    /**
     * independent VC observer, that observes until `custom.post-interaction-logs` event is sent
     */
    _defineProperty(this, "vcObserver", null);
    _defineProperty(this, "vcObserverSSRConfig", null);
    /**
     * Handler function to process / send the observation data
     */
    _defineProperty(this, "sinkHandlerFn", () => {});
  }
  initializeVCObserver(options) {
    this.vcObserver = new VCObserverWrapper({
      ...options,
      isPostInteraction: true
    });
  }
  startVCObserver({
    startTime
  }) {
    var _this$vcObserver;
    (_this$vcObserver = this.vcObserver) === null || _this$vcObserver === void 0 ? void 0 : _this$vcObserver.start({
      startTime
    });
  }
  stopVCObserver() {
    var _this$vcObserver2;
    (_this$vcObserver2 = this.vcObserver) === null || _this$vcObserver2 === void 0 ? void 0 : _this$vcObserver2.stop();
  }
  setVCObserverSSRConfig(vcObserverSSRConfig) {
    this.vcObserverSSRConfig = vcObserverSSRConfig;
  }

  /**
   * Set the VC result as per the last interaction
   * Used to compare diffs of VC updates vs post interaction VC observer
   * @param result - VC result as calculated by UFO create payload
   */
  setLastInteractionFinishVCResult(result) {
    this.lastInteractionFinishVCResult = result;
  }
  /**
   * Set the fn that would be invoked to process / send the observation data
   */
  sinkHandler(sinkHandlerFn) {
    this.sinkHandlerFn = sinkHandlerFn;
  }

  /**
   * Reset state of the log
   */
  reset() {
    this.lastInteractionFinish = null;
    this.reactProfilerTimings = [];
    this.holdInfo = [];
    if (this.sinkTimeoutId != null) {
      clearTimeout(this.sinkTimeoutId);
      this.sinkTimeoutId = null;
    }
    this.setVCObserverSSRConfig(null);
  }

  /**
   * Check if there is data in the log
   */
  hasData() {
    var _this$reactProfilerTi;
    return ((_this$reactProfilerTi = this.reactProfilerTimings) === null || _this$reactProfilerTi === void 0 ? void 0 : _this$reactProfilerTi.length) > 0;
  }

  /**
   * Send the log if there is data
   */
  async sendPostInteractionLog() {
    var _this$vcObserver4, _config$vc, _config$vc2, _this$vcObserver5;
    if (!this.lastInteractionFinish || !this.sinkHandlerFn) {
      var _this$vcObserver3;
      this.reset();
      (_this$vcObserver3 = this.vcObserver) === null || _this$vcObserver3 === void 0 ? void 0 : _this$vcObserver3.stop();
      return;
    }
    const pageVisibilityState = getPageVisibilityState(this.lastInteractionFinish.start, this.lastInteractionFinish.end);
    const isPageVisible = pageVisibilityState === 'visible';
    const config = getConfig();
    const postInteractionFinishVCResult = await ((_this$vcObserver4 = this.vcObserver) === null || _this$vcObserver4 === void 0 ? void 0 : _this$vcObserver4.getVCResult({
      start: this.lastInteractionFinish.start,
      stop: performance.now(),
      tti: -1,
      // no need for TTI value here
      isEventAborted: !!this.lastInteractionFinish.abortReason,
      prefix: 'ufo',
      experienceKey: this.lastInteractionFinish.ufoName,
      interactionId: this.lastInteractionFinish.id,
      includeSSRInV3: config === null || config === void 0 ? void 0 : (_config$vc = config.vc) === null || _config$vc === void 0 ? void 0 : _config$vc.includeSSRInV3,
      includeSSRRatio: config === null || config === void 0 ? void 0 : (_config$vc2 = config.vc) === null || _config$vc2 === void 0 ? void 0 : _config$vc2.includeSSRRatio,
      ...this.vcObserverSSRConfig,
      interactionType: this.lastInteractionFinish.type,
      isPageVisible,
      interactionAbortReason: this.lastInteractionFinish.abortReason
    }));
    (_this$vcObserver5 = this.vcObserver) === null || _this$vcObserver5 === void 0 ? void 0 : _this$vcObserver5.stop();
    this.sinkHandlerFn({
      lastInteractionFinish: this.lastInteractionFinish,
      reactProfilerTimings: this.reactProfilerTimings,
      postInteractionFinishVCResult,
      lastInteractionFinishVCResult: this.lastInteractionFinishVCResult,
      postInteractionHoldInfo: this.holdInfo
    });
    this.reset();
  }

  /**
   * This fn should be invoked when an interaction has finished
   * Basic details about the finished interaction will be recorded
   * A timeout will be setup to send the post interaction observation after some time.
   */
  onInteractionComplete({
    ufoName,
    start,
    end,
    id,
    abortReason,
    abortedByInteractionName,
    routeName,
    type,
    experimentalTTAI,
    experimentalVC90,
    errors
  }) {
    var _getConfig;
    this.lastInteractionFinish = {
      ufoName,
      start,
      end,
      id,
      abortReason,
      abortedByInteractionName,
      routeName,
      type,
      experimentalTTAI,
      experimentalVC90,
      errors
    };
    const timeout = ((_getConfig = getConfig()) === null || _getConfig === void 0 ? void 0 : _getConfig.timeWindowForLateMutationsInMilliseconds) || POST_INTERACTION_LOG_SEND_DEFAULT_TIMEOUT;
    this.sinkTimeoutId = window.setTimeout(async () => {
      await this.sendPostInteractionLog();
    }, timeout);
  }

  /**
   * This fn should be invoked when a React render happens after interaction has finished
   */
  addProfilerTimings(labelStack, type, actualDuration, baseDuration, startTime, commitTime) {
    if (this.lastInteractionFinish != null) {
      this.reactProfilerTimings.push({
        type,
        actualDuration,
        baseDuration,
        startTime,
        commitTime,
        labelStack
      });
    }
  }
  addHoldInfo(labelStack, name, start) {
    this.holdInfo.push({
      name,
      labelStack,
      start
    });
  }
}