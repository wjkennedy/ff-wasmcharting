export function getVCRevisionDebugDetails({
  revision,
  isClean,
  abortReason,
  VCEntries,
  componentsLog,
  interactionId
}) {
  // Pre-sort VCEntries by time for efficient lookups
  const sortedVCEntries = [...VCEntries].sort((a, b) => a.time - b.time);

  // Pre-calculate max viewport percentage up to each time for efficient lookups
  const maxViewportPercentageAtTime = new Map();
  let maxSoFar = 0;
  for (const entry of sortedVCEntries) {
    maxSoFar = Math.max(maxSoFar, entry.vc);
    maxViewportPercentageAtTime.set(entry.time, maxSoFar);
  }

  // Helper function to find the biggest previous viewport percentage
  const getBiggestPreviousViewportPercentage = targetTime => {
    // Binary search for the largest time <= targetTime
    let left = 0;
    let right = sortedVCEntries.length - 1;
    let result = -1;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (sortedVCEntries[mid].time <= targetTime) {
        result = mid;
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    return result >= 0 ? maxViewportPercentageAtTime.get(sortedVCEntries[result].time) || null : null;
  };
  const allVcLogs = [];

  // Add regular VC entries
  for (const entry of VCEntries) {
    const timeLogEntries = componentsLog[entry.time];
    allVcLogs.push({
      time: entry.time,
      viewportPercentage: entry.vc,
      entries: entry.elements.map(element => {
        const logEntry = timeLogEntries === null || timeLogEntries === void 0 ? void 0 : timeLogEntries.find(log => log.targetName === element);
        return {
          elementName: element,
          type: logEntry === null || logEntry === void 0 ? void 0 : logEntry.type,
          rect: logEntry === null || logEntry === void 0 ? void 0 : logEntry.intersectionRect,
          visible: true,
          attributeName: logEntry === null || logEntry === void 0 ? void 0 : logEntry.attributeName,
          oldValue: logEntry === null || logEntry === void 0 ? void 0 : logEntry.oldValue,
          newValue: logEntry === null || logEntry === void 0 ? void 0 : logEntry.newValue,
          ignoreReason: logEntry === null || logEntry === void 0 ? void 0 : logEntry.ignoreReason
        };
      })
    });
  }

  // Add ignored elements - only process timestamps that have ignored elements
  for (const [timestamp, timeLogEntries] of Object.entries(componentsLog)) {
    const ignoredElements = timeLogEntries.filter(log => log.ignoreReason);
    if (ignoredElements.length === 0) {
      continue;
    }
    const time = Number(timestamp);
    const viewportPercentage = getBiggestPreviousViewportPercentage(time);
    allVcLogs.push({
      time,
      viewportPercentage,
      entries: ignoredElements.map(logEntry => ({
        elementName: logEntry.targetName,
        type: logEntry.type,
        rect: logEntry.intersectionRect,
        visible: false,
        attributeName: logEntry.attributeName,
        oldValue: logEntry.oldValue,
        newValue: logEntry.newValue,
        ignoreReason: logEntry.ignoreReason
      }))
    });
  }

  // Sort once at the end
  allVcLogs.sort((a, b) => a.time - b.time);
  return {
    revision,
    isClean,
    abortReason,
    vcLogs: allVcLogs,
    interactionId
  };
}