import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { isContainedWithinMediaWrapper } from '../media-wrapper/vc-utils';
import isNonVisualStyleMutation from './non-visual-styles/is-non-visual-style-mutation';
import { RLLPlaceholderHandlers } from './rll-placeholders';
import { SSRPlaceholderHandlers } from './ssr-placeholders';
const state = {
  normal: 1,
  waitingForFirstRender: 2,
  ignoring: 3
};
function isElementVisible(target) {
  if (!target || typeof target.checkVisibility !== 'function') {
    return true;
  }
  const isVisible = target.checkVisibility({
    contentVisibilityAuto: true,
    opacityProperty: true,
    visibilityProperty: true
  });
  return isVisible;
}
export class Observers {
  constructor(opts) {
    _defineProperty(this, "observedMutations", new WeakMap());
    _defineProperty(this, "elementsInView", new Set());
    _defineProperty(this, "callbacks", new Set());
    _defineProperty(this, "totalTime", 0);
    _defineProperty(this, "_startMeasureTimestamp", -1);
    _defineProperty(this, "ssr", {
      state: state.normal,
      reactRootElement: null,
      renderStart: -1,
      renderStop: -1
    });
    _defineProperty(this, "selectorConfig", {
      id: false,
      testId: false,
      role: false,
      className: true,
      dataVC: true
    });
    _defineProperty(this, "subscribeResults", cb => {
      this.callbacks.add(cb);
    });
    _defineProperty(this, "observeElement", (node, mutation, type, ignoreReason, attributeName, oldValue = null, newValue = null) => {
      var _this$intersectionObs;
      (_this$intersectionObs = this.intersectionObserver) === null || _this$intersectionObs === void 0 ? void 0 : _this$intersectionObs.observe(node);
      this.observedMutations.set(node, {
        mutation,
        ignoreReason,
        type,
        attributeName,
        oldValue,
        newValue
      });
    });
    this.selectorConfig = {
      ...this.selectorConfig,
      ...opts.selectorConfig
    };
    this.intersectionObserver = this.getIntersectionObserver();
    this.mutationObserver = this.getMutationObserver();

    // Use shared SSR placeholder handler if provided, otherwise create new one
    if (opts.ssrPlaceholderHandler) {
      this.ssrPlaceholderHandler = opts.ssrPlaceholderHandler;
    } else {
      var _opts$SSRConfig;
      this.ssrPlaceholderHandler = new SSRPlaceholderHandlers({
        enablePageLayoutPlaceholder: (_opts$SSRConfig = opts.SSRConfig) === null || _opts$SSRConfig === void 0 ? void 0 : _opts$SSRConfig.enablePageLayoutPlaceholder
      });
    }
  }
  isBrowserSupported() {
    return typeof window.IntersectionObserver === 'function' && typeof window.MutationObserver === 'function';
  }
  observe() {
    var _this$mutationObserve;
    this.totalTime = 0;
    this.ssr = {
      state: state.normal,
      reactRootElement: null,
      renderStart: -1,
      renderStop: -1
    };
    (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 ? void 0 : _this$mutationObserve.observe(document.body, {
      attributeFilter: ['hidden', 'style', 'src', 'class'],
      attributeOldValue: true,
      attributes: true,
      childList: true,
      subtree: true
    });
  }
  disconnect() {
    var _this$mutationObserve2, _this$intersectionObs2;
    (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.disconnect();
    (_this$intersectionObs2 = this.intersectionObserver) === null || _this$intersectionObs2 === void 0 ? void 0 : _this$intersectionObs2.disconnect();
    this.observedMutations = new WeakMap();
    this.elementsInView.clear();
    this.callbacks.clear();
    this.ssr.reactRootElement = null;
    this.ssrPlaceholderHandler.clear();
  }
  getTotalTime() {
    return this.totalTime;
  }
  setReactRootElement(element) {
    this.ssr.reactRootElement = element;
  }
  setReactRootRenderStart(startTime = performance.now()) {
    this.ssr.renderStart = startTime;
    this.ssr.state = state.waitingForFirstRender;
  }
  setReactRootRenderStop(stopTime = performance.now()) {
    this.ssr.renderStop = stopTime;
  }
  getMutationObserver() {
    if (!this.isBrowserSupported()) {
      return null;
    }
    return new MutationObserver(mutations => {
      this.measureStart();
      mutations.forEach(mutation => {
        // patching element if timestamp not automatically added
        // eslint-disable-next-line no-param-reassign
        mutation.timestamp = mutation.timestamp === undefined ? performance.now() : mutation.timestamp;
        let ignoreReason = '';
        if (this.ssr.state === state.waitingForFirstRender && mutation.timestamp > this.ssr.renderStart && mutation.target === this.ssr.reactRootElement) {
          this.ssr.state = state.ignoring;
          if (this.ssr.renderStop === -1) {
            // arbitrary 500ms DOM update window
            this.ssr.renderStop = mutation.timestamp + 500;
          }
          ignoreReason = 'ssr-hydration';
        }
        if (this.ssr.state === state.ignoring && mutation.timestamp > this.ssr.renderStart && mutation.target === this.ssr.reactRootElement) {
          if (mutation.timestamp <= this.ssr.renderStop) {
            ignoreReason = 'ssr-hydration';
          } else {
            this.ssr.state = state.normal;
          }
        }
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach(node => {
            if (isContainedWithinMediaWrapper(node)) {
              ignoreReason = 'image';
            }
            if (node instanceof HTMLElement
            /* && !node instanceof HTMLStyleElement && !node instanceof HTMLScriptElement && !node instanceof HTMLLinkElement */) {
              if (this.ssrPlaceholderHandler.isPlaceholder(node) || this.ssrPlaceholderHandler.isPlaceholderIgnored(node)) {
                this.ssrPlaceholderHandler.checkIfExistedAndSizeMatching(node).then(result => {
                  if (result === false) {
                    this.observeElement(node, mutation, 'html', ignoreReason);
                  }
                });
                return;
              }
              if (this.ssrPlaceholderHandler.isPlaceholderReplacement(node) || this.ssrPlaceholderHandler.isPlaceholderIgnored(node)) {
                this.ssrPlaceholderHandler.validateReactComponentMatchToPlaceholder(node).then(result => {
                  if (result === false) {
                    this.observeElement(node, mutation, 'html', ignoreReason);
                  }
                });
                return;
              }
              this.observeElement(node, mutation, 'html', ignoreReason);
            }
            if (node instanceof Text && node.parentElement != null) {
              this.observeElement(node.parentElement, mutation, 'text', ignoreReason);
            }
          });
          mutation.removedNodes.forEach(node => {
            if (node instanceof Element) {
              var _this$intersectionObs3;
              this.elementsInView.delete(node);
              (_this$intersectionObs3 = this.intersectionObserver) === null || _this$intersectionObs3 === void 0 ? void 0 : _this$intersectionObs3.unobserve(node);
            }
          });
        } else if (mutation.type === 'attributes') {
          if (mutation.target instanceof HTMLElement) {
            var _mutation$oldValue;
            const attributeName = mutation.attributeName;
            /*
            	"MutationObserver was explicitly designed to work that way, but I can't now recall the reasoning.
            	I think it might have been something along the lines that for consistency every setAttribute call should create a record.
            	Conceptually there is after all a mutation: there is an old value replaced with a new one,
            	and whether or not they are the same doesn't really matter.
            	And Custom elements should work the same way as MutationObserver."
            	https://github.com/whatwg/dom/issues/520#issuecomment-336574796
            */
            const oldValue = (_mutation$oldValue = mutation.oldValue) !== null && _mutation$oldValue !== void 0 ? _mutation$oldValue : undefined;
            const newValue = attributeName ? mutation.target.getAttribute(attributeName) : undefined;
            if (oldValue !== newValue) {
              if (isNonVisualStyleMutation(mutation)) {
                ignoreReason = 'non-visual-style';
              }
              if (isContainedWithinMediaWrapper(mutation.target)) {
                ignoreReason = 'image';
              }
              this.observeElement(mutation.target, mutation, 'attr', ignoreReason, attributeName, oldValue, newValue);
            }
          }
        }
      });
    });
  }
  getElementName(element) {
    try {
      const tagName = element.localName;
      const dataVCAttr = element.getAttribute('data-vc');
      const dataVC = this.selectorConfig.dataVC && dataVCAttr ? `[data-vc="${dataVCAttr}"]` : '';
      const id = this.selectorConfig.id && element.id ? `#${element.id}` : '';
      let testId = this.selectorConfig.testId ? element.getAttribute('data-testid') || element.getAttribute('data-test-id') : '';
      testId = testId ? `[testid=${testId}]` : '';
      let role = this.selectorConfig.role ? element.getAttribute('role') : '';
      role = role ? `[role=${role}]` : '';
      let classList = this.selectorConfig.className ? Array.from(element.classList).join('.') : '';
      classList = classList === '' ? '' : `.${classList}`;
      const attrs = dataVC ? dataVC : [id, testId, role].join('');
      let idString = '';
      if (attrs === '' && classList === '') {
        const parent = element.parentElement ? this.getElementName(element.parentElement) : 'unknown';
        idString = `${parent} > ${tagName}`;
      } else {
        idString = [tagName, attrs || classList].join('');
      }
      return idString;
    } catch {
      return 'error';
    }
  }
  getIntersectionObserver() {
    if (!this.isBrowserSupported()) {
      return null;
    }
    return new IntersectionObserver(entries => {
      this.measureStart();
      entries.forEach(({
        isIntersecting,
        intersectionRect: ir,
        target
      }) => {
        const data = this.observedMutations.get(target);
        this.observedMutations.delete(target);
        if (isIntersecting && ir.width > 0 && ir.height > 0) {
          if (!(target instanceof HTMLElement)) {
            return;
          }
          if (!(data !== null && data !== void 0 && data.mutation)) {
            // ignore intersection report without recent mutation
            return;
          }
          if (!isElementVisible(target)) {
            data.ignoreReason = 'not-visible';
          }
          if (RLLPlaceholderHandlers.getInstance().isRLLPlaceholderHydration(ir)) {
            data.ignoreReason = 'rll-placeholder';
          }
          this.callbacks.forEach(callback => {
            let elementName;
            try {
              elementName = this.getElementName(target);
            } catch {
              elementName = 'error';
            }
            callback(data.mutation.timestamp || performance.now(), ir, elementName, target, data.type, data.ignoreReason, data.attributeName, data.oldValue, data.newValue);
          });
          this.elementsInView.add(target);
        } else {
          this.elementsInView.delete(target);
        }
      });
      this.measureStop();
    });
  }
  measureStart() {
    this._startMeasureTimestamp = performance.now();
  }
  measureStop() {
    if (this._startMeasureTimestamp === -1) {
      return;
    }
    this.totalTime += performance.now() - this._startMeasureTimestamp;
    this._startMeasureTimestamp = -1;
  }
}