import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { fg } from '@atlaskit/platform-feature-flags';
import { isContainedWithinMediaWrapper } from '../../vc-observer/media-wrapper/vc-utils';
import isDnDStyleMutation from '../../vc-observer/observers/non-visual-styles/is-dnd-style-mutation';
import isNonVisualStyleMutation from '../../vc-observer/observers/non-visual-styles/is-non-visual-style-mutation';
import { RLLPlaceholderHandlers } from '../../vc-observer/observers/rll-placeholders';
import { createIntersectionObserver } from './intersection-observer';
import createMutationObserver from './mutation-observer';
import createPerformanceObserver from './performance-observer';
import checkWithinComponent, { cleanupCaches } from './utils/check-within-component';
import { isContainedWithinSmartAnswers } from './utils/is-contained-within-smart-answers';
import { isElementVisible } from './utils/is-element-visible';
import isInVCIgnoreIfNoLayoutShiftMarker from './utils/is-in-vc-ignore-if-no-layout-shift-marker';
import { isInputNameMutation } from './utils/is-input-name-mutation';
import { isSameRectDimensions } from './utils/is-same-rect-dimensions';
import { isSameRectSize } from './utils/is-same-rect-size';
const createElementMutationsWatcher = (removedNodeRects, isWithinThirdPartySegment, isWithinSmartAnswersSegment, hasSameDeletedNode, timestamp, isTargetReactRoot, getSSRState, getSSRPlaceholderHandler) => ({
  target,
  rect
}) => {
  if (getSSRState) {
    const ssrState = getSSRState();
    const SSRStateEnum = {
      normal: 1,
      waitingForFirstRender: 2,
      ignoring: 3
    };
    if (ssrState.state === SSRStateEnum.waitingForFirstRender && timestamp > ssrState.renderStart && isTargetReactRoot) {
      ssrState.state = SSRStateEnum.ignoring;
      if (ssrState.renderStop === -1) {
        // arbitrary 500ms DOM update window
        ssrState.renderStop = timestamp + 500;
      }
      return 'ssr-hydration';
    }
    if (ssrState.state === SSRStateEnum.ignoring && timestamp > ssrState.renderStart && isTargetReactRoot) {
      if (timestamp <= ssrState.renderStop) {
        return 'ssr-hydration';
      } else {
        ssrState.state = SSRStateEnum.normal;
      }
    }
  }
  if (getSSRPlaceholderHandler) {
    const ssrPlaceholderHandler = getSSRPlaceholderHandler();
    if (ssrPlaceholderHandler) {
      if ((ssrPlaceholderHandler.isPlaceholderV4(target) || ssrPlaceholderHandler.isPlaceholderIgnored(target)) && ssrPlaceholderHandler.checkIfExistedAndSizeMatchingV3(target)) {
        return 'mutation:ssr-placeholder';
      }
      if ((ssrPlaceholderHandler.isPlaceholderReplacementV4(target) || ssrPlaceholderHandler.isPlaceholderIgnored(target)) && ssrPlaceholderHandler.validateReactComponentMatchToPlaceholderV4(target)) {
        return 'mutation:ssr-placeholder';
      }
    }
  }
  if (hasSameDeletedNode && isInVCIgnoreIfNoLayoutShiftMarker(target)) {
    return 'mutation:remount';
  }
  if (isContainedWithinMediaWrapper(target)) {
    return 'mutation:media';
  }
  if (isWithinThirdPartySegment) {
    return 'mutation:third-party-element';
  }
  if (isWithinSmartAnswersSegment) {
    return 'mutation:smart-answers-element';
  }
  const isInIgnoreLsMarker = isInVCIgnoreIfNoLayoutShiftMarker(target);
  if (!isInIgnoreLsMarker) {
    return 'mutation:element';
  }
  const isRLLPlaceholder = RLLPlaceholderHandlers.getInstance().isRLLPlaceholderHydration(rect);
  if (isRLLPlaceholder && isInIgnoreLsMarker) {
    return 'mutation:rll-placeholder';
  }
  const wasDeleted = removedNodeRects.some(nr => isSameRectDimensions(nr, rect));
  if (wasDeleted && isInIgnoreLsMarker) {
    return 'mutation:element-replacement';
  }
  return 'mutation:element';
};
export default class ViewportObserver {
  // SSR context functions

  constructor({
    onChange,
    getSSRState,
    getSSRPlaceholderHandler,
    searchPageConfig
  }) {
    _defineProperty(this, "handleIntersectionEntry", ({
      target,
      rect,
      time,
      type,
      mutationData
    }) => {
      if (!target) {
        return;
      }
      const visible = isElementVisible(target);
      const lastElementRect = this.mapVisibleNodeRects.get(target);
      this.mapVisibleNodeRects.set(target, rect);
      this.onChange({
        time,
        type,
        elementRef: new WeakRef(target),
        visible,
        rect,
        previousRect: lastElementRect,
        mutationData
      });
    });
    _defineProperty(this, "handleChildListMutation", async ({
      target,
      addedNodes,
      removedNodes,
      timestamp
    }) => {
      const removedNodeRects = removedNodes.map(ref => {
        const n = ref.deref();
        if (!n) {
          return;
        }
        return this.mapVisibleNodeRects.get(n);
      });
      const targetNode = target.deref();
      for (const addedNodeRef of addedNodes) {
        var _this$getSSRState, _this$getSSRState$cal, _this$intersectionObs;
        const addedNode = addedNodeRef.deref();
        if (!addedNode) {
          continue;
        }
        const hasSameDeletedNode = removedNodes.find(ref => {
          const n = ref.deref();
          if (!n || !addedNode) {
            return false;
          }
          return n.isEqualNode(addedNode);
        });
        const {
          isWithin: isWithinThirdPartySegment
        } = checkWithinComponent(addedNode, 'UFOThirdPartySegment', this.mapIs3pResult);
        const isWithinSmartAnswersSegment = Boolean(this.shouldCheckSmartAnswersMutations() && isContainedWithinSmartAnswers(addedNode));
        const isTargetReactRoot = targetNode === ((_this$getSSRState = this.getSSRState) === null || _this$getSSRState === void 0 ? void 0 : (_this$getSSRState$cal = _this$getSSRState.call(this)) === null || _this$getSSRState$cal === void 0 ? void 0 : _this$getSSRState$cal.reactRootElement);
        (_this$intersectionObs = this.intersectionObserver) === null || _this$intersectionObs === void 0 ? void 0 : _this$intersectionObs.watchAndTag(addedNode, createElementMutationsWatcher(removedNodeRects, isWithinThirdPartySegment, isWithinSmartAnswersSegment, !!hasSameDeletedNode, timestamp, isTargetReactRoot, this.getSSRState, this.getSSRPlaceholderHandler));
      }
    });
    _defineProperty(this, "handleAttributeMutation", ({
      target,
      attributeName,
      oldValue,
      newValue
    }) => {
      var _this$intersectionObs2;
      (_this$intersectionObs2 = this.intersectionObserver) === null || _this$intersectionObs2 === void 0 ? void 0 : _this$intersectionObs2.watchAndTag(target, ({
        target,
        rect
      }) => {
        if (isContainedWithinMediaWrapper(target)) {
          return {
            type: 'mutation:media',
            mutationData: {
              attributeName,
              oldValue,
              newValue
            }
          };
        }
        if (fg('platform_ufo_exclude_3p_attribute_changes')) {
          const {
            isWithin: isWithinThirdPartySegment
          } = checkWithinComponent(target, 'UFOThirdPartySegment', this.mapIs3pResult);
          if (isWithinThirdPartySegment) {
            return {
              type: 'mutation:third-party-attribute',
              mutationData: {
                attributeName,
                oldValue,
                newValue
              }
            };
          }
        }
        if (this.shouldCheckSmartAnswersMutations() && isContainedWithinSmartAnswers(target)) {
          return {
            type: 'mutation:smart-answers-attribute',
            mutationData: {
              attributeName,
              oldValue,
              newValue
            }
          };
        }
        if (isDnDStyleMutation({
          target,
          attributeName,
          oldValue,
          newValue
        })) {
          return {
            type: 'mutation:attribute:non-visual-style',
            mutationData: {
              attributeName,
              oldValue,
              newValue
            }
          };
        }
        if (isNonVisualStyleMutation({
          target,
          attributeName,
          type: 'attributes'
        })) {
          return {
            type: 'mutation:attribute:non-visual-style',
            mutationData: {
              attributeName,
              oldValue,
              newValue
            }
          };
        }
        if (isInputNameMutation({
          target,
          attributeName,
          oldValue,
          newValue
        })) {
          return {
            type: 'mutation:attribute:non-visual-input-name',
            mutationData: {
              attributeName,
              oldValue,
              newValue
            }
          };
        }
        const isRLLPlaceholder = RLLPlaceholderHandlers.getInstance().isRLLPlaceholderHydration(rect);
        if (isRLLPlaceholder) {
          return {
            type: 'mutation:rll-placeholder',
            mutationData: {
              attributeName,
              oldValue,
              newValue
            }
          };
        }
        const lastElementRect = this.mapVisibleNodeRects.get(target);
        if (lastElementRect && isSameRectSize(rect, lastElementRect)) {
          return {
            type: 'mutation:attribute:no-layout-shift',
            mutationData: {
              attributeName,
              oldValue,
              newValue
            }
          };
        }
        return {
          type: 'mutation:attribute',
          mutationData: {
            attributeName,
            oldValue,
            newValue
          }
        };
      });
    });
    _defineProperty(this, "handleLayoutShift", ({
      time,
      changedRects
    }) => {
      for (const changedRect of changedRects) {
        const target = changedRect.node;
        if (target) {
          const isSameCurrentAndPreviousRects = isSameRectDimensions(changedRect.rect, changedRect.previousRect);
          this.onChange({
            time,
            elementRef: new WeakRef(target),
            visible: true,
            rect: changedRect.rect,
            previousRect: changedRect.previousRect,
            type: isSameCurrentAndPreviousRects ? 'layout-shift:same-rect' : 'layout-shift'
          });
        }
      }
    });
    _defineProperty(this, "shouldCheckSmartAnswersMutations", () => {
      var _this$searchPageConfi, _this$searchPageConfi2, _window, _window$location;
      return ((_this$searchPageConfi = this.searchPageConfig) === null || _this$searchPageConfi === void 0 ? void 0 : _this$searchPageConfi.enableSmartAnswersMutations) && ((_this$searchPageConfi2 = this.searchPageConfig) === null || _this$searchPageConfi2 === void 0 ? void 0 : _this$searchPageConfi2.searchPageRoute) && ((_window = window) === null || _window === void 0 ? void 0 : (_window$location = _window.location) === null || _window$location === void 0 ? void 0 : _window$location.pathname) && window.location.pathname === this.searchPageConfig.searchPageRoute && fg('rovo_search_page_ttvc_ignoring_smart_answers_fix');
    });
    this.mapVisibleNodeRects = new WeakMap();
    this.mapIs3pResult = new WeakMap();
    this.onChange = onChange;
    this.isStarted = false;
    this.intersectionObserver = null;
    this.mutationObserver = null;
    this.performanceObserver = null;

    // Initialize SSR context functions
    this.getSSRState = getSSRState;
    this.getSSRPlaceholderHandler = getSSRPlaceholderHandler;
    this.searchPageConfig = searchPageConfig;
  }
  initializeObservers() {
    if (this.isStarted) {
      return;
    }
    this.intersectionObserver = createIntersectionObserver({
      onEntry: this.handleIntersectionEntry
    });
    this.mutationObserver = createMutationObserver({
      onChildListMutation: this.handleChildListMutation,
      onAttributeMutation: this.handleAttributeMutation
    });
    this.performanceObserver = createPerformanceObserver({
      onLayoutShift: this.handleLayoutShift
    });
  }
  start() {
    var _this$mutationObserve, _this$performanceObse;
    if (this.isStarted) {
      return;
    }
    this.initializeObservers();
    (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 ? void 0 : _this$mutationObserve.observe(document.body, {
      attributeOldValue: true,
      attributes: true,
      childList: true,
      subtree: true
    });
    (_this$performanceObse = this.performanceObserver) === null || _this$performanceObse === void 0 ? void 0 : _this$performanceObse.observe({
      type: 'layout-shift',
      buffered: true,
      // @ts-ignore -error
      durationThreshold: 30
    });
    this.isStarted = true;
  }
  stop() {
    var _this$mutationObserve2, _this$intersectionObs3, _this$performanceObse2;
    if (!this.isStarted) {
      return;
    }
    (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.disconnect();
    (_this$intersectionObs3 = this.intersectionObserver) === null || _this$intersectionObs3 === void 0 ? void 0 : _this$intersectionObs3.disconnect();
    (_this$performanceObse2 = this.performanceObserver) === null || _this$performanceObse2 === void 0 ? void 0 : _this$performanceObse2.disconnect();
    this.isStarted = false;
    // Clean up caches when stopping
    cleanupCaches(this.mapIs3pResult);
  }
}