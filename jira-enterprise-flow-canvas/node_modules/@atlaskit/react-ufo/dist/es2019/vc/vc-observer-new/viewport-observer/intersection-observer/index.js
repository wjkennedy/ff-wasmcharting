import { isZeroDimensionRectangle } from '../utils/is-zero-dimension-rectangle';
function isValidEntry(entry) {
  return entry.isIntersecting && entry.intersectionRect.width > 0 && entry.intersectionRect.height > 0;
}
export function createIntersectionObserver({
  onEntry,
  onObserved
}) {
  if (!window || typeof window.IntersectionObserver !== 'function') {
    return null;
  }
  const callbacksPerElement = new WeakMap();
  const intersectionObserverCallback = entries => {
    const validEntries = [];
    const startTime = performance.now();
    entries.forEach(entry => {
      var _mutationTag;
      if (!(entry.target instanceof HTMLElement)) {
        return;
      }
      const tagOrCallback = callbacksPerElement.get(entry.target);
      if (isZeroDimensionRectangle(entry.intersectionRect)) {
        const zeroDimensionRectangleTagCallback = props => {
          const tagOrCallbackResult = typeof tagOrCallback === 'function' ? tagOrCallback(props) : tagOrCallback;

          // override as display-contents mutation
          if (tagOrCallbackResult === 'mutation:element') {
            return 'mutation:display-contents-children-element';
          }

          // override as display-contents mutation
          if (tagOrCallbackResult && typeof tagOrCallbackResult !== 'string' && tagOrCallbackResult.type === 'mutation:attribute') {
            const {
              attributeName,
              oldValue,
              newValue
            } = tagOrCallbackResult.mutationData;
            const isRoutingMutation = attributeName === 'style' && (!oldValue && newValue === 'display: none !important;' || oldValue === 'display: none !important;' && !newValue);
            if (isRoutingMutation) {
              return {
                type: 'mutation:attribute:framework-routing',
                mutationData: tagOrCallbackResult.mutationData
              };
            }
            return {
              type: 'mutation:display-contents-children-attribute',
              mutationData: tagOrCallbackResult.mutationData
            };
          }
          return tagOrCallbackResult;
        };
        for (const child of entry.target.children) {
          observer.observe(child);
          callbacksPerElement.set(child, zeroDimensionRectangleTagCallback);
        }
        return;
      }
      if (!isValidEntry(entry)) {
        return;
      }
      let mutationTag = null;
      let mutationData = null;
      if (typeof tagOrCallback === 'function') {
        const tagOrCallbackResult = tagOrCallback({
          target: entry.target,
          rect: entry.intersectionRect
        });
        if (!tagOrCallbackResult) {
          mutationTag = 'unknown';
        } else if (typeof tagOrCallbackResult === 'string') {
          mutationTag = tagOrCallbackResult;
        } else {
          mutationTag = tagOrCallbackResult.type;
          mutationData = tagOrCallbackResult.mutationData;
        }
      } else if (typeof tagOrCallback === 'string') {
        mutationTag = tagOrCallback;
      }
      onEntry({
        target: entry.target,
        rect: entry.intersectionRect,
        time: entry.time,
        type: (_mutationTag = mutationTag) !== null && _mutationTag !== void 0 ? _mutationTag : 'unknown',
        mutationData
      });
      validEntries.push(new WeakRef(entry.target));
      callbacksPerElement.delete(entry.target);
      observer.unobserve(entry.target);
    });
    onObserved === null || onObserved === void 0 ? void 0 : onObserved({
      time: startTime,
      elements: validEntries
    });
  };
  const observer = new IntersectionObserver(intersectionObserverCallback);
  return {
    disconnect: () => {
      observer.disconnect();
    },
    unobserve: target => {
      observer.unobserve(target);
    },
    watchAndTag: (target, tagOrCallback) => {
      callbacksPerElement.set(target, tagOrCallback);
      observer.observe(target);
    }
  };
}