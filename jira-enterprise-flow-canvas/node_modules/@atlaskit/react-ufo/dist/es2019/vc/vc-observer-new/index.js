import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { fg } from '@atlaskit/platform-feature-flags';
import { isVCRevisionEnabled } from '../../config';
import { getActiveInteraction } from '../../interaction-metrics';
import { SSRPlaceholderHandlers } from '../vc-observer/observers/ssr-placeholders';
import EntriesTimeline from './entries-timeline';
import getElementName from './get-element-name';
import VCCalculator_FY25_03 from './metric-calculator/fy25_03';
import VCCalculator_FY26_04 from './metric-calculator/fy26_04';
import getViewportHeight from './metric-calculator/utils/get-viewport-height';
import getViewportWidth from './metric-calculator/utils/get-viewport-width';
import VCCalculator_Next from './metric-calculator/vc-next';
import RawDataHandler from './raw-data-handler';
import ViewportObserver from './viewport-observer';
import WindowEventObserver from './window-event-observer';
const SSRState = {
  normal: 1,
  waitingForFirstRender: 2,
  ignoring: 3
};
const DEFAULT_SELECTOR_CONFIG = {
  id: false,
  testId: true,
  role: false,
  className: false,
  dataVC: true
};
let hasAbortingEventDuringSSR = false;
export function getHasAbortingEventDuringSSR() {
  return hasAbortingEventDuringSSR;
}
export default class VCObserverNew {
  constructor(config) {
    var _config$isPostInterac, _config$selectorConfi;
    _defineProperty(this, "viewportObserver", null);
    _defineProperty(this, "windowEventObserver", null);
    // SSR related properties
    _defineProperty(this, "ssrPlaceholderHandler", null);
    _defineProperty(this, "ssr", {
      state: SSRState.normal,
      reactRootElement: null,
      renderStart: -1,
      renderStop: -1
    });
    this.entriesTimeline = new EntriesTimeline();
    this.isPostInteraction = (_config$isPostInterac = config.isPostInteraction) !== null && _config$isPostInterac !== void 0 ? _config$isPostInterac : false;
    this.selectorConfig = (_config$selectorConfi = config.selectorConfig) !== null && _config$selectorConfi !== void 0 ? _config$selectorConfi : DEFAULT_SELECTOR_CONFIG;

    // Use shared SSR placeholder handler if provided, otherwise create new one if feature flag is enabled
    if (config.ssrPlaceholderHandler) {
      this.ssrPlaceholderHandler = config.ssrPlaceholderHandler;
    } else {
      var _config$SSRConfig$ena, _config$SSRConfig;
      this.ssrPlaceholderHandler = new SSRPlaceholderHandlers({
        enablePageLayoutPlaceholder: (_config$SSRConfig$ena = (_config$SSRConfig = config.SSRConfig) === null || _config$SSRConfig === void 0 ? void 0 : _config$SSRConfig.enablePageLayoutPlaceholder) !== null && _config$SSRConfig$ena !== void 0 ? _config$SSRConfig$ena : false
      });
    }
    this.viewportObserver = new ViewportObserver({
      onChange: onChangeArg => {
        const {
          time,
          type,
          elementRef,
          visible,
          rect,
          previousRect,
          mutationData
        } = onChangeArg;
        let elementName = 'unknown';
        const element = elementRef.deref();
        if (element) {
          elementName = this.getElementName(element);
        }
        const data = {
          type,
          elementName,
          rect,
          previousRect,
          visible,
          attributeName: mutationData === null || mutationData === void 0 ? void 0 : mutationData.attributeName,
          oldValue: mutationData === null || mutationData === void 0 ? void 0 : mutationData.oldValue,
          newValue: mutationData === null || mutationData === void 0 ? void 0 : mutationData.newValue
        };
        if (element) {
          const labelStacks = getLabelStacks(element);
          if (labelStacks) {
            Object.assign(data, {
              labelStacks
            });
          }
        }
        this.entriesTimeline.push({
          time,
          data
        });
      },
      // Pass SSR context to ViewportObserver
      getSSRState: () => this.getSSRState(),
      getSSRPlaceholderHandler: () => this.getSSRPlaceholderHandler(),
      searchPageConfig: config.searchPageConfig
    });
    this.windowEventObserver = new WindowEventObserver({
      onEvent: ({
        time,
        type
      }) => {
        // Don't abort press interactions on keydown events, as keydown is expected
        // when users press Enter/Space to activate buttons or other interactive elements
        if (type === 'keydown' && fg('platform_ufo_keypress_interaction_abort')) {
          const interaction = getActiveInteraction();
          if ((interaction === null || interaction === void 0 ? void 0 : interaction.type) === 'press') {
            return;
          }
        }
        this.entriesTimeline.push({
          time,
          data: {
            type: 'window:event',
            eventType: type
          }
        });
      }
    });
  }
  start(_) {
    var _this$viewportObserve;
    // Reset SSR state on start (matches old VCObserver behavior)
    this.ssr = {
      state: SSRState.normal,
      reactRootElement: null,
      // Reset to null (matches old VCObserver)
      renderStart: -1,
      renderStop: -1
    };
    (_this$viewportObserve = this.viewportObserver) === null || _this$viewportObserve === void 0 ? void 0 : _this$viewportObserve.start();
    if (fg('ufo_fix_aborting_interaction_detection_during_ssr')) {
      var _window, _this$windowEventObse;
      this.entriesTimeline.clear();
      if ((_window = window) !== null && _window !== void 0 && _window.__SSR_ABORT_LISTENERS__) {
        const abortListeners = window.__SSR_ABORT_LISTENERS__;
        const aborts = abortListeners.aborts;
        if (aborts && typeof aborts === 'object') {
          Object.entries(aborts).forEach(([key, time]) => {
            if (typeof time === 'number') {
              this.entriesTimeline.push({
                time,
                data: {
                  type: 'window:event',
                  eventType: key
                }
              });
            }
          });
        }
      }
      (_this$windowEventObse = this.windowEventObserver) === null || _this$windowEventObse === void 0 ? void 0 : _this$windowEventObse.start();
    } else {
      var _window2, _this$windowEventObse2;
      if ((_window2 = window) !== null && _window2 !== void 0 && _window2.__SSR_ABORT_LISTENERS__) {
        const abortListeners = window.__SSR_ABORT_LISTENERS__;
        const aborts = abortListeners.aborts;
        if (aborts && typeof aborts === 'object') {
          Object.entries(aborts).forEach(([key, time]) => {
            if (typeof time === 'number') {
              this.entriesTimeline.push({
                time,
                data: {
                  type: 'window:event',
                  eventType: key
                }
              });
              if (fg('ufo_detect_aborting_interaction_during_ssr')) {
                hasAbortingEventDuringSSR = true;
              }
            }
          });
        }
      }
      (_this$windowEventObse2 = this.windowEventObserver) === null || _this$windowEventObse2 === void 0 ? void 0 : _this$windowEventObse2.start();
      this.entriesTimeline.clear();
    }
  }
  stop() {
    var _this$viewportObserve2, _this$windowEventObse3;
    (_this$viewportObserve2 = this.viewportObserver) === null || _this$viewportObserve2 === void 0 ? void 0 : _this$viewportObserve2.stop();
    (_this$windowEventObse3 = this.windowEventObserver) === null || _this$windowEventObse3 === void 0 ? void 0 : _this$windowEventObse3.stop();

    // Clear SSR state on stop (matches old VCObserver behavior)
    this.ssr.reactRootElement = null;
  }

  // SSR related methods
  setReactRootElement(element) {
    this.ssr.reactRootElement = element;
  }
  setReactRootRenderStart(startTime = performance.now()) {
    this.ssr.renderStart = startTime;
    this.ssr.state = SSRState.waitingForFirstRender;
  }
  setReactRootRenderStop(stopTime = performance.now()) {
    this.ssr.renderStop = stopTime;
  }
  collectSSRPlaceholders() {
    // This is handled by the shared SSRPlaceholderHandlers in VCObserverWrapper
    // Individual observers don't need to implement this
  }

  // Internal methods for ViewportObserver to access SSR state
  getSSRState() {
    return this.ssr;
  }
  getSSRPlaceholderHandler() {
    return this.ssrPlaceholderHandler;
  }
  addSSR(ssr) {
    this.entriesTimeline.push({
      time: ssr,
      data: {
        elementName: 'SSR',
        type: 'mutation:element',
        rect: {
          height: getViewportHeight(),
          width: getViewportWidth(),
          left: 0,
          top: 0,
          x: 0,
          y: 0,
          bottom: getViewportHeight(),
          right: getViewportWidth(),
          toJSON() {
            return null;
          }
        },
        visible: true
      }
    });
  }
  async getVCResult(param) {
    const {
      start,
      stop,
      interactionId,
      interactionType,
      interactionAbortReason,
      isPageVisible,
      include3p,
      includeSSRRatio,
      excludeSmartAnswersInSearch,
      includeRawData,
      rawDataStopTime
    } = param;
    const results = [];
    this.addStartEntry(start);
    const feVCCalculationStartTime = performance.now();
    const calculator_fy25_03 = new VCCalculator_FY25_03();
    if (param.includeSSRInV3 && param.ssr) {
      this.addSSR(param.ssr);
    }
    const orderedEntries = this.entriesTimeline.getOrderedEntries({
      start,
      stop
    });
    const fy25_03 = isVCRevisionEnabled('fy25.03') ? await calculator_fy25_03.calculate({
      orderedEntries,
      startTime: start,
      stopTime: stop,
      interactionId,
      interactionType,
      isPostInteraction: this.isPostInteraction,
      include3p,
      excludeSmartAnswersInSearch,
      includeSSRRatio,
      isPageVisible,
      interactionAbortReason
    }) : null;
    if (fy25_03) {
      results.push(fy25_03);
    }

    // From TTVC v4 onwards, ensuring that SSR entry is always auto-added, whenever it is configured.
    if (param.ssr) {
      this.addSSR(param.ssr);
    }
    const calculator_fy26_04 = new VCCalculator_FY26_04();
    const calculator_next = new VCCalculator_Next();
    const calculatorParams = {
      orderedEntries,
      startTime: start,
      stopTime: stop,
      interactionId,
      interactionType,
      isPostInteraction: this.isPostInteraction,
      include3p,
      excludeSmartAnswersInSearch,
      includeSSRRatio,
      isPageVisible,
      interactionAbortReason
    };
    const [fy26_04, vcNext] = await Promise.all([isVCRevisionEnabled('fy26.04') ? calculator_fy26_04.calculate(calculatorParams) : null, isVCRevisionEnabled('next') ? calculator_next.calculate(calculatorParams) : null]);
    if (fy26_04) {
      results.push(fy26_04);
    }
    if (vcNext) {
      results.push(vcNext);
    }
    const feVCCalculationEndTime = performance.now();
    if (includeRawData && fg('platform_ufo_enable_vc_raw_data')) {
      const rawVCCalculationStartTime = performance.now();
      const rawHandler = new RawDataHandler();
      // Use rawDataStopTime (end3p) when available to capture observations during 3p holds
      const rawStopTime = rawDataStopTime !== null && rawDataStopTime !== void 0 ? rawDataStopTime : stop;
      const rawOrderedEntries = rawDataStopTime ? this.entriesTimeline.getOrderedEntries({
        start,
        stop: rawStopTime
      }) : orderedEntries;
      const raw = await rawHandler.getRawData({
        entries: rawOrderedEntries,
        startTime: start,
        stopTime: rawStopTime,
        isPageVisible
      });
      results.forEach(result => {
        delete result.vcDetails;
        delete result.ratios;
      });
      if (raw) {
        raw.rawVCTime = Number((performance.now() - rawVCCalculationStartTime).toFixed(2));
        raw.feVCTime = Number((feVCCalculationEndTime - feVCCalculationStartTime).toFixed(2));
        results.push(raw);
      }
    }
    return results;
  }
  addStartEntry(startTime) {
    this.entriesTimeline.push({
      time: startTime,
      data: {
        type: 'mutation:element',
        elementName: 'START',
        visible: true,
        rect: {
          x: 0,
          y: 0,
          width: window.innerWidth,
          height: window.innerHeight,
          top: 0,
          left: 0,
          bottom: window.innerHeight,
          right: window.innerWidth,
          toJSON: function () {
            return {
              x: this.x,
              y: this.y,
              width: this.width,
              height: this.height,
              top: this.top,
              left: this.left,
              bottom: this.bottom,
              right: this.right
            };
          }
        }
      }
    });
  }
  getElementName(element) {
    return getElementName(this.selectorConfig, element);
  }
}
function labelStackFromFiber(fiber) {
  var _fiber$child, _fiber$child$memoized;
  const value = fiber === null || fiber === void 0 ? void 0 : (_fiber$child = fiber.child) === null || _fiber$child === void 0 ? void 0 : (_fiber$child$memoized = _fiber$child.memoizedProps) === null || _fiber$child$memoized === void 0 ? void 0 : _fiber$child$memoized.value;
  return Array.isArray(value === null || value === void 0 ? void 0 : value.labelStack) ? value.labelStack : [];
}
function labelStackToString(labelStack) {
  return labelStack.map(label => label.name).join('/');
}
function labelStackToSegment(labelStack) {
  let segmentIndex = -1;
  for (let i = labelStack.length - 1; i >= 0; i--) {
    if (labelStack[i].segmentId) {
      segmentIndex = i;
      break;
    }
  }
  return labelStack.slice(0, segmentIndex + 1).map(label => label.name).join('/');
}
function traverseFiber(fiber) {
  let segment = 'unknown';
  let labelStackString = 'unknown';
  let currentFiber = fiber;
  while (currentFiber) {
    if (currentFiber.type) {
      const componentName = currentFiber.type.displayName || currentFiber.type.name;
      if (componentName === 'UFOSegment' || componentName === 'UFOLabel') {
        const labelStack = labelStackFromFiber(currentFiber);
        labelStackString = labelStackToString(labelStack) || 'unknown';
        segment = labelStackToSegment(labelStack) || 'unknown';
        break;
      }
    }
    currentFiber = currentFiber.return;
  }
  return {
    segment,
    labelStack: labelStackString
  };
}
function getLabelStacks(element) {
  const reactFiberKey = Object.keys(element).find(key => key.startsWith('__reactFiber$'));
  if (!reactFiberKey) {
    return null;
  }
  const fiber = element[reactFiberKey];
  return fiber ? traverseFiber(fiber) : null;
}