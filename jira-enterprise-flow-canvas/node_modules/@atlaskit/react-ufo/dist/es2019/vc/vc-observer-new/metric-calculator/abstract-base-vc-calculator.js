import { fg } from '@atlaskit/platform-feature-flags';
import { calculateTTVCPercentilesWithDebugInfo } from './percentile-calc';
import getViewportHeight from './utils/get-viewport-height';
import getViewportWidth from './utils/get-viewport-width';

// Create comprehensive debug details including ignored entries

// Helper function for reporting ratios
function roundDecimal(value, decimals = 3) {
  const factor = Math.pow(10, decimals);
  return Math.round(value * factor) / factor;
}
export default class AbstractVCCalculatorBase {
  constructor(revisionNo) {
    this.revisionNo = revisionNo;
  }
  filterViewportEntries(entries) {
    return entries.filter(entry => {
      return 'rect' in entry.data;
    });
  }

  /**
   * Calculate ratios for each element based on their viewport coverage.
   */
  calculateRatios(filteredEntries) {
    const ratios = {};
    const viewportWidth = getViewportWidth();
    const viewportHeight = getViewportHeight();
    const totalViewportArea = viewportWidth * viewportHeight;
    if (totalViewportArea === 0) {
      return ratios;
    }
    const elementRects = new Map();
    for (const entry of filteredEntries) {
      if ('rect' in entry.data) {
        const viewportEntry = entry.data;
        elementRects.set(viewportEntry.elementName, viewportEntry.rect);
      }
    }
    for (const [elementName, rect] of elementRects) {
      const elementArea = rect.width * rect.height;
      ratios[elementName] = roundDecimal(elementArea / totalViewportArea);
    }
    return ratios;
  }
  getLabelStacks(filteredEntries, isPostInteraction) {
    const labelStacks = {};
    for (const entry of filteredEntries) {
      if ('elementName' in entry.data && entry.data.labelStacks) {
        if (isPostInteraction) {
          labelStacks[entry.data.elementName] = {
            segment: entry.data.labelStacks.segment,
            labelStack: entry.data.labelStacks.labelStack
          };
        } else {
          labelStacks[entry.data.elementName] = entry.data.labelStacks.labelStack;
        }
      }
    }
    return labelStacks;
  }
  async calculateWithDebugInfo(filteredEntries, startTime, stopTime, isPostInteraction, isVCClean, interactionType, isPageVisible, interactionId, dirtyReason, allEntries, include3p, excludeSmartAnswersInSearch, interactionAbortReason, includeSSRRatio) {
    var _window, _window2, _window3, _window4, _window6;
    const percentiles = [25, 50, 75, 80, 85, 90, 95, 98, 99, 100];
    const viewportEntries = this.filterViewportEntries(filteredEntries);
    const {
      entries: vcLogs,
      speedIndex
    } = await calculateTTVCPercentilesWithDebugInfo({
      viewport: {
        width: getViewportWidth(),
        height: getViewportHeight()
      },
      startTime,
      stopTime,
      orderedEntries: viewportEntries
    });
    const vcDetails = {};
    let percentileIndex = 0;
    const entryDataBuffer = new Set();
    let ssrRatio = -1;
    if (vcLogs) {
      for (const entry of vcLogs) {
        const {
          time,
          viewportPercentage,
          entries
        } = entry;
        if (includeSSRRatio && ssrRatio === -1 && entries.some(e => e.elementName === 'SSR')) {
          ssrRatio = viewportPercentage;
        }

        // Only process entries if we haven't reached all percentiles
        if (percentileIndex >= percentiles.length) {
          break;
        }

        // Check if this entry matches any checkpoint percentiles
        if (viewportPercentage >= percentiles[percentileIndex]) {
          const elementNames = [...new Set(entries.map(e => e.elementName))];

          // Process all matching percentiles in one go
          while (percentileIndex < percentiles.length && viewportPercentage >= percentiles[percentileIndex]) {
            vcDetails[`${percentiles[percentileIndex]}`] = {
              t: Math.round(time),
              e: elementNames
            };
            percentileIndex++;
          }

          // Clear buffer after processing all matching percentiles
          entryDataBuffer.clear();
        } else {
          // Only add to buffer if we haven't reached all percentiles
          entries.forEach(e => entryDataBuffer.add(e));
        }
      }
    }

    // Fill in any missing percentiles with the last known values
    let previousResult = {
      t: 0,
      e: []
    };
    for (let i = 0; i < percentiles.length; i++) {
      const percentile = percentiles[i];
      if (!(percentile in vcDetails)) {
        vcDetails[`${percentile}`] = previousResult;
      } else {
        previousResult = vcDetails[`${percentile}`];
      }
    }
    let enhancedVcLogs = vcLogs ? vcLogs.map(log => ({
      ...log,
      entries: log.entries.map(entry => {
        var _entry$rect, _entry$previousRect;
        return {
          ...entry,
          rect: (_entry$rect = entry.rect) === null || _entry$rect === void 0 ? void 0 : _entry$rect.toJSON(),
          previousRect: (_entry$previousRect = entry.previousRect) === null || _entry$previousRect === void 0 ? void 0 : _entry$previousRect.toJSON()
        };
      }),
      viewportPercentage: log.viewportPercentage
    })) : [];

    // If 3p metric enabled - calculate the debug details
    const shouldCalculate3p = include3p && fg('platform_ufo_enable_ttai_with_3p');
    // Only calculate enhanced debug details if devtool callbacks exist

    const shouldCalculateDebugDetails = !isPostInteraction && (typeof ((_window = window) === null || _window === void 0 ? void 0 : _window.__ufo_devtool_onVCRevisionReady__) === 'function' || typeof ((_window2 = window) === null || _window2 === void 0 ? void 0 : _window2.__on_ufo_vc_debug_data_ready) === 'function' || typeof ((_window3 = window) === null || _window3 === void 0 ? void 0 : _window3.__ufo_devtool_vc_3p_debug_data) === 'function');
    if (shouldCalculateDebugDetails && allEntries && vcLogs) {
      // Pre-sort vcLogs by time for efficient lookups
      const sortedVcLogs = [...vcLogs].sort((a, b) => a.time - b.time);

      // Pre-calculate max viewport percentage up to each time for efficient lookups
      const maxViewportPercentageAtTime = new Map();
      let maxSoFar = 0;
      for (const log of sortedVcLogs) {
        if (log.viewportPercentage !== null) {
          maxSoFar = Math.max(maxSoFar, log.viewportPercentage);
          maxViewportPercentageAtTime.set(log.time, maxSoFar);
        }
      }

      // Helper function to find the biggest previous viewport percentage
      const getBiggestPreviousViewportPercentage = targetTime => {
        // Binary search for the largest time <= targetTime
        let left = 0;
        let right = sortedVcLogs.length - 1;
        let result = -1;
        while (left <= right) {
          const mid = Math.floor((left + right) / 2);
          if (sortedVcLogs[mid].time <= targetTime) {
            result = mid;
            left = mid + 1;
          } else {
            right = mid - 1;
          }
        }
        return result >= 0 ? maxViewportPercentageAtTime.get(sortedVcLogs[result].time) || null : null;
      };

      // Group ignored entries by timestamp
      const ignoredEntriesByTime = new Map();
      for (const entry of allEntries) {
        if ('rect' in entry.data && !this.isEntryIncluded(entry, include3p, excludeSmartAnswersInSearch)) {
          var _ignoredEntriesByTime, _viewportData$rect, _viewportData$previou;
          const viewportData = entry.data;
          const timestamp = Math.round(entry.time);
          if (!ignoredEntriesByTime.has(timestamp)) {
            ignoredEntriesByTime.set(timestamp, []);
          }
          (_ignoredEntriesByTime = ignoredEntriesByTime.get(timestamp)) === null || _ignoredEntriesByTime === void 0 ? void 0 : _ignoredEntriesByTime.push({
            ...viewportData,
            rect: (_viewportData$rect = viewportData.rect) === null || _viewportData$rect === void 0 ? void 0 : _viewportData$rect.toJSON(),
            previousRect: (_viewportData$previou = viewportData.previousRect) === null || _viewportData$previou === void 0 ? void 0 : _viewportData$previou.toJSON(),
            ignoreReason: viewportData.visible ? viewportData.type : 'not-visible'
          });
        }
      }

      // Add ignored entries to vcLogs
      const additionalVcLogs = [];
      for (const [timestamp, ignoredEntries] of ignoredEntriesByTime) {
        if (ignoredEntries.length > 0) {
          const viewportPercentage = getBiggestPreviousViewportPercentage(timestamp);
          additionalVcLogs.push({
            time: timestamp,
            viewportPercentage,
            entries: ignoredEntries
          });
        }
      }

      // Combine and sort all vcLogs
      enhancedVcLogs = [...enhancedVcLogs, ...additionalVcLogs].sort((a, b) => a.time - b.time);
    }

    // Only create debug details if callbacks exist
    let v3RevisionDebugDetails = null;
    if (shouldCalculateDebugDetails) {
      v3RevisionDebugDetails = {
        revision: this.revisionNo,
        isClean: isVCClean && !interactionAbortReason && isPageVisible,
        abortReason: !isPageVisible ? 'browser_backgrounded' : dirtyReason !== null && dirtyReason !== void 0 ? dirtyReason : interactionAbortReason,
        vcLogs: enhancedVcLogs,
        interactionId,
        interactionType
      };
    }

    // Handle devtool callback
    if (v3RevisionDebugDetails && typeof ((_window4 = window) === null || _window4 === void 0 ? void 0 : _window4.__ufo_devtool_onVCRevisionReady__) === 'function' && !include3p) {
      try {
        var _window5, _window5$__ufo_devtoo;
        (_window5 = window) === null || _window5 === void 0 ? void 0 : (_window5$__ufo_devtoo = _window5.__ufo_devtool_onVCRevisionReady__) === null || _window5$__ufo_devtoo === void 0 ? void 0 : _window5$__ufo_devtoo.call(_window5, v3RevisionDebugDetails);
      } catch (e) {
        // if any error communicating with devtool, we don't want to break the app
        // eslint-disable-next-line no-console
        console.error('Error in onVCRevisionReady', e);
      }
    }
    if (v3RevisionDebugDetails && typeof ((_window6 = window) === null || _window6 === void 0 ? void 0 : _window6.__on_ufo_vc_debug_data_ready) === 'function' && !include3p) {
      try {
        var _window7, _window7$__on_ufo_vc_;
        (_window7 = window) === null || _window7 === void 0 ? void 0 : (_window7$__on_ufo_vc_ = _window7.__on_ufo_vc_debug_data_ready) === null || _window7$__on_ufo_vc_ === void 0 ? void 0 : _window7$__on_ufo_vc_.call(_window7, v3RevisionDebugDetails);
      } catch (e) {
        // eslint-disable-next-line no-console
        console.error('Error in onVCRevisionReady', e);
      }
    }
    if (v3RevisionDebugDetails && shouldCalculate3p) {
      try {
        // Log vc details with 3p for debugging
        window.__ufo_devtool_vc_3p_debug_data = v3RevisionDebugDetails;
      } catch (e) {
        // eslint-disable-next-line no-console
        console.error('Error in 3pDebugData', e);
      }
    }
    return {
      vcDetails,
      ssrRatio,
      speedIndex
    };
  }
  async calculate({
    startTime,
    stopTime,
    orderedEntries,
    interactionId,
    isPostInteraction,
    include3p,
    excludeSmartAnswersInSearch,
    includeSSRRatio,
    interactionType,
    isPageVisible,
    interactionAbortReason
  }) {
    var _vcDetails$90$t, _vcDetails$;
    const filteredEntries = orderedEntries.filter(entry => {
      return this.isEntryIncluded(entry, include3p, excludeSmartAnswersInSearch);
    });
    let isVCClean;
    let dirtyReason;
    const getVCCleanStatusResult = this.getVCCleanStatus(filteredEntries);
    isVCClean = getVCCleanStatusResult.isVCClean;
    dirtyReason = getVCCleanStatusResult.dirtyReason;
    if (!isVCClean) {
      return {
        revision: this.revisionNo,
        'metric:vc90': null,
        clean: false,
        abortReason: dirtyReason,
        abortTimestamp: getVCCleanStatusResult.abortTimestamp
      };
    }
    const {
      vcDetails,
      ssrRatio,
      speedIndex
    } = await this.calculateWithDebugInfo(filteredEntries, startTime, stopTime, isPostInteraction, isVCClean, interactionType, isPageVisible, interactionId, dirtyReason, orderedEntries, include3p, excludeSmartAnswersInSearch, interactionAbortReason, includeSSRRatio);
    const result = {
      revision: this.revisionNo,
      clean: true,
      'metric:vc90': (_vcDetails$90$t = vcDetails === null || vcDetails === void 0 ? void 0 : (_vcDetails$ = vcDetails['90']) === null || _vcDetails$ === void 0 ? void 0 : _vcDetails$.t) !== null && _vcDetails$90$t !== void 0 ? _vcDetails$90$t : null,
      vcDetails: vcDetails !== null && vcDetails !== void 0 ? vcDetails : undefined
    };
    result.ratios = this.calculateRatios(filteredEntries);
    if (ssrRatio !== -1) {
      result.ssrRatio = ssrRatio;
    }

    // speedIndex is only included in the result when it has a meaningful value (> 0)
    if (speedIndex > 0) {
      result.speedIndex = speedIndex;
    }
    result.labelStacks = this.getLabelStacks(filteredEntries, isPostInteraction);
    return result;
  }
}