import { fg } from '@atlaskit/platform-feature-flags';
import { ViewportCanvas } from './canvas-pixel';
async function calculateTTVCPercentiles({
  viewport,
  orderedEntries,
  percentiles,
  startTime
}) {
  const canvas = new ViewportCanvas(viewport, fg('platform_ufo_canvas_heatmap_full_precision') ? 1 : 0.25);
  const elementMap = new Map();
  for (const entry of orderedEntries) {
    if (!('rect' in entry.data)) {
      continue;
    }
    const rect = entry.data.rect;
    const elementName = entry.data.elementName;
    canvas.drawRect(rect, entry.time);
    if (!elementMap.has(entry.time)) {
      elementMap.set(entry.time, new Set());
    }
    elementMap.get(entry.time).add(elementName);
  }

  // Get pixel counts
  const timePixelCounts = await canvas.getPixelCounts();
  const canvasDimenstions = canvas.getScaledDimensions();
  const totalPixels = canvasDimenstions.width * canvasDimenstions.height;
  return calculatePercentiles(timePixelCounts, elementMap, percentiles, totalPixels, startTime);
}
async function calculateTTVCPercentilesWithDebugInfo({
  viewport,
  orderedEntries,
  startTime
}) {
  const canvas = new ViewportCanvas(viewport, fg('platform_ufo_canvas_heatmap_full_precision') ? 1 : 0.25);
  const elementMap = new Map();
  for (const entry of orderedEntries) {
    if (!('rect' in entry.data)) {
      continue;
    }
    const rect = entry.data.rect;
    canvas.drawRect(rect, entry.time);
    if (!elementMap.has(entry.time)) {
      elementMap.set(entry.time, []);
    }
    elementMap.get(entry.time).push(entry.data);
  }

  // Get pixel counts
  const timePixelCounts = await canvas.getPixelCounts();
  const canvasDimensions = canvas.getScaledDimensions();
  const totalPixels = canvasDimensions.width * canvasDimensions.height;
  return calculatePercentilesWithDebugInfo(timePixelCounts, elementMap, totalPixels, startTime);
}
export default calculateTTVCPercentiles;
export function calculatePercentiles(timePixelCounts, elementMap, unorderedPercentiles, totalPixels, startTime) {
  const results = {};
  let cumulativePixels = 0;
  const percentiles = unorderedPercentiles.sort((a, b) => a - b);

  // Sort entries by timestamp for consistent processing
  const sortedEntries = Array.from(timePixelCounts.entries()).sort(([timeA], [timeB]) => Number(timeA) - Number(timeB));
  let percentileIndex = 0;
  let domElementsBuffer = new Set();
  for (const [time, pixelCount] of sortedEntries) {
    cumulativePixels += pixelCount;
    const percentCovered = cumulativePixels / totalPixels * 100;
    const elementNames = elementMap.get(time) || new Set();
    elementNames.forEach(elName => domElementsBuffer.add(elName));
    let matchesAnyCheckpoints = false;
    while (percentileIndex < percentiles.length && percentCovered >= percentiles[percentileIndex]) {
      results[`${percentiles[percentileIndex]}`] = {
        t: Math.round(Number(time - startTime)),
        e: Array.from(domElementsBuffer)
      };
      percentileIndex++;
      matchesAnyCheckpoints = true;
    }
    if (matchesAnyCheckpoints) {
      domElementsBuffer.clear();
    }
    if (percentileIndex >= percentiles.length) {
      break;
    }
  }
  let previousResult = {
    t: 0,
    e: []
  };
  for (let i = 0; i < percentiles.length; i++) {
    const percentile = percentiles[i];
    if (!(percentile in results)) {
      results[`${percentile}`] = previousResult;
    }
    previousResult = results[`${percentile}`];
  }
  return results;
}
export function calculatePercentilesWithDebugInfo(timePixelCounts, elementMap, totalPixels, startTime) {
  const entries = new Array(elementMap.size);
  let cumulativePixels = 0;
  let speedIndex = 0;
  let previousPercentCovered = 0;
  const sortedEntries = Array.from(timePixelCounts.entries()).sort(([timeA], [timeB]) => Number(timeA) - Number(timeB));
  for (let i = 0; i < sortedEntries.length; i++) {
    const [time, pixelCount] = sortedEntries[i];
    cumulativePixels += pixelCount;
    const percentCovered = cumulativePixels / totalPixels * 100;
    const entryDatas = elementMap.get(time) || [];
    const relativeTime = Math.round(Number(time - startTime));
    entries[i] = {
      time: relativeTime,
      viewportPercentage: percentCovered,
      entries: Array.from(entryDatas)
    };

    // Speed index calculation: sum of (time Ã— incremental viewport percentage)
    const ratioDelta = (percentCovered - previousPercentCovered) / 100;
    speedIndex += relativeTime * ratioDelta;
    previousPercentCovered = percentCovered;
  }
  return {
    entries,
    speedIndex: Math.round(speedIndex)
  };
}
export { calculateTTVCPercentilesWithDebugInfo };