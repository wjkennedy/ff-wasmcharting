import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { ROOT_CONTEXT } from '@opentelemetry/api';

/**
 * We need to store a reference to the Context manager so that we can get it later.
 * This is because the OTel JS API doesn't allow us to get the registered context manager,
 * and we need to get it because we need to call a function that's not available in the OTel API:
 * `setActive`. The OTel JS API design doesn't allow us to manually set the active context
 * despite the spec allowing for the capability. Sigh.
 * 
 * I imagine this situation might not be permanent if we can move to a system were we can rely
 * solely on the API, but for the purposes of the first change being React UFO API compatible,
 * we'll need to do this.
 */

var contextManager;
export function setContextManager(ctxMgr) {
  contextManager = ctxMgr;
}
export function getContextManager() {
  return contextManager;
}

/** 
 * The below is shamelessly borrowed from StackContextManager from @opentelemetry/sdk-trace-web
 * Using this rather than importing the entire package because this is all we need for now
 */

/**
 * UFO Context Manager for managing the state in web
 * it doesn't fully support the async calls though
 */
export var UFOContextManager = /*#__PURE__*/function () {
  function UFOContextManager() {
    _classCallCheck(this, UFOContextManager);
    /**
     * whether the context manager is enabled or not
     */
    _defineProperty(this, "_enabled", false);
    /**
     * Keeps the reference to current context
     */
    _defineProperty(this, "_currentContext", ROOT_CONTEXT);
  }
  return _createClass(UFOContextManager, [{
    key: "_bindFunction",
    value:
    /**
     *
     * @param context
     * @param target Function to be executed within the context
     */
    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
    function _bindFunction() {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ROOT_CONTEXT;
      var target = arguments.length > 1 ? arguments[1] : undefined;
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      var manager = this;
      var contextWrapper = function contextWrapper() {
        var _this = this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return manager.with(context, function () {
          return target.apply(_this, args);
        });
      };
      Object.defineProperty(contextWrapper, 'length', {
        enumerable: false,
        configurable: true,
        writable: false,
        value: target.length
      });
      return contextWrapper;
    }

    /**
     * Returns the active context
     */
  }, {
    key: "active",
    value: function active() {
      return this._currentContext;
    }

    /**
     * Binds a the certain context or the active one to the target function and then returns the target
     * @param context A context (span) to be bind to target
     * @param target a function or event emitter. When target or one of its callbacks is called,
     *  the provided context will be used as the active context for the duration of the call.
     */
  }, {
    key: "bind",
    value: function bind(context, target) {
      // if no specific context to propagate is given, we use the current one
      if (context === undefined) {
        context = this.active();
      }
      if (typeof target === 'function') {
        return this._bindFunction(context, target);
      }
      return target;
    }

    /**
     * Disable the context manager (clears the current context)
     */
  }, {
    key: "disable",
    value: function disable() {
      this._currentContext = ROOT_CONTEXT;
      this._enabled = false;
      return this;
    }

    /**
     * Enables the context manager and creates a default(root) context
     */
  }, {
    key: "enable",
    value: function enable() {
      if (this._enabled) {
        return this;
      }
      this._enabled = true;
      this._currentContext = ROOT_CONTEXT;
      return this;
    }

    /**
     * Calls the callback function [fn] with the provided [context]. If [context] is undefined then it will use the window.
     * The context will be set as active
     * @param context
     * @param fn Callback function
     * @param thisArg optional receiver to be used for calling fn
     * @param args optional arguments forwarded to fn
     */
  }, {
    key: "with",
    value: function _with(context, fn, thisArg) {
      var previousContext = this._currentContext;
      this._currentContext = context || ROOT_CONTEXT;
      try {
        for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
          args[_key2 - 3] = arguments[_key2];
        }
        return fn.call.apply(fn, [thisArg].concat(args));
      } finally {
        this._currentContext = previousContext;
      }
    }

    /**
     * Sets the active context.
     * This function is an extension of the OTel spec, in order to facilitate the current API of React UFO trace context handling.
     * It doesn't keep track of any previously set active contexts, because it's assumed (for now) that only one trace context
     * will ever exist at a time.
     * The next step in the work to improve tracing in the FE will likely remove this function as we need to track the 
     * hierarchy of contexts (likely using the `with()` function above).
     * @param context The context to be made the globally active one 
     */
  }, {
    key: "setActive",
    value: function setActive(context) {
      if (this._enabled) {
        this._currentContext = context;
      }
    }
  }]);
}();