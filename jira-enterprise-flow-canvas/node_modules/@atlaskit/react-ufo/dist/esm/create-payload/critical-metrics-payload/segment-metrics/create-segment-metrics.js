import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import _regeneratorRuntime from "@babel/runtime/regenerator";
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
import { getConfig } from '../../../config';
import getBrowserMetadata from '../../utils/get-browser-metadata';
import getPageVisibilityUpToTTAI from '../../utils/get-page-visibility-up-to-ttai';
import { LATEST_REACT_UFO_PAYLOAD_VERSION } from '../../utils/get-react-ufo-payload-version';
import getIsRootSegment from './get-is-root-segment';
import getSegmentId from './get-segment-id';
import getSegmentStatus from './get-segment-status';
export function createSegmentMetricsPayloads(_x, _x2) {
  return _createSegmentMetricsPayloads.apply(this, arguments);
}
function _createSegmentMetricsPayloads() {
  _createSegmentMetricsPayloads = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(interactionId, interaction) {
    var _interaction$cohortin;
    var config, browserMetadata, cohortingCustomData, pageVisibilityAtTTAI, knownSegments, reactProfilerTimings, rate, routeName, previousInteractionName, isPreviousInteractionAborted, abortedByInteractionName, segmentsByName, _iterator, _step, _loop, _ret, payloads, _iterator2, _step2, _loop2, _ret2;
    return _regeneratorRuntime.wrap(function _callee$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          config = getConfig();
          if (config) {
            _context3.next = 3;
            break;
          }
          throw Error('UFO Configuration not provided');
        case 3:
          // Get browser metadata (using compact nested format)
          browserMetadata = getBrowserMetadata(); // Process cohorting custom data
          cohortingCustomData = (_interaction$cohortin = interaction.cohortingCustomData) !== null && _interaction$cohortin !== void 0 && _interaction$cohortin.size ? Object.fromEntries(interaction.cohortingCustomData) : undefined;
          pageVisibilityAtTTAI = getPageVisibilityUpToTTAI(interaction);
          knownSegments = interaction.knownSegments, reactProfilerTimings = interaction.reactProfilerTimings, rate = interaction.rate, routeName = interaction.routeName, previousInteractionName = interaction.previousInteractionName, isPreviousInteractionAborted = interaction.isPreviousInteractionAborted, abortedByInteractionName = interaction.abortedByInteractionName; // Group segments by name and select the first segment for each name
          segmentsByName = new Map();
          _iterator = _createForOfIteratorHelper(knownSegments);
          _context3.prev = 9;
          _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {
            var segment, segmentId, name, isRootSegment, segmentProfilerTimings, firstMountTiming, firstMountTime, existingEntry;
            return _regeneratorRuntime.wrap(function _loop$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  segment = _step.value;
                  segmentId = getSegmentId(segment.labelStack); // skip if no segmentId
                  if (segmentId) {
                    _context.next = 4;
                    break;
                  }
                  return _context.abrupt("return", 0);
                case 4:
                  name = segment.labelStack[segment.labelStack.length - 1].name;
                  isRootSegment = getIsRootSegment(segment.labelStack);
                  segmentProfilerTimings = reactProfilerTimings.filter(function (timing) {
                    var timingSegmentId = getSegmentId(timing.labelStack);
                    // check if labelStack matches exactly
                    return timingSegmentId === segmentId;
                  }).sort(function (a, b) {
                    return a.startTime - b.startTime;
                  });
                  firstMountTiming = segmentProfilerTimings.find(function (timing) {
                    return timing.type === 'mount';
                  });
                  if (firstMountTiming) {
                    _context.next = 10;
                    break;
                  }
                  return _context.abrupt("return", 0);
                case 10:
                  firstMountTime = isRootSegment ? interaction.start : firstMountTiming.startTime; // Check if we already have a segment with this name
                  existingEntry = segmentsByName.get(name);
                  if (!existingEntry || firstMountTime < existingEntry.firstMountTime) {
                    // Either first time seeing this name, or this segment mounted earlier
                    segmentsByName.set(name, {
                      segment: segment,
                      firstMountTime: firstMountTime
                    });
                  }
                case 13:
                case "end":
                  return _context.stop();
              }
            }, _loop);
          });
          _iterator.s();
        case 12:
          if ((_step = _iterator.n()).done) {
            _context3.next = 19;
            break;
          }
          return _context3.delegateYield(_loop(), "t0", 14);
        case 14:
          _ret = _context3.t0;
          if (!(_ret === 0)) {
            _context3.next = 17;
            break;
          }
          return _context3.abrupt("continue", 17);
        case 17:
          _context3.next = 12;
          break;
        case 19:
          _context3.next = 24;
          break;
        case 21:
          _context3.prev = 21;
          _context3.t1 = _context3["catch"](9);
          _iterator.e(_context3.t1);
        case 24:
          _context3.prev = 24;
          _iterator.f();
          return _context3.finish(24);
        case 27:
          // Create payloads only for the selected segments (first one per name)
          payloads = [];
          _iterator2 = _createForOfIteratorHelper(segmentsByName.values());
          _context3.prev = 29;
          _loop2 = /*#__PURE__*/_regeneratorRuntime.mark(function _loop2() {
            var _window$location;
            var segment, segmentId, name, isRootSegment, segmentProfilerTimings, firstMountTiming, lastTiming, startTime, endTime, ttai, _getSegmentStatus, status, segmentAbortReason, properties, payload;
            return _regeneratorRuntime.wrap(function _loop2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  segment = _step2.value.segment;
                  segmentId = getSegmentId(segment.labelStack);
                  name = segment.labelStack[segment.labelStack.length - 1].name;
                  isRootSegment = getIsRootSegment(segment.labelStack);
                  segmentProfilerTimings = reactProfilerTimings.filter(function (timing) {
                    var timingSegmentId = getSegmentId(timing.labelStack);
                    // check if labelStack matches exactly
                    return timingSegmentId === segmentId;
                  }).sort(function (a, b) {
                    return a.startTime - b.startTime;
                  });
                  firstMountTiming = segmentProfilerTimings.find(function (timing) {
                    return timing.type === 'mount';
                  }); // We already checked this exists in the grouping phase
                  if (firstMountTiming) {
                    _context2.next = 8;
                    break;
                  }
                  return _context2.abrupt("return", 0);
                case 8:
                  lastTiming = segmentProfilerTimings[segmentProfilerTimings.length - 1];
                  startTime = isRootSegment ? interaction.start : firstMountTiming.startTime;
                  endTime = lastTiming.commitTime;
                  ttai = Math.round(endTime - startTime);
                  _getSegmentStatus = getSegmentStatus(interaction, segment), status = _getSegmentStatus.status, segmentAbortReason = _getSegmentStatus.abortReason;
                  if (!(status !== 'SUCCEEDED')) {
                    _context2.next = 15;
                    break;
                  }
                  return _context2.abrupt("return", 0);
                case 15:
                  properties = _objectSpread({
                    // Basic metadata
                    'event:hostname': ((_window$location = window.location) === null || _window$location === void 0 ? void 0 : _window$location.hostname) || 'unknown',
                    'event:product': config.product,
                    'event:schema': '1.0.0',
                    'event:region': config.region || 'unknown',
                    'event:source': {
                      name: 'react-ufo/web',
                      version: LATEST_REACT_UFO_PAYLOAD_VERSION
                    },
                    'experience:key': 'custom.ufo.critical-metrics',
                    'experience:name': name,
                    // Browser metadata (compact nested format)
                    browser: browserMetadata.browser,
                    device: browserMetadata.device,
                    network: browserMetadata.network,
                    time: browserMetadata.time,
                    metrics: {
                      ttai: ttai,
                      tti: ttai
                    },
                    interactionId: interactionId,
                    type: 'page_segment_load',
                    rate: rate,
                    routeName: routeName !== null && routeName !== void 0 ? routeName : undefined,
                    // Performance timings
                    start: Math.round(startTime),
                    end: Math.round(endTime),
                    // Status and outcome
                    status: status,
                    abortReason: segmentAbortReason,
                    previousInteractionName: previousInteractionName,
                    isPreviousInteractionAborted: isPreviousInteractionAborted,
                    abortedByInteractionName: abortedByInteractionName,
                    pageVisibilityAtTTAI: pageVisibilityAtTTAI,
                    // Basic error count (not detailed error count)
                    errorCount: interaction.errors.length
                  }, Object.keys(cohortingCustomData || {}).length > 0 && {
                    cohortingCustomData: cohortingCustomData
                  });
                  payload = {
                    actionSubject: 'experience',
                    action: 'measured',
                    eventType: 'operational',
                    source: 'measured',
                    tags: ['observability'],
                    attributes: {
                      properties: properties
                    }
                  };
                  payloads.push(payload);
                case 18:
                case "end":
                  return _context2.stop();
              }
            }, _loop2);
          });
          _iterator2.s();
        case 32:
          if ((_step2 = _iterator2.n()).done) {
            _context3.next = 39;
            break;
          }
          return _context3.delegateYield(_loop2(), "t2", 34);
        case 34:
          _ret2 = _context3.t2;
          if (!(_ret2 === 0)) {
            _context3.next = 37;
            break;
          }
          return _context3.abrupt("continue", 37);
        case 37:
          _context3.next = 32;
          break;
        case 39:
          _context3.next = 44;
          break;
        case 41:
          _context3.prev = 41;
          _context3.t3 = _context3["catch"](29);
          _iterator2.e(_context3.t3);
        case 44:
          _context3.prev = 44;
          _iterator2.f();
          return _context3.finish(44);
        case 47:
          return _context3.abrupt("return", payloads);
        case 48:
        case "end":
          return _context3.stop();
      }
    }, _callee, null, [[9, 21, 24, 27], [29, 41, 44, 47]]);
  }));
  return _createSegmentMetricsPayloads.apply(this, arguments);
}