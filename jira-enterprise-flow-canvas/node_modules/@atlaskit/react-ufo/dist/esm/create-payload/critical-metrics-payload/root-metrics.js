import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { getLighthouseMetrics } from '../../additional-payload';
import { getConfig } from '../../config';
import { getPageVisibilityState } from '../../hidden-timing';
import { sanitizeUfoName } from '../common/utils';
import getBrowserMetadata from '../utils/get-browser-metadata';
import { getFMP } from '../utils/get-fmp';
import getInteractionStatus from '../utils/get-interaction-status';
import getNavigationMetrics from '../utils/get-navigation-metrics';
import getPageVisibilityUpToTTAI from '../utils/get-page-visibility-up-to-ttai';
import getPaintMetrics from '../utils/get-paint-metrics';
import { LATEST_REACT_UFO_PAYLOAD_VERSION } from '../utils/get-react-ufo-payload-version';
import getSSRSuccess from '../utils/get-ssr-success';
import getTTAI from '../utils/get-ttai';
import { getTTI } from '../utils/get-tti';
import getVCMetrics from '../utils/get-vc-metrics';

// Re-export types for convenience

// Local utility functions
function getPageVisibilityUpToTTI(interaction) {
  var _interaction$apdex$0$, _interaction$apdex;
  var start = interaction.start;
  var bm3EndTimeOrInteractionEndTime = (_interaction$apdex$0$ = (_interaction$apdex = interaction.apdex) === null || _interaction$apdex === void 0 || (_interaction$apdex = _interaction$apdex[0]) === null || _interaction$apdex === void 0 ? void 0 : _interaction$apdex.stopTime) !== null && _interaction$apdex$0$ !== void 0 ? _interaction$apdex$0$ : interaction.end;
  return getPageVisibilityState(start, bm3EndTimeOrInteractionEndTime);
}

// TODO Write tests for this function
export function createRootCriticalMetricsPayload(_x, _x2, _x3) {
  return _createRootCriticalMetricsPayload.apply(this, arguments);
}
function _createRootCriticalMetricsPayload() {
  _createRootCriticalMetricsPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(interactionId, interaction, vcMetrics) {
    var _finalVCMetrics$ufoV, _interaction$cohortin, _window$location;
    var config, end, start, ufoName, rate, type, abortReason, routeName, previousInteractionName, isPreviousInteractionAborted, abortedByInteractionName, holdInfo, responsiveness, pageVisibilityAtTTI, pageVisibilityAtTTAI, interactionStatus, newUFOName, ttai, paintMetrics, navigationMetrics, ssrSuccess, tti, fmp, browserMetadata, lighthouseMetrics, finalVCMetrics, ttvc, earliestHold, cohortingCustomData, properties, payload;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          config = getConfig();
          if (config) {
            _context.next = 3;
            break;
          }
          throw Error('UFO Configuration not provided');
        case 3:
          end = interaction.end, start = interaction.start, ufoName = interaction.ufoName, rate = interaction.rate, type = interaction.type, abortReason = interaction.abortReason, routeName = interaction.routeName, previousInteractionName = interaction.previousInteractionName, isPreviousInteractionAborted = interaction.isPreviousInteractionAborted, abortedByInteractionName = interaction.abortedByInteractionName, holdInfo = interaction.holdInfo, responsiveness = interaction.responsiveness;
          pageVisibilityAtTTI = getPageVisibilityUpToTTI(interaction);
          pageVisibilityAtTTAI = getPageVisibilityUpToTTAI(interaction);
          interactionStatus = getInteractionStatus(interaction);
          if (!(interactionStatus.originalInteractionStatus !== 'SUCCEEDED')) {
            _context.next = 9;
            break;
          }
          return _context.abrupt("return", null);
        case 9:
          newUFOName = sanitizeUfoName(ufoName); // Get performance metrics
          ttai = getTTAI(interaction);
          _context.next = 13;
          return getPaintMetrics(type, end);
        case 13:
          paintMetrics = _context.sent;
          navigationMetrics = getNavigationMetrics(type);
          ssrSuccess = getSSRSuccess(type); // Calculate BM3 metrics (TTI and FMP) directly
          tti = getTTI(interaction, newUFOName);
          fmp = getFMP(interaction, newUFOName); // Get browser metadata (using compact nested format)
          browserMetadata = getBrowserMetadata();
          lighthouseMetrics = getLighthouseMetrics({
            start: start,
            stop: end
          }); // Use provided vcMetrics or calculate if not provided
          _context.t0 = vcMetrics;
          if (_context.t0) {
            _context.next = 25;
            break;
          }
          _context.next = 24;
          return getVCMetrics(interaction);
        case 24:
          _context.t0 = _context.sent;
        case 25:
          finalVCMetrics = _context.t0;
          ttvc = (_finalVCMetrics$ufoV = finalVCMetrics['ufo:vc:rev']) === null || _finalVCMetrics$ufoV === void 0 ? void 0 : _finalVCMetrics$ufoV.map(function (revision) {
            if (revision['metric:vc90'] === null || revision.clean !== true) {
              return null;
            }
            return {
              revision: revision.revision,
              vc90: revision['metric:vc90']
            };
          }).filter(function (revision) {
            return revision != null;
          }); // find earliest hold
          earliestHold = holdInfo === null || holdInfo === void 0 ? void 0 : holdInfo.reduce(function (a, b) {
            if (a && a.start < b.start) {
              return a;
            }
            return b;
          }, null); // Process cohorting custom data
          cohortingCustomData = (_interaction$cohortin = interaction.cohortingCustomData) !== null && _interaction$cohortin !== void 0 && _interaction$cohortin.size ? Object.fromEntries(interaction.cohortingCustomData) : undefined;
          properties = _objectSpread(_objectSpread({
            // Basic metadata
            'event:hostname': ((_window$location = window.location) === null || _window$location === void 0 ? void 0 : _window$location.hostname) || 'unknown',
            'event:product': config.product,
            'event:schema': '1.0.0',
            'event:region': config.region || 'unknown',
            'event:source': {
              name: 'react-ufo/web',
              version: LATEST_REACT_UFO_PAYLOAD_VERSION
            },
            'experience:key': 'custom.ufo.critical-metrics',
            'experience:name': newUFOName,
            // Browser metadata (compact nested format)
            browser: browserMetadata.browser,
            device: browserMetadata.device,
            network: browserMetadata.network,
            time: browserMetadata.time,
            metrics: _objectSpread({
              fp: paintMetrics.fp,
              fcp: paintMetrics.fcp,
              lcp: paintMetrics.lcp,
              ttai: ttai,
              tti: tti,
              fmp: fmp,
              tbt: lighthouseMetrics['metric:tbt'],
              tbtObserved: lighthouseMetrics['metric:tbt:observed'],
              cls: lighthouseMetrics['metric:cls'],
              ttvc: ttvc !== null && ttvc !== void 0 ? ttvc : undefined,
              earliestHoldStart: earliestHold !== null && earliestHold !== void 0 && earliestHold.start ? Math.round(earliestHold.start - start) : undefined,
              // for interaction response
              inputDelay: responsiveness !== null && responsiveness !== void 0 && responsiveness.inputDelay ? Math.round(responsiveness.inputDelay) : undefined,
              inp: responsiveness !== null && responsiveness !== void 0 && responsiveness.experimentalInputToNextPaint ? Math.round(responsiveness.experimentalInputToNextPaint) : undefined
            }, navigationMetrics && {
              navigation: navigationMetrics
            })
          }, ssrSuccess !== undefined && {
            ssrSuccess: ssrSuccess
          }), {}, {
            interactionId: interactionId,
            type: type,
            rate: rate,
            routeName: routeName !== null && routeName !== void 0 ? routeName : undefined,
            // Performance timings
            start: Math.round(start),
            end: Math.round(end),
            // Status and outcome
            status: interactionStatus.originalInteractionStatus,
            abortReason: abortReason,
            previousInteractionName: previousInteractionName,
            isPreviousInteractionAborted: isPreviousInteractionAborted,
            abortedByInteractionName: abortedByInteractionName,
            pageVisibilityAtTTI: pageVisibilityAtTTI !== null && pageVisibilityAtTTI !== void 0 ? pageVisibilityAtTTI : undefined,
            pageVisibilityAtTTAI: pageVisibilityAtTTAI,
            // Basic error count (not detailed error count)
            errorCount: interaction.errors.length
          }, Object.keys(cohortingCustomData || {}).length > 0 && {
            cohortingCustomData: cohortingCustomData
          });
          payload = {
            actionSubject: 'experience',
            action: 'measured',
            eventType: 'operational',
            source: 'measured',
            tags: ['observability'],
            attributes: {
              properties: properties
            }
          };
          return _context.abrupt("return", payload);
        case 32:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _createRootCriticalMetricsPayload.apply(this, arguments);
}