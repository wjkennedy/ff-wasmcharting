import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
// eslint-disable-next-line @atlaskit/platform/prefer-crypto-random-uuid -- Use crypto.randomUUID instead
import { v4 as createUUID } from 'uuid';
import { fg } from '@atlaskit/platform-feature-flags';
import coinflip from '../coinflip';
import { getAwaitBM3TTIList, getCapabilityRate, getConfig, getExperimentalInteractionRate, getExtraInteractionRate, getFinishInteractionOnTransition, getInteractionTimeout, getPostInteractionRate, getReactHydrationStats, shouldUseRawDataThirdPartyBehavior } from '../config';
import { experimentalVC, getExperimentalVCMetrics, onExperimentalInteractionComplete } from '../create-experimental-interaction-metrics-payload';
import { onSearchPageInteractionComplete } from '../create-extra-search-page-interaction-payload';
import { sanitizeUfoName, stringifyLabelStackFully } from '../create-payload/common/utils';
import { clearActiveTrace } from '../experience-trace-id-context';
import { allFeatureFlagsAccessed, currentFeatureFlagsAccessed } from '../feature-flags-accessed';
import { getInteractionId } from '../interaction-id-context';
import { flushSsrRenderProfilerTraces } from '../segment/ssr-render-profiler';
import { newVCObserver } from '../vc';
import { interactions } from './common/constants';
import InteractionExtraMetrics from './interaction-extra-metrics';
import PostInteractionLog from './post-interaction-log';
export var PreviousInteractionLog = {
  id: undefined,
  name: undefined,
  type: undefined,
  isAborted: undefined,
  timestamp: undefined
};
export var postInteractionLog = new PostInteractionLog();
export var interactionExtraMetrics = new InteractionExtraMetrics();
var interactionQueue = [];
var segmentCache = new Map();
export var segmentUnmountCache = new Map(); // Temporarily store segment unmount counts

var firstSegmentLoadMarked = false;
var segmentObservers = [];
export function getActiveInteraction() {
  var interactionId = getInteractionId();
  if (!interactionId.current) {
    return;
  }
  return interactions.get(interactionId.current);
}
function isPerformanceTracingEnabled() {
  var _getConfig;
  return ((_getConfig = getConfig()) === null || _getConfig === void 0 ? void 0 : _getConfig.enableAdditionalPerformanceMarks) || window.__REACT_UFO_ENABLE_PERF_TRACING || process.env.NODE_ENV !== 'production';
}
var performanceEventObserver;
export var getPerformanceObserver = function getPerformanceObserver() {
  performanceEventObserver = performanceEventObserver || new PerformanceObserver(function (entries) {
    var list = entries.getEntries();
    var _iterator = _createForOfIteratorHelper(list),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var entry = _step.value;
        if (entry.name === 'click') {
          setInteractionPerformanceEvent(entry);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  });
  return performanceEventObserver;
};
export var setInteractionPerformanceEvent = function setInteractionPerformanceEvent(entry) {
  var interaction = getActiveInteraction();
  if ((interaction === null || interaction === void 0 ? void 0 : interaction.type) === 'press') {
    var responsiveness = interaction.responsiveness || {};
    // if happens there is another event interaction that has started after
    // the initial one, we don't want to replace the values if they have already
    // been set up
    responsiveness.experimentalInputToNextPaint = responsiveness.experimentalInputToNextPaint || entry.duration;
    responsiveness.inputDelay = responsiveness.experimentalInputToNextPaint || entry.processingStart - entry.startTime;
    interaction.responsiveness = responsiveness;
    // if the entry start time is lower than the one in the interaction
    // it means the interaction start time is not accurate, we assign
    // this value which will match the timestamp in the event
    if (entry.startTime < interaction.start) {
      interaction.start = entry.startTime;
    }
  }
};
function labelStackToString(labelStack, name) {
  var _stack$map;
  var stack = _toConsumableArray(labelStack !== null && labelStack !== void 0 ? labelStack : []);
  if (name) {
    stack.push({
      name: name
    });
  }
  return (_stack$map = stack.map(function (l) {
    return l.name;
  })) === null || _stack$map === void 0 ? void 0 : _stack$map.join('/');
}
function labelStackToIdString(labelStack) {
  var _labelStack$map;
  return labelStack === null || labelStack === void 0 || (_labelStack$map = labelStack.map(function (l) {
    return 'segmentId' in l ? "".concat(l.name, ":").concat(l.segmentId) : "".concat(l.name);
  })) === null || _labelStack$map === void 0 ? void 0 : _labelStack$map.join('/');
}
function addSegmentObserver(observer) {
  segmentObservers.push(observer);
  var _iterator2 = _createForOfIteratorHelper(segmentCache.values()),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var segmentInfo = _step2.value;
      observer.onAdd(segmentInfo);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
}
function removeSegmentObserver(observer) {
  var index = segmentObservers.findIndex(function (obs) {
    return obs === observer;
  });
  if (index !== -1) {
    segmentObservers.splice(index, 1);
  }
}
export function remove(interactionId) {
  interactions.delete(interactionId);
}
export function updatePageLoadInteractionName(ufoName) {
  var routeName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ufoName;
  var interaction = getActiveInteraction();
  if (!interaction || interaction.type !== 'page_load' && interaction.type !== 'transition') {
    return;
  }
  interaction.ufoName = ufoName;
  interaction.routeName = routeName;
}
export function addMetadata(interactionId, data) {
  var interaction = interactions.get(interactionId);
  if (interaction != null) {
    Object.keys(data).forEach(function (key) {
      interaction.metaData[key] = data[key];
    });
  }
}
export function addCustomData(interactionId, labelStack, data) {
  var interaction = interactions.get(interactionId);
  if (interaction != null) {
    Object.keys(data).forEach(function (i) {
      interaction.customData.push({
        labelStack: labelStack,
        data: _defineProperty({}, i, data[i])
      });
    });
  }
}
export function addCohortingCustomData(interactionId, key, value) {
  var interaction = interactions.get(interactionId);
  if (interaction == null) {
    return;
  }

  // Allow null and undefined values
  if (value === null || value === undefined) {
    interaction.cohortingCustomData.set(key, value);
    return;
  }

  // Validate that the value is a primitive (number, boolean, or string)
  if (typeof value !== 'number' && typeof value !== 'boolean' && typeof value !== 'string') {
    return;
  }

  // Validate string length (max 50 characters)
  if (typeof value === 'string' && value.length > 50) {
    return;
  }
  interaction.cohortingCustomData.set(key, value);
}
export function addCustomTiming(interactionId, labelStack, data) {
  var interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.customTimings.push({
      labelStack: labelStack,
      data: data
    });
    if (isPerformanceTracingEnabled()) {
      for (var _i = 0, _Object$entries = Object.entries(data); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          timingData = _Object$entries$_i[1];
        var startTime = timingData.startTime,
          endTime = timingData.endTime;
        try {
          // for Firefox 102 and older
          performance.measure("\uD83D\uDEF8 ".concat(labelStackToString(labelStack, key), " [custom_timing]"), {
            start: startTime,
            end: endTime,
            detail: {
              devtools: {
                track: 'ðŸ›¸ reactUFO detailed timings',
                color: 'tertiary-light'
              }
            }
          });
        } catch (_unused) {
          // do nothing
        }
      }
    }
  }
}
export function addMark(interactionId, type, name, labelStack) {
  var time = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : performance.now();
  var interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.marks.push({
      type: type,
      name: name,
      labelStack: labelStack,
      time: time
    });
  }
  if (isPerformanceTracingEnabled()) {
    performance.mark("\uD83D\uDEF8 ".concat(labelStackToString(labelStack, name), " [").concat(type, "]"), {
      startTime: time
    });
  }
}
export function markFirstSegmentLoad(interactionId, labelStack) {
  var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : performance.now();
  if (!fg('platform_mark_ufo_segment_first_load')) {
    return;
  }
  var interaction = interactions.get(interactionId);
  if (interaction != null && !firstSegmentLoadMarked) {
    firstSegmentLoadMarked = true;
    interaction.marks.push({
      type: 'first_segment_load',
      name: 'first_segment_load',
      labelStack: labelStack,
      time: time
    });
  }
}
export function addMarkToAll(type, name, labelStack) {
  var time = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : performance.now();
  interactions.forEach(function (interaction) {
    interaction.marks.push({
      type: type,
      name: name,
      labelStack: labelStack,
      time: time
    });
  });
  if (isPerformanceTracingEnabled()) {
    performance.mark("\uD83D\uDEF8 ".concat(labelStackToString(labelStack, name), " [").concat(type, "]"), {
      startTime: time
    });
  }
}
export function addSpan(interactionId, type, name, labelStack, start) {
  var end = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : performance.now();
  var size = arguments.length > 6 ? arguments[6] : undefined;
  var interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.spans.push({
      type: type,
      name: name,
      labelStack: labelStack,
      start: start,
      end: end,
      size: size
    });
    if (isPerformanceTracingEnabled()) {
      try {
        // for Firefox 102 and older
        performance.measure("\uD83D\uDEF8 ".concat(labelStackToString(labelStack, name), " [").concat(type, "]"), {
          start: start,
          end: end,
          detail: {
            devtools: {
              track: 'ðŸ›¸ reactUFO detailed timings',
              color: 'secondary'
            }
          }
        });
      } catch (_unused2) {
        // do nothing
      }
    }
  }
}
export function addSpanToAll(type, name, labelStack, start) {
  var end = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : performance.now();
  var size = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
  interactions.forEach(function (interaction) {
    interaction.spans.push({
      type: type,
      name: name,
      labelStack: labelStack,
      start: start,
      end: end,
      size: size
    });
  });
  if (isPerformanceTracingEnabled()) {
    try {
      // for Firefox 102 and older
      performance.measure("\uD83D\uDEF8 ".concat(labelStackToString(labelStack, name), " [").concat(type, "]"), {
        start: start,
        end: end,
        detail: {
          devtools: {
            track: 'ðŸ›¸ reactUFO detailed timings',
            color: 'secondary'
          }
        }
      });
    } catch (_unused3) {
      // do nothing
    }
  }
}
export function addPreload(moduleId, timestamp) {
  addMarkToAll('bundle_preload', moduleId, null, timestamp);
}
export function addLoad(identifier, start, end) {
  addSpanToAll('bundle_load', identifier, null, start, end - start);
}
var moduleLoadingRequests = {};
export function extractModuleName(input) {
  var result = input !== null && input !== void 0 ? input : '';
  result = result.replace(/^\.\/src\/packages\//, '');
  result = result.replace(/^\.\/node_modules\//, '');
  result = result.replace(/(\/src)?\/(index|main)\.(tsx|ts|js|jsx)$/, '');
  return result;
}
function addHoldCriterion(id, labelStack, name, startTime) {
  var _window$__CRITERION__;
  if (!((_window$__CRITERION__ = window.__CRITERION__) !== null && _window$__CRITERION__ !== void 0 && _window$__CRITERION__.addUFOHold)) {
    return;
  }
  window.__CRITERION__.addUFOHold(id, labelStackToString(labelStack), name, startTime);
}
function removeHoldCriterion(id) {
  var _window$__CRITERION__2;
  if (!((_window$__CRITERION__2 = window.__CRITERION__) !== null && _window$__CRITERION__2 !== void 0 && _window$__CRITERION__2.removeUFOHold)) {
    return;
  }
  window.__CRITERION__.removeUFOHold(id);
}
export function addHold(interactionId, labelStack, name, experimental) {
  var interaction = interactions.get(interactionId);
  // eslint-disable-next-line @atlaskit/platform/prefer-crypto-random-uuid -- Use crypto.randomUUID instead
  var id = createUUID();
  if (!interaction && fg('platform_ufo_enable_late_holds_post_interaction')) {
    // add hold timestamp to post interaction log if interaction is complete
    postInteractionLog.addHoldInfo(labelStack, name, performance.now());
  }
  if (interaction != null) {
    var start = performance.now();
    var holdActive = {
      labelStack: labelStack,
      name: name,
      start: start
    };
    if (fg('platform_ufo_enable_ttai_with_3p')) {
      var is3pHold = labelStack.some(function (l) {
        return 'type' in l && l.type === 'third-party';
      });
      if (is3pHold) {
        if (!interaction.hold3pActive) {
          interaction.hold3pActive = new Map();
        }
        interaction.hold3pActive.set(id, _objectSpread(_objectSpread({}, holdActive), {}, {
          start: start
        }));
      } else {
        interaction.holdActive.set(id, _objectSpread(_objectSpread({}, holdActive), {}, {
          start: start
        }));
        addHoldCriterion(id, labelStack, name, start);
      }
    } else {
      var _getConfig2;
      if ((_getConfig2 = getConfig()) !== null && _getConfig2 !== void 0 && (_getConfig2 = _getConfig2.experimentalInteractionMetrics) !== null && _getConfig2 !== void 0 && _getConfig2.enabled && experimental) {
        interaction.holdExpActive.set(id, _objectSpread(_objectSpread({}, holdActive), {}, {
          start: start
        }));
      }
      if (!experimental) {
        interaction.holdActive.set(id, _objectSpread(_objectSpread({}, holdActive), {}, {
          start: start
        }));
      }
      addHoldCriterion(id, labelStack, name, start);
    }
    return function () {
      var end = performance.now();
      if (isPerformanceTracingEnabled()) {
        try {
          // for Firefox 102 and older
          performance.measure("\uD83D\uDEF8 ".concat(labelStackToString(labelStack, name), " [hold]"), {
            start: start,
            end: end,
            detail: {
              devtools: {
                track: 'ðŸ›¸ reactUFO detailed timings',
                color: 'secondary-light'
              }
            }
          });
        } catch (_unused4) {
          // do nothing
        }
      }
      removeHoldCriterion(id);
      var currentInteraction = interactions.get(interactionId);
      var currentHold = interaction.holdActive.get(id);
      var expHold = interaction.holdExpActive.get(id);
      if (currentInteraction != null) {
        if (currentHold != null) {
          currentInteraction.holdInfo.push(_objectSpread(_objectSpread({}, currentHold), {}, {
            end: end
          }));
          interaction.holdActive.delete(id);
        }
        if (expHold != null) {
          currentInteraction.holdExpInfo.push(_objectSpread(_objectSpread({}, expHold), {}, {
            end: end
          }));
          interaction.holdExpActive.delete(id);
        }
        if (fg('platform_ufo_enable_ttai_with_3p')) {
          if (interaction.hold3pActive) {
            var current3pHold = interaction.hold3pActive.get(id);
            if (current3pHold != null) {
              if (!currentInteraction.hold3pInfo) {
                currentInteraction.hold3pInfo = [];
              }
              currentInteraction.hold3pInfo.push(_objectSpread(_objectSpread({}, current3pHold), {}, {
                end: end
              }));
              interaction.hold3pActive.delete(id);
            }
          }
        }
      }
    };
  }
  return function () {};
}
export function addHoldByID(interactionId, labelStack, name, id, ignoreOnSubmit) {
  var interaction = interactions.get(interactionId);
  if (interaction != null) {
    var start = performance.now();
    if (fg('platform_ufo_enable_ttai_with_3p')) {
      var is3pHold = labelStack.some(function (l) {
        return 'type' in l && l.type === 'third-party';
      });
      if (is3pHold) {
        if (!interaction.hold3pActive) {
          interaction.hold3pActive = new Map();
        }
        interaction.hold3pActive.set(id, {
          labelStack: labelStack,
          name: name,
          start: start,
          ignoreOnSubmit: ignoreOnSubmit
        });
      } else {
        interaction.holdActive.set(id, {
          labelStack: labelStack,
          name: name,
          start: start,
          ignoreOnSubmit: ignoreOnSubmit
        });
        addHoldCriterion(id, labelStack, name, start);
      }
    } else {
      interaction.holdActive.set(id, {
        labelStack: labelStack,
        name: name,
        start: start,
        ignoreOnSubmit: ignoreOnSubmit
      });
      addHoldCriterion(id, labelStack, name, start);
    }
  }
  return function () {};
}
export function removeHoldByID(interactionId, id) {
  var interaction = interactions.get(interactionId);
  if (interaction != null) {
    var end = performance.now();
    var currentInteraction = interactions.get(interactionId);
    var currentHold = interaction.holdActive.get(id);
    if (currentInteraction != null && currentHold != null) {
      currentInteraction.holdInfo.push(_objectSpread(_objectSpread({}, currentHold), {}, {
        end: end
      }));
      interaction.holdActive.delete(id);
      removeHoldCriterion(id);
    }
    if (fg('platform_ufo_enable_ttai_with_3p')) {
      if (interaction.hold3pActive) {
        var current3pHold = interaction.hold3pActive.get(id);
        if (currentInteraction != null && current3pHold != null) {
          if (!currentInteraction.hold3pInfo) {
            currentInteraction.hold3pInfo = [];
          }
          currentInteraction.hold3pInfo.push(_objectSpread(_objectSpread({}, current3pHold), {}, {
            end: end
          }));
          interaction.hold3pActive.delete(id);
        }
      }
    }
  }
}
export function getCurrentInteractionType(interactionId) {
  var interaction = interactions.get(interactionId);
  if (interaction) {
    return interaction.type;
  }
  return null;
}
export var ModuleLoadingProfiler = {
  onPreload: function onPreload(moduleId, _priority) {
    addPreload(extractModuleName(moduleId), performance.now());
  },
  onLoadStart: function onLoadStart(info) {
    var timeoutId = setTimeout(function () {
      delete moduleLoadingRequests[info.identifier];
    }, 30000);
    var request = {
      start: performance.now(),
      timeoutId: timeoutId
    };
    moduleLoadingRequests[info.identifier] = request;
  },
  onLoadComplete: function onLoadComplete(info) {
    var request = moduleLoadingRequests[info.identifier];
    if (request) {
      clearTimeout(request.timeoutId);
      delete moduleLoadingRequests[info.identifier];
      addLoad(extractModuleName(info.identifier), request.start, performance.now());
    }
  },
  placeholderFallBackMounted: function placeholderFallBackMounted(id, moduleId) {
    var interactionId = getInteractionId();
    var currentInteractionId = interactionId.current;
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    addHoldByID(currentInteractionId, [], moduleId, id);
  },
  placeholderFallBackUnmounted: function placeholderFallBackUnmounted(id) {
    var interactionId = getInteractionId();
    var currentInteractionId = interactionId.current;
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    removeHoldByID(currentInteractionId, id);
  }
};
export function addError(interactionId, name, labelStack, errorType, errorMessage, errorStack, forcedError, errorHash, errorStatusCode) {
  var interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.errors.push({
      name: name,
      labelStack: labelStack,
      errorType: errorType,
      errorMessage: errorMessage,
      errorStack: errorStack,
      forcedError: forcedError,
      errorHash: errorHash,
      errorStatusCode: errorStatusCode
    });
  }
}
export function addErrorToAll(name, labelStack, errorType, errorMessage, errorStack, errorHash, errorStatusCode) {
  interactions.forEach(function (interaction) {
    interaction.errors.push({
      name: name,
      labelStack: labelStack,
      errorType: errorType,
      errorMessage: errorMessage,
      errorStack: errorStack,
      errorHash: errorHash,
      errorStatusCode: errorStatusCode
    });
  });
}
export function addProfilerTimings(interactionId, labelStack, type, actualDuration, baseDuration, startTime, commitTime) {
  var _getConfig3;
  if (isPerformanceTracingEnabled()) {
    try {
      // for Firefox 102 and older
      performance.measure("\uD83D\uDEF8 ".concat(labelStackToString(labelStack), " [react-profiler] ").concat(type), {
        start: startTime,
        duration: actualDuration,
        detail: {
          devtools: {
            track: 'ðŸ›¸ reactUFO detailed timings',
            color: 'secondary-dark'
          }
        }
      });
    } catch (_unused5) {
      // do nothing
    }
  }
  var interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.reactProfilerTimings.push({
      labelStack: labelStack,
      type: type,
      actualDuration: actualDuration,
      baseDuration: baseDuration,
      startTime: startTime,
      commitTime: commitTime
    });
  } else if ((_getConfig3 = getConfig()) !== null && _getConfig3 !== void 0 && (_getConfig3 = _getConfig3.postInteractionLog) !== null && _getConfig3 !== void 0 && _getConfig3.enabled) {
    postInteractionLog.addProfilerTimings(labelStack, type, actualDuration, baseDuration, startTime, commitTime);
  }
}
function pushToQueue(id, data) {
  interactionQueue.push({
    id: id,
    data: data
  });
}
var handleInteraction = pushToQueue;
function callCleanUpCallbacks(interaction) {
  interaction.cleanupCallbacks.reverse().forEach(function (cleanUpCallback) {
    cleanUpCallback();
  });
}
function finishInteraction(id, data) {
  var _getConfig4;
  var endTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : performance.now();
  data.end = endTime;
  try {
    // for Firefox 102 and older
    performance.measure("\uD83D\uDEF8 [".concat(data.type, "] ").concat(data.ufoName, " [ttai]"), {
      start: data.start,
      end: data.end,
      detail: {
        devtools: {
          track: 'main metrics',
          trackGroup: 'ðŸ›¸ reactUFO metrics',
          color: 'tertiary'
        }
      }
    });
    performance.mark("TTAI", {
      startTime: data.end,
      detail: {
        devtools: {
          dataType: 'marker'
        }
      }
    });
  } catch (_unused6) {
    // do nothing
  }
  if (data.featureFlags) {
    data.featureFlags.during = Object.fromEntries(currentFeatureFlagsAccessed);
  }
  clearActiveTrace();
  callCleanUpCallbacks(data);
  flushSsrRenderProfilerTraces();
  if ((_getConfig4 = getConfig()) !== null && _getConfig4 !== void 0 && (_getConfig4 = _getConfig4.vc) !== null && _getConfig4 !== void 0 && _getConfig4.stopVCAtInteractionFinish) {
    // Use per-interaction VC observer if available, otherwise fall back to global
    var observer = data.vcObserver;
    if (observer) {
      data.vc = observer.getVCRawData();
    }
  }
  if (data.type === 'page_load') {
    data.hydration = getReactHydrationStats();
  }

  // By this time, stop the post interaction log observer if coinflip rate is 0
  var sanitisedUfoName = sanitizeUfoName(data.ufoName);
  if (!coinflip(getPostInteractionRate(sanitisedUfoName, data.type))) {
    postInteractionLog.stopVCObserver();
  }
  if (fg('platform_ufo_enable_ttai_with_3p')) {
    var _sanitisedUfoName = sanitizeUfoName(data.ufoName);
    if (!coinflip(getExtraInteractionRate(_sanitisedUfoName, data.type))) {
      interactionExtraMetrics.stopAll(id);
    } else if (!data.hold3pActive || data.hold3pActive.size === 0) {
      var _getConfig5;
      if (!((_getConfig5 = getConfig()) !== null && _getConfig5 !== void 0 && (_getConfig5 = _getConfig5.experimentalInteractionMetrics) !== null && _getConfig5 !== void 0 && _getConfig5.enabled)) {
        remove(id);
      }
    }
  } else {
    var _getConfig6;
    if (!((_getConfig6 = getConfig()) !== null && _getConfig6 !== void 0 && (_getConfig6 = _getConfig6.experimentalInteractionMetrics) !== null && _getConfig6 !== void 0 && _getConfig6.enabled)) {
      remove(id);
    }
  }
  if (fg('platform_ufo_enable_terminal_errors')) {
    PreviousInteractionLog.id = data.id;
    PreviousInteractionLog.type = data.type;
    PreviousInteractionLog.timestamp = data.end;
  }
  PreviousInteractionLog.name = data.ufoName || 'unknown';
  PreviousInteractionLog.isAborted = data.abortReason != null;
  if (data.ufoName) {
    if (fg('platform_ufo_enable_ttai_with_3p')) {
      var _interactionExtraMetr;
      if (((_interactionExtraMetr = interactionExtraMetrics.finishedInteraction) === null || _interactionExtraMetr === void 0 ? void 0 : _interactionExtraMetr.id) !== id) {
        // If this same interaction was not already handled, handle it
        handleInteraction(id, data);
      }
    } else {
      handleInteraction(id, data);
    }
  }
  if (isPerformanceTracingEnabled()) {
    var profilerTimingMap = new Map();
    data.reactProfilerTimings.forEach(function (profilerTiming) {
      var labelStackId = labelStackToIdString(profilerTiming.labelStack);
      if (labelStackId) {
        var _profilerTimingMap$ge, _timing$start, _timing$end;
        var timing = (_profilerTimingMap$ge = profilerTimingMap.get(labelStackId)) !== null && _profilerTimingMap$ge !== void 0 ? _profilerTimingMap$ge : {
          labelStack: profilerTiming.labelStack
        };
        timing.start = profilerTiming.startTime < ((_timing$start = timing.start) !== null && _timing$start !== void 0 ? _timing$start : Number.MAX_SAFE_INTEGER) ? profilerTiming.startTime : timing.start;
        timing.end = profilerTiming.commitTime > ((_timing$end = timing.end) !== null && _timing$end !== void 0 ? _timing$end : Number.MIN_SAFE_INTEGER) ? profilerTiming.commitTime : timing.end;
        profilerTimingMap.set(labelStackId, timing);
      }
    });
    try {
      // for Firefox 102 and older
      var _iterator3 = _createForOfIteratorHelper(profilerTimingMap.entries()),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _step3$value = _slicedToArray(_step3.value, 2),
            _step3$value$ = _step3$value[1],
            labelStack = _step3$value$.labelStack,
            start = _step3$value$.start,
            end = _step3$value$.end;
          performance.measure("\uD83D\uDEF8 ".concat(labelStackToString(labelStack), " [segment_ttai]"), {
            start: start,
            end: end,
            detail: {
              devtools: {
                track: 'ðŸ›¸ reactUFO detailed timings',
                color: 'secondary-dark'
              }
            }
          });
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    } catch (_unused7) {
      // do nothing
    }
  }
  try {
    // dispatch a global window event to notify the measure is completed
    window.dispatchEvent(new CustomEvent('UFO_FINISH_INTERACTION', {
      detail: data
    }));
  } catch (_unused8) {
    // do nothing
  }
}
export function sinkInteractionHandler(sinkFn) {
  if (handleInteraction === pushToQueue) {
    handleInteraction = sinkFn;
    interactionQueue.forEach(function (interaction) {
      sinkFn(interaction.id, interaction.data);
    });
    interactionQueue.length = 0;
  }
}
export function sinkPostInteractionLogHandler(sinkFn) {
  postInteractionLog.sinkHandler(sinkFn);
}

// a flag to prevent multiple submitting
var activeSubmitted = false;
export function tryComplete(interactionId, endTime) {
  var interaction = interactions.get(interactionId);
  if (interaction != null) {
    var noMoreActiveHolds = interaction.holdActive.size === 0;
    var noMoreExpHolds = interaction.holdExpActive.size === 0;
    var shouldUseRawDataThirdParty = shouldUseRawDataThirdPartyBehavior(interaction.ufoName, interaction.type);
    var postInteraction = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _getConfig7;
        var _getConfig8, experimentalVC90, experimentalTTAI, _yield$getExperimenta, start, end, _interactionExtraMetr2, _getConfig9, _getConfig0;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!((_getConfig7 = getConfig()) !== null && _getConfig7 !== void 0 && (_getConfig7 = _getConfig7.postInteractionLog) !== null && _getConfig7 !== void 0 && _getConfig7.enabled)) {
                _context.next = 17;
                break;
              }
              if (!((_getConfig8 = getConfig()) !== null && _getConfig8 !== void 0 && (_getConfig8 = _getConfig8.experimentalInteractionMetrics) !== null && _getConfig8 !== void 0 && _getConfig8.enabled)) {
                _context.next = 16;
                break;
              }
              _context.next = 4;
              return getExperimentalVCMetrics(interaction);
            case 4:
              _context.t1 = _yield$getExperimenta = _context.sent;
              _context.t0 = _context.t1 === null;
              if (_context.t0) {
                _context.next = 8;
                break;
              }
              _context.t0 = _yield$getExperimenta === void 0;
            case 8:
              if (!_context.t0) {
                _context.next = 12;
                break;
              }
              _context.t2 = void 0;
              _context.next = 13;
              break;
            case 12:
              _context.t2 = _yield$getExperimenta['metric:experimental:vc90'];
            case 13:
              experimentalVC90 = _context.t2;
              start = interaction.start, end = interaction.end;
              experimentalTTAI = !interaction.abortReason ? Math.round(end - start) : undefined;
            case 16:
              postInteractionLog.onInteractionComplete(_objectSpread(_objectSpread({}, interaction), {}, {
                experimentalTTAI: experimentalTTAI,
                experimentalVC90: experimentalVC90
              }));
            case 17:
              if (fg('platform_ufo_enable_ttai_with_3p')) {
                if (((_interactionExtraMetr2 = interactionExtraMetrics.finishedInteraction) === null || _interactionExtraMetr2 === void 0 ? void 0 : _interactionExtraMetr2.id) !== interactionId) {
                  // If interactionExtraMetrics is not waiting for measuring this interaction
                  if ((_getConfig9 = getConfig()) !== null && _getConfig9 !== void 0 && (_getConfig9 = _getConfig9.experimentalInteractionMetrics) !== null && _getConfig9 !== void 0 && _getConfig9.enabled) {
                    remove(interactionId);
                  }
                }
              } else {
                if ((_getConfig0 = getConfig()) !== null && _getConfig0 !== void 0 && (_getConfig0 = _getConfig0.experimentalInteractionMetrics) !== null && _getConfig0 !== void 0 && _getConfig0.enabled) {
                  remove(interactionId);
                }
              }
              activeSubmitted = false;
            case 19:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function postInteraction() {
        return _ref.apply(this, arguments);
      };
    }();
    if (fg('platform_ufo_enable_ttai_with_3p')) {
      var _interaction$hold3pAc;
      var noMoreActive3pHolds = ((_interaction$hold3pAc = interaction.hold3pActive) === null || _interaction$hold3pAc === void 0 ? void 0 : _interaction$hold3pAc.size) === 0 || interaction.hold3pActive === undefined;

      // If using raw data third party behavior, wait for 3p holds to clear
      if (shouldUseRawDataThirdParty) {
        // If there are no non-3p holds active, mark the interaction as successful
        // but don't finish until 3p holds are cleared
        if (noMoreActiveHolds && !noMoreActive3pHolds) {
          // Mark interaction as successful by setting endTime, but don't finish yet
          if (endTime !== undefined && interaction.end === 0) {
            interaction.end = endTime;
          }
          // Wait for 3p holds to clear before finishing
          return;
        }

        // If all holds (including 3p) are cleared, finish the interaction
        if (noMoreActiveHolds && noMoreActive3pHolds) {
          if (!activeSubmitted) {
            var _getConfig1, _getConfig10, _getConfig11;
            // Set end3p to current time when 3p holds cleared, but ensure it's at least interaction.end
            var currentTime = endTime !== null && endTime !== void 0 ? endTime : performance.now();
            interaction.end3p = interaction.end !== 0 && currentTime < interaction.end ? interaction.end : currentTime;
            finishInteraction(interactionId, interaction, interaction.end !== 0 ? interaction.end : endTime);
            if ((_getConfig1 = getConfig()) !== null && _getConfig1 !== void 0 && (_getConfig1 = _getConfig1.extraInteractionMetrics) !== null && _getConfig1 !== void 0 && _getConfig1.enabled) {
              interactionExtraMetrics.updateFinishedInteraction(interaction);
            }
            if ((_getConfig10 = getConfig()) !== null && _getConfig10 !== void 0 && (_getConfig10 = _getConfig10.extraSearchPageInteraction) !== null && _getConfig10 !== void 0 && _getConfig10.enabled && interaction.ufoName === ((_getConfig11 = getConfig()) === null || _getConfig11 === void 0 || (_getConfig11 = _getConfig11.extraSearchPageInteraction) === null || _getConfig11 === void 0 ? void 0 : _getConfig11.searchPageMetricName)) {
              onSearchPageInteractionComplete(interactionId, interaction);
            }
            activeSubmitted = true;
          }
          if (noMoreExpHolds) {
            var _getConfig12;
            if ((_getConfig12 = getConfig()) !== null && _getConfig12 !== void 0 && (_getConfig12 = _getConfig12.experimentalInteractionMetrics) !== null && _getConfig12 !== void 0 && _getConfig12.enabled) {
              onExperimentalInteractionComplete(interactionId, interaction, endTime || interaction.end);
            }
            postInteraction();
          }
        }
        // Send separated third-party event even when feature flag is active
        if (noMoreActiveHolds && noMoreActive3pHolds) {
          var data = _objectSpread(_objectSpread({}, interaction), {}, {
            end: endTime || interaction.end
          });
          interactionExtraMetrics.onInteractionComplete(interactionId, data);
        }
      } else {
        var _interactionExtraMetr3;
        // Original behavior when feature flag is not active
        if (noMoreActiveHolds && ((_interactionExtraMetr3 = interactionExtraMetrics.finishedInteraction) === null || _interactionExtraMetr3 === void 0 ? void 0 : _interactionExtraMetr3.id) !== interactionId) {
          // If it's not waiting for extra metrics to complete, finish the interaction as normal
          if (!activeSubmitted) {
            var _getConfig13, _getConfig14, _getConfig15;
            finishInteraction(interactionId, interaction, endTime);
            if ((_getConfig13 = getConfig()) !== null && _getConfig13 !== void 0 && (_getConfig13 = _getConfig13.extraInteractionMetrics) !== null && _getConfig13 !== void 0 && _getConfig13.enabled) {
              interactionExtraMetrics.updateFinishedInteraction(interaction);
            }
            if ((_getConfig14 = getConfig()) !== null && _getConfig14 !== void 0 && (_getConfig14 = _getConfig14.extraSearchPageInteraction) !== null && _getConfig14 !== void 0 && _getConfig14.enabled && interaction.ufoName === ((_getConfig15 = getConfig()) === null || _getConfig15 === void 0 || (_getConfig15 = _getConfig15.extraSearchPageInteraction) === null || _getConfig15 === void 0 ? void 0 : _getConfig15.searchPageMetricName)) {
              onSearchPageInteractionComplete(interactionId, interaction);
            }
            activeSubmitted = true;
          }
          if (noMoreExpHolds) {
            var _getConfig16;
            if ((_getConfig16 = getConfig()) !== null && _getConfig16 !== void 0 && (_getConfig16 = _getConfig16.experimentalInteractionMetrics) !== null && _getConfig16 !== void 0 && _getConfig16.enabled) {
              onExperimentalInteractionComplete(interactionId, interaction, endTime);
            }
            postInteraction();
          }
        }
        if (noMoreActiveHolds && noMoreActive3pHolds) {
          var _data2 = _objectSpread(_objectSpread({}, interaction), {}, {
            end: endTime
          });
          interactionExtraMetrics.onInteractionComplete(interactionId, _data2);
        }
      }
    } else {
      if (noMoreActiveHolds) {
        if (!activeSubmitted) {
          var _getConfig17, _getConfig18;
          finishInteraction(interactionId, interaction, endTime);
          if ((_getConfig17 = getConfig()) !== null && _getConfig17 !== void 0 && (_getConfig17 = _getConfig17.extraSearchPageInteraction) !== null && _getConfig17 !== void 0 && _getConfig17.enabled && interaction.ufoName === ((_getConfig18 = getConfig()) === null || _getConfig18 === void 0 || (_getConfig18 = _getConfig18.extraSearchPageInteraction) === null || _getConfig18 === void 0 ? void 0 : _getConfig18.searchPageMetricName)) {
            onSearchPageInteractionComplete(interactionId, interaction);
          }
          activeSubmitted = true;
        }
        if (noMoreExpHolds) {
          var _getConfig19;
          if ((_getConfig19 = getConfig()) !== null && _getConfig19 !== void 0 && (_getConfig19 = _getConfig19.experimentalInteractionMetrics) !== null && _getConfig19 !== void 0 && _getConfig19.enabled) {
            onExperimentalInteractionComplete(interactionId, interaction, endTime);
          }
          postInteraction();
        }
      }
    }
  }
}
function callCancelCallbacks(interaction) {
  interaction.cancelCallbacks.reverse().forEach(function (cancelCallback) {
    cancelCallback();
  });
}
export function abort(interactionId, abortReason) {
  var interaction = interactions.get(interactionId);
  if (interaction != null) {
    var shouldUseRawDataThirdParty = shouldUseRawDataThirdPartyBehavior(interaction.ufoName, interaction.type);
    var noMoreActiveHolds = interaction.holdActive.size === 0;
    var has3pHoldsActive = interaction.hold3pActive && interaction.hold3pActive.size > 0;

    // If only third-party holds are active, finish as successful instead of aborting
    if (shouldUseRawDataThirdParty && noMoreActiveHolds && has3pHoldsActive) {
      var endTime = interaction.end !== 0 ? interaction.end : performance.now();
      interaction.end3p = performance.now();
      finishInteraction(interactionId, interaction, endTime);
      postInteractionLog.reset();
      postInteractionLog.stopVCObserver();
      if (fg('platform_ufo_enable_ttai_with_3p')) {
        interactionExtraMetrics.stopAll(interactionId);
      }
      if (coinflip(getExperimentalInteractionRate(interaction.ufoName, interaction.type))) {
        onExperimentalInteractionComplete(interactionId, interaction, endTime);
        remove(interactionId);
      }
      return;
    }
    callCancelCallbacks(interaction);
    interaction.abortReason = abortReason;
    finishInteraction(interactionId, interaction);
    postInteractionLog.reset();
    postInteractionLog.stopVCObserver();
    if (fg('platform_ufo_enable_ttai_with_3p')) {
      interactionExtraMetrics.stopAll(interactionId);
    }
    if (coinflip(getExperimentalInteractionRate(interaction.ufoName, interaction.type))) {
      onExperimentalInteractionComplete(interactionId, interaction);
      remove(interactionId);
    }
  }
}
export function abortByNewInteraction(interactionId, interactionName) {
  var interaction = interactions.get(interactionId);
  if (interaction != null) {
    var shouldUseRawDataThirdParty = shouldUseRawDataThirdPartyBehavior(interaction.ufoName, interaction.type);
    var noMoreActiveHolds = interaction.holdActive.size === 0;
    var has3pHoldsActive = interaction.hold3pActive && interaction.hold3pActive.size > 0;

    // If only third-party holds are active, finish as successful instead of aborting
    if (shouldUseRawDataThirdParty && noMoreActiveHolds && has3pHoldsActive) {
      var endTime = interaction.end !== 0 ? interaction.end : performance.now();
      // Set end3p to current time, but ensure it's at least interaction.end
      interaction.end3p = performance.now();
      finishInteraction(interactionId, interaction, endTime);
      postInteractionLog.reset();
      postInteractionLog.stopVCObserver();
      if (fg('platform_ufo_enable_ttai_with_3p')) {
        interactionExtraMetrics.stopAll(interactionId);
      }
      if (coinflip(getExperimentalInteractionRate(interaction.ufoName, interaction.type))) {
        onExperimentalInteractionComplete(interactionId, interaction, endTime);
        remove(interactionId);
      }
      return;
    }
    callCancelCallbacks(interaction);
    interaction.abortReason = 'new_interaction';
    interaction.abortedByInteractionName = interactionName;
    finishInteraction(interactionId, interaction);
    postInteractionLog.reset();
    postInteractionLog.stopVCObserver();
    if (fg('platform_ufo_enable_ttai_with_3p')) {
      interactionExtraMetrics.stopAll(interactionId);
    }
    if (coinflip(getExperimentalInteractionRate(interaction.ufoName, interaction.type))) {
      onExperimentalInteractionComplete(interactionId, interaction);
      remove(interactionId);
    }
  } else {
    if (fg('platform_reset_post_interaction_on_new_interaction')) {
      // post-interaction log is active after interaction is aborted by new one
      postInteractionLog.reset();
      postInteractionLog.stopVCObserver();
    }
  }
}
export function abortAll(abortReason, abortedByInteractionName) {
  var activeInteraction = getActiveInteraction();
  var finishInteractions = getFinishInteractionOnTransition();
  interactions.forEach(function (interaction, interactionId) {
    var isActiveInteraction = activeInteraction === interaction;
    var hasFinished = interaction.holdActive.size === 0;
    if (isActiveInteraction && abortReason === 'transition' && interaction.type === 'press' && finishInteractions !== null && finishInteractions !== void 0 && finishInteractions.includes(interaction.ufoName) && fg('platform_ufo_enable_finish_interaction_transition')) {
      hasFinished = true;
    }
    var shouldUseRawDataThirdParty = shouldUseRawDataThirdPartyBehavior(interaction.ufoName, interaction.type);
    var noMoreActiveHolds = interaction.holdActive.size === 0;
    var has3pHoldsActive = interaction.hold3pActive && interaction.hold3pActive.size > 0;

    // If only third-party holds are active, finish as successful instead of aborting
    if (shouldUseRawDataThirdParty && noMoreActiveHolds && has3pHoldsActive) {
      var endTime = interaction.end !== 0 ? interaction.end : performance.now();
      interaction.end3p = performance.now();
      finishInteraction(interactionId, interaction, endTime);
      postInteractionLog.reset();
      postInteractionLog.stopVCObserver();
      if (fg('platform_ufo_enable_ttai_with_3p')) {
        interactionExtraMetrics.stopAll(interactionId);
      }
      if (coinflip(getExperimentalInteractionRate(interaction.ufoName, interaction.type))) {
        onExperimentalInteractionComplete(interactionId, interaction, endTime);
        remove(interactionId);
      }
      return;
    }
    if (!hasFinished) {
      callCancelCallbacks(interaction);
      interaction.abortReason = abortReason;
      if (abortedByInteractionName != null) {
        interaction.abortedByInteractionName = abortedByInteractionName;
      }
    }
    finishInteraction(interactionId, interaction);
    postInteractionLog.reset();
    postInteractionLog.stopVCObserver();
    if (fg('platform_ufo_enable_ttai_with_3p')) {
      interactionExtraMetrics.stopAll(interactionId);
    }
    if (coinflip(getExperimentalInteractionRate(interaction.ufoName, interaction.type))) {
      onExperimentalInteractionComplete(interactionId, interaction);
      remove(interactionId);
    }
  });
}
export function addOnCancelCallback(id, cancelCallback) {
  var interaction = interactions.get(id);
  interaction === null || interaction === void 0 || interaction.cancelCallbacks.push(cancelCallback);
}
export function addNewInteraction(interactionId, ufoName, type, startTime, rate, labelStack, routeName) {
  var _config$extraSearchPa, _config$extraSearchPa2;
  var trace = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
  interactionExtraMetrics.reset();
  postInteractionLog.reset();
  var vcObserver;
  var previousTime = startTime;
  var timeoutTime = getInteractionTimeout(ufoName);
  var timerID = setTimeout(function () {
    abort(interactionId, 'timeout');
  }, timeoutTime);
  function changeTimeout(newTime) {
    // we compare if the time left is lower than the new time to no
    // extend the timeout beyond the initial waiting time
    var currentTime = performance.now();
    var timeLeft = timeoutTime - (currentTime - previousTime);
    if (timeLeft < newTime) {
      return;
    }
    clearTimeout(this.timerID);
    var newTimerID = setTimeout(function () {
      abort(interactionId, 'timeout');
    }, newTime);
    timeoutTime = newTime;
    previousTime = currentTime;
    this.timerID = newTimerID;
  }
  var addFeatureFlagsToInteraction = coinflip(getCapabilityRate('feature_flag_access'));
  var config = getConfig();
  var searchPageConfig = fg('rovo_search_page_ttvc_ignoring_smart_answers_fix') ? {
    enableSmartAnswersMutations: config === null || config === void 0 || (_config$extraSearchPa = config.extraSearchPageInteraction) === null || _config$extraSearchPa === void 0 ? void 0 : _config$extraSearchPa.enabled,
    searchPageRoute: config === null || config === void 0 || (_config$extraSearchPa2 = config.extraSearchPageInteraction) === null || _config$extraSearchPa2 === void 0 ? void 0 : _config$extraSearchPa2.searchPageRoute
  } : undefined;
  if (config && config.vc) {
    var vcOptions = {
      heatmapSize: config.vc.heatmapSize,
      oldDomUpdates: config.vc.oldDomUpdates,
      devToolsEnabled: config.vc.devToolsEnabled,
      selectorConfig: config.vc.selectorConfig,
      ssrEnablePageLayoutPlaceholder: config.vc.ssrEnablePageLayoutPlaceholder,
      searchPageConfig: searchPageConfig
    };
    vcObserver = newVCObserver(vcOptions);
  }
  var priorAccessedFg = type === 'press' && fg('platform_ufo_drop_prior_fg_interactions') ? {} : Object.fromEntries(allFeatureFlagsAccessed);
  var metrics = {
    id: interactionId,
    start: startTime,
    end: 0,
    ufoName: ufoName,
    type: type,
    previousInteractionName: PreviousInteractionLog.name,
    isPreviousInteractionAborted: PreviousInteractionLog.isAborted === true,
    marks: [],
    customData: [],
    cohortingCustomData: new Map(),
    customTimings: [],
    spans: [],
    requestInfo: [],
    reactProfilerTimings: [],
    holdInfo: [],
    holdExpInfo: [],
    holdActive: new Map(),
    holdExpActive: new Map(),
    // measure when we execute this code
    // from this, we can measure the input delay -
    // how long the browser took to hand execution back to JS)
    measureStart: performance.now(),
    rate: rate,
    cancelCallbacks: [],
    metaData: {},
    errors: [],
    apdex: [],
    labelStack: labelStack,
    routeName: routeName !== null && routeName !== void 0 ? routeName : ufoName,
    featureFlags: addFeatureFlagsToInteraction ? {
      prior: priorAccessedFg,
      during: {}
    } : undefined,
    knownSegments: [],
    cleanupCallbacks: [],
    awaitReactProfilerCount: 0,
    redirects: [],
    timerID: timerID,
    changeTimeout: changeTimeout,
    trace: trace,
    vcObserver: vcObserver,
    hold3pActive: new Map(),
    hold3pInfo: [],
    minorInteractions: []
  };
  if (addFeatureFlagsToInteraction) {
    currentFeatureFlagsAccessed.clear();
  }
  interactions.set(interactionId, metrics);
  var segmentObserver = {
    onAdd: function onAdd(segment) {
      metrics.knownSegments.push(segment);
    },
    onRemove: function onRemove() {}
  };
  addSegmentObserver(segmentObserver);
  metrics.cleanupCallbacks.push(function () {
    removeSegmentObserver(segmentObserver);
  });
  metrics.cleanupCallbacks.push(function () {
    clearTimeout(metrics.timerID);
  });
  // Add cleanup for per-interaction VC observer
  if (vcObserver) {
    metrics.cleanupCallbacks.push(function () {
      vcObserver.stop(ufoName);
    });
  }
  var awaitBM3TTIList = getAwaitBM3TTIList();
  if (awaitBM3TTIList.includes(ufoName)) {
    addHoldByID(interactionId, [], ufoName, ufoName, true);
  }
  if (type === 'transition' || type === 'page_load') {
    var _getConfig20, _config$extraInteract;
    // Use per-interaction VC observer if available, otherwise fall back to global
    var observer = vcObserver;
    if (observer) {
      observer.start({
        startTime: startTime,
        experienceKey: ufoName
      });
    }
    // Start post interaction observer for all if config is enabled
    // in case ufoName is updated at later time
    if ((_getConfig20 = getConfig()) !== null && _getConfig20 !== void 0 && (_getConfig20 = _getConfig20.postInteractionLog) !== null && _getConfig20 !== void 0 && _getConfig20.enabled) {
      postInteractionLog.startVCObserver({
        startTime: startTime
      });
    }
    if (coinflip(getExperimentalInteractionRate(ufoName, type))) {
      experimentalVC.start({
        startTime: startTime
      });
    }
    if (config !== null && config !== void 0 && (_config$extraInteract = config.extraInteractionMetrics) !== null && _config$extraInteract !== void 0 && _config$extraInteract.enabled && fg('platform_ufo_enable_ttai_with_3p')) {
      interactionExtraMetrics.startVCObserver({
        startTime: startTime
      }, interactionId);
    }
  }
  if (type === 'press') {
    // Use per-interaction VC observer if available, otherwise fall back to global
    var _observer = vcObserver;
    if (_observer) {
      _observer.start({
        startTime: startTime,
        experienceKey: ufoName
      });
    }
  }
}
export function addBrowserMetricEvent(event) {
  var interaction = getActiveInteraction();
  if (interaction) {
    var _event$config;
    interaction.legacyMetrics = interaction.legacyMetrics || [];
    interaction.legacyMetrics.push(event);
    if ((interaction.type === 'page_load' || interaction.type === 'transition') && ((_event$config = event.config) === null || _event$config === void 0 ? void 0 : _event$config.type) === 'PAGE_LOAD') {
      removeHoldByID(interaction.id, interaction.ufoName);
    }
  }
}
export function addApdexToAll(apdex) {
  interactions.forEach(function (interaction, key) {
    interaction.apdex.push(apdex);
    try {
      var _apdex$startTime;
      // for Firefox 102 and older
      performance.measure("\uD83D\uDEF8 ".concat(apdex.key, " [bm3_tti]"), {
        start: (_apdex$startTime = apdex.startTime) !== null && _apdex$startTime !== void 0 ? _apdex$startTime : interaction.start,
        end: apdex.stopTime,
        detail: {
          devtools: {
            track: 'main metrics',
            trackGroup: 'ðŸ›¸ reactUFO metrics',
            color: 'primary-dark'
          }
        }
      });
      performance.mark("[bm3] TTI", {
        startTime: apdex.stopTime,
        detail: {
          devtools: {
            dataType: 'marker'
          }
        }
      });
    } catch (_unused9) {
      // do nothing
    }
    if (interaction.type === 'page_load' || interaction.type === 'transition') {
      removeHoldByID(key, interaction.ufoName);
    }
  });
}
export function addApdex(interactionId, apdexInfo) {
  var interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.apdex.push(apdexInfo);
    try {
      var _apdexInfo$startTime;
      // for Firefox 102 and older
      performance.measure("\uD83D\uDEF8 ".concat(apdexInfo.key, " [bm3_tti]"), {
        start: (_apdexInfo$startTime = apdexInfo.startTime) !== null && _apdexInfo$startTime !== void 0 ? _apdexInfo$startTime : interaction.start,
        end: apdexInfo.stopTime,
        detail: {
          devtools: {
            track: 'main metrics',
            trackGroup: 'ðŸ›¸ reactUFO metrics',
            color: 'primary-dark'
          }
        }
      });
      performance.mark("[bm3] TTI", {
        startTime: apdexInfo.stopTime,
        detail: {
          devtools: {
            dataType: 'marker'
          }
        }
      });
    } catch (_unused0) {
      // do nothing
    }
    if (interaction.type === 'page_load' || interaction.type === 'transition') {
      removeHoldByID(interactionId, interaction.ufoName);
    }
  }
}
export function addRequestInfo(interactionId, labelStack, requestInfo) {
  var interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.requestInfo.push(_objectSpread({
      labelStack: labelStack
    }, requestInfo));
  }
}
function isSegmentLabel(obj) {
  return obj && typeof obj.name === 'string' && typeof obj.segmentId === 'string';
}
function getSegmentCacheKey(labelStack) {
  return labelStack.map(function (l) {
    if (isSegmentLabel(l)) {
      return "".concat(l.name, "_").concat(l.segmentId);
    }
    return l.name;
  }).join('|');
}
export function addSegment(labelStack) {
  var key = getSegmentCacheKey(labelStack);
  var existingSegment = segmentCache.get(key);
  if (!existingSegment) {
    var segmentInfo = {
      labelStack: labelStack
    };
    segmentCache.set(key, segmentInfo);
    segmentObservers.forEach(function (observer) {
      observer.onAdd(segmentInfo);
    });
  }
}
export function removeSegment(labelStack) {
  var key = getSegmentCacheKey(labelStack);
  var segmentInfo = segmentCache.get(key);
  if (segmentInfo) {
    segmentCache.delete(JSON.stringify(labelStack));
    if (fg('platform_ufo_segment_unmount_count')) {
      var cacheKey = stringifyLabelStackFully(labelStack);
      segmentUnmountCache.set(cacheKey, (segmentUnmountCache.get(cacheKey) || 0) + 1);
    }
    segmentObservers.forEach(function (observer) {
      observer.onRemove(segmentInfo);
    });
  }
}
export function addRedirect(interactionId, fromUfoName, nextUfoName, nextRouteName, time) {
  var interaction = interactions.get(interactionId);
  if (interaction != null) {
    interaction.ufoName = nextUfoName;
    interaction.routeName = nextRouteName;
    interaction.redirects.push({
      fromInteractionName: fromUfoName,
      time: time
    });
    if (isPerformanceTracingEnabled()) {
      var prevRedirect = interaction.redirects.at(-2);
      try {
        var _prevRedirect$time;
        // for Firefox 102 and older
        performance.measure("\uD83D\uDEF8 ".concat(nextUfoName, " [redirect]"), {
          start: (_prevRedirect$time = prevRedirect === null || prevRedirect === void 0 ? void 0 : prevRedirect.time) !== null && _prevRedirect$time !== void 0 ? _prevRedirect$time : interaction.start,
          end: time,
          detail: {
            devtools: {
              track: 'ðŸ›¸ reactUFO detailed timings',
              color: 'tertiary'
            }
          }
        });
      } catch (_unused1) {
        // do nothing
      }
    }
  }
}
export var interactionSpans = [];
var defaultLabelStack = [{
  name: 'custom'
}];
export function addCustomSpans(name, start) {
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : performance.now();
  var size = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var labelStack = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : defaultLabelStack;
  var customSpan = {
    type: 'custom',
    name: name,
    start: start,
    end: end,
    labelStack: labelStack,
    size: size
  };
  interactionSpans.push(customSpan);
}