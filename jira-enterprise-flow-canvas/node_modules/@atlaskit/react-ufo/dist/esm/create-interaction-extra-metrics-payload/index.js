import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
var _excluded = ["labelStack"];
import _regeneratorRuntime from "@babel/runtime/regenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { fg } from '@atlaskit/platform-feature-flags';
import coinflip from '../coinflip';
import { DEFAULT_TTVC_REVISION, getConfig, getExtraInteractionRate } from '../config';
import { buildSegmentTree, getOldSegmentsLabelStack, optimizeLabelStack, sanitizeUfoName } from '../create-payload/common/utils';
import { getMoreAccuratePageVisibilityUpToTTAI } from '../create-payload/utils/get-more-accurate-page-visibility-up-to-ttai';
import getPageVisibilityUpToTTAI from '../create-payload/utils/get-page-visibility-up-to-ttai';
import getPayloadSize from '../create-payload/utils/get-payload-size';
import { getReactUFOPayloadVersion } from '../create-payload/utils/get-react-ufo-payload-version';
import getTTAI from '../create-payload/utils/get-ttai';
import getVCMetrics from '../create-payload/utils/get-vc-metrics';
import { optimizeApdex } from '../create-payload/utils/optimize-apdex';
import { optimizeCustomTimings } from '../create-payload/utils/optimize-custom-timings';
import { optimizeHoldInfo } from '../create-payload/utils/optimize-hold-info';
import { optimizeMarks } from '../create-payload/utils/optimize-marks';
import { optimizeReactProfilerTimings } from '../create-payload/utils/optimize-react-profiler-timings';
import { optimizeRequestInfo } from '../create-payload/utils/optimize-request-info';
import { optimizeSpans } from '../create-payload/utils/optimize-spans';
import { interactionSpans as atlaskitInteractionSpans } from '../interaction-metrics';
function createInteractionExtraLogPayload(_x, _x2, _x3, _x4) {
  return _createInteractionExtraLogPayload.apply(this, arguments);
}
function _createInteractionExtraLogPayload() {
  _createInteractionExtraLogPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(interactionId, interaction, lastInteractionFinish, lastInteractionFinishVCResult) {
    var _getTTAI, _lastInteractionFinis, _getTTAI2, _window$location;
    var config, end, start, ufoName, rate, type, abortReason, routeName, previousInteractionName, isPreviousInteractionAborted, abortedByInteractionName, knownSegments, minorInteractions, sanitisedUfoName, configRate, pageVisibilityAtTTAI, isPageLoad, calculatePageVisibilityFromTheStartOfPageLoad, moreAccuratePageVisibilityAtTTAI, extraTTAI, newUFOName, finalVCMetrics, vcRevisionPayload, effectiveVCRevisionPayload, normalTTAI, lastInteractionFinishStart, lastInteractionFinishEnd, lastInteractionFinishVC90, lastInteractionFinishVCClean, lastInteractionFinishVCRev, lastInteractionFinishRevision, isThirdParty, filteredData, getDetailedInteractionMetrics, segments3p, segmentTree, payload;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          config = getConfig();
          if (config) {
            _context.next = 3;
            break;
          }
          throw Error('UFO Configuration not provided');
        case 3:
          end = interaction.end, start = interaction.start, ufoName = interaction.ufoName, rate = interaction.rate, type = interaction.type, abortReason = interaction.abortReason, routeName = interaction.routeName, previousInteractionName = interaction.previousInteractionName, isPreviousInteractionAborted = interaction.isPreviousInteractionAborted, abortedByInteractionName = interaction.abortedByInteractionName, knownSegments = interaction.knownSegments, minorInteractions = interaction.minorInteractions;
          sanitisedUfoName = sanitizeUfoName(ufoName);
          configRate = getExtraInteractionRate(sanitisedUfoName, type);
          if (coinflip(configRate)) {
            _context.next = 8;
            break;
          }
          return _context.abrupt("return", null);
        case 8:
          pageVisibilityAtTTAI = getPageVisibilityUpToTTAI(interaction);
          isPageLoad = type === 'page_load' || type === 'transition';
          if (!(!isPageLoad || minorInteractions !== undefined && minorInteractions.length > 0)) {
            _context.next = 12;
            break;
          }
          return _context.abrupt("return", null);
        case 12:
          calculatePageVisibilityFromTheStartOfPageLoad = config.enableBetterPageVisibilityApi && isPageLoad;
          moreAccuratePageVisibilityAtTTAI = calculatePageVisibilityFromTheStartOfPageLoad ? getMoreAccuratePageVisibilityUpToTTAI(interaction) : null;
          extraTTAI = (_getTTAI = getTTAI(interaction)) !== null && _getTTAI !== void 0 ? _getTTAI : undefined;
          newUFOName = sanitizeUfoName(ufoName);
          _context.next = 18;
          return getVCMetrics(interaction, true);
        case 18:
          finalVCMetrics = _context.sent;
          // Check if VC is clean and has valid metric
          vcRevisionPayload = finalVCMetrics === null || finalVCMetrics === void 0 ? void 0 : finalVCMetrics['ufo:vc:rev'];
          effectiveVCRevisionPayload = vcRevisionPayload === null || vcRevisionPayload === void 0 ? void 0 : vcRevisionPayload.find(function (_ref) {
            var revision = _ref.revision;
            return revision === DEFAULT_TTVC_REVISION;
          });
          if (!(!(effectiveVCRevisionPayload !== null && effectiveVCRevisionPayload !== void 0 && effectiveVCRevisionPayload.clean) || (effectiveVCRevisionPayload === null || effectiveVCRevisionPayload === void 0 ? void 0 : effectiveVCRevisionPayload['metric:vc90']) === undefined || typeof (effectiveVCRevisionPayload === null || effectiveVCRevisionPayload === void 0 ? void 0 : effectiveVCRevisionPayload['metric:vc90']) !== 'number' || extraTTAI === undefined || typeof extraTTAI !== 'number' || interaction.errors.length > 0)) {
            _context.next = 23;
            break;
          }
          return _context.abrupt("return", null);
        case 23:
          if (!(!lastInteractionFinish || lastInteractionFinish !== null && lastInteractionFinish !== void 0 && lastInteractionFinish.abortReason || lastInteractionFinish !== null && lastInteractionFinish !== void 0 && (_lastInteractionFinis = lastInteractionFinish.errors) !== null && _lastInteractionFinis !== void 0 && _lastInteractionFinis.length)) {
            _context.next = 25;
            break;
          }
          return _context.abrupt("return", null);
        case 25:
          normalTTAI = (_getTTAI2 = getTTAI(lastInteractionFinish)) !== null && _getTTAI2 !== void 0 ? _getTTAI2 : undefined;
          lastInteractionFinishStart = typeof lastInteractionFinish.start === 'number' ? Math.round(lastInteractionFinish.start) : undefined;
          lastInteractionFinishEnd = typeof lastInteractionFinish.end === 'number' ? Math.round(lastInteractionFinish.end) : undefined;
          lastInteractionFinishVC90 = null;
          lastInteractionFinishVCClean = false;
          if (!lastInteractionFinishVCResult) {
            _context.next = 41;
            break;
          }
          lastInteractionFinishVCRev = lastInteractionFinishVCResult['ufo:vc:rev'];
          lastInteractionFinishRevision = lastInteractionFinishVCRev === null || lastInteractionFinishVCRev === void 0 ? void 0 : lastInteractionFinishVCRev.find(function (_ref2) {
            var revision = _ref2.revision;
            return revision === DEFAULT_TTVC_REVISION;
          });
          if (!(lastInteractionFinishRevision !== null && lastInteractionFinishRevision !== void 0 && lastInteractionFinishRevision.clean)) {
            _context.next = 38;
            break;
          }
          lastInteractionFinishVCClean = true;
          lastInteractionFinishVC90 = lastInteractionFinishRevision['metric:vc90'];
          _context.next = 39;
          break;
        case 38:
          return _context.abrupt("return", null);
        case 39:
          _context.next = 42;
          break;
        case 41:
          if (normalTTAI !== undefined && typeof normalTTAI === 'number' && normalTTAI === extraTTAI) {
            // Because TTAI is equal between with and without 3p, we can assume VC90 is also equal
            lastInteractionFinishVC90 = effectiveVCRevisionPayload === null || effectiveVCRevisionPayload === void 0 ? void 0 : effectiveVCRevisionPayload['metric:vc90'];
            lastInteractionFinishVCClean = effectiveVCRevisionPayload === null || effectiveVCRevisionPayload === void 0 ? void 0 : effectiveVCRevisionPayload.clean;
          }
        case 42:
          // Helper function to check if labelStack contains third-party type
          isThirdParty = function isThirdParty(labelStack) {
            var _labelStack$some;
            return (_labelStack$some = labelStack === null || labelStack === void 0 ? void 0 : labelStack.some(function (entry) {
              return 'type' in entry && entry.type === 'third-party';
            })) !== null && _labelStack$some !== void 0 ? _labelStack$some : false;
          }; // Pre-filter 3p data
          filteredData = {
            errors: interaction.errors.filter(function (error) {
              return isThirdParty(error.labelStack);
            }),
            spans: [].concat(_toConsumableArray(interaction.spans), _toConsumableArray(atlaskitInteractionSpans)).filter(function (span) {
              return isThirdParty(span.labelStack);
            }),
            requestInfo: interaction.requestInfo.filter(function (req) {
              return isThirdParty(req.labelStack);
            }),
            customTimings: interaction.customTimings.filter(function (timing) {
              return isThirdParty(timing.labelStack);
            }),
            apdex: interaction.apdex.filter(function (apdex) {
              return isThirdParty(apdex.labelStack);
            }),
            reactProfilerTimings: interaction.reactProfilerTimings.filter(function (timing) {
              return isThirdParty(timing.labelStack);
            }),
            customData: interaction.customData.filter(function (data) {
              return isThirdParty(data.labelStack);
            }),
            segments: knownSegments.filter(function (segment) {
              return isThirdParty(segment.labelStack);
            }),
            marks: interaction.marks.filter(function (mark) {
              return isThirdParty(mark.labelStack);
            })
          }; // Clear atlaskit spans after filtering
          atlaskitInteractionSpans.length = 0;

          // Detailed payload
          getDetailedInteractionMetrics = function getDetailedInteractionMetrics() {
            var _interaction$hold3pIn;
            return {
              errors: filteredData.errors.map(function (_ref3) {
                var labelStack = _ref3.labelStack,
                  others = _objectWithoutProperties(_ref3, _excluded);
                return _objectSpread(_objectSpread({}, others), {}, {
                  labelStack: labelStack && optimizeLabelStack(labelStack, getReactUFOPayloadVersion(interaction.type))
                });
              }),
              holdActive: interaction.hold3pActive ? _toConsumableArray(interaction.hold3pActive.values()) : [],
              holdInfo: optimizeHoldInfo((_interaction$hold3pIn = interaction.hold3pInfo) !== null && _interaction$hold3pIn !== void 0 ? _interaction$hold3pIn : [], start, getReactUFOPayloadVersion(interaction.type)),
              spans: optimizeSpans(filteredData.spans, start, getReactUFOPayloadVersion(interaction.type)),
              requestInfo: optimizeRequestInfo(filteredData.requestInfo, start, getReactUFOPayloadVersion(interaction.type)),
              customTimings: optimizeCustomTimings(filteredData.customTimings, start)
            };
          };
          segments3p = !fg('platform_ufo_remove_deprecated_config_fields') && config.killswitchNestedSegments ? [] : filteredData.segments;
          segmentTree = getReactUFOPayloadVersion(interaction.type) === '2.0.0' ? buildSegmentTree(segments3p.map(function (segment) {
            return segment.labelStack;
          })) : {};
          payload = {
            actionSubject: 'experience',
            action: 'measured',
            eventType: 'operational',
            source: 'measured',
            tags: ['observability'],
            attributes: {
              properties: {
                // basic
                'event:hostname': ((_window$location = window.location) === null || _window$location === void 0 ? void 0 : _window$location.hostname) || 'unknown',
                'event:product': config.product,
                'event:schema': '1.0.0',
                'event:sizeInKb': 0,
                'event:source': {
                  name: 'react-ufo/web',
                  version: getReactUFOPayloadVersion(interaction.type)
                },
                'event:region': config.region || 'unknown',
                'experience:key': 'custom.interaction-extra-metrics',
                'experience:name': newUFOName,
                interactionMetrics: _objectSpread(_objectSpread({
                  namePrefix: config.namePrefix || '',
                  segmentPrefix: config.segmentPrefix || '',
                  interactionId: interactionId,
                  pageVisibilityAtTTAI: pageVisibilityAtTTAI,
                  experimental__pageVisibilityAtTTAI: moreAccuratePageVisibilityAtTTAI,
                  // raw interaction metrics
                  rate: rate,
                  routeName: routeName,
                  type: type,
                  abortReason: abortReason,
                  previousInteractionName: previousInteractionName,
                  isPreviousInteractionAborted: isPreviousInteractionAborted,
                  abortedByInteractionName: abortedByInteractionName,
                  // performance
                  end: Math.round(end),
                  start: Math.round(start),
                  'metric:ttai:3p': extraTTAI
                }, finalVCMetrics), {}, {
                  segments: getReactUFOPayloadVersion(interaction.type) === '2.0.0' ? segmentTree : getOldSegmentsLabelStack(segments3p, interaction.type),
                  marks: optimizeMarks(filteredData.marks, getReactUFOPayloadVersion(interaction.type)),
                  apdex: optimizeApdex(filteredData.apdex, getReactUFOPayloadVersion(interaction.type)),
                  reactProfilerTimings: optimizeReactProfilerTimings(filteredData.reactProfilerTimings, start, getReactUFOPayloadVersion(interaction.type)),
                  customData: filteredData.customData
                }, getDetailedInteractionMetrics()),
                'vc:effective:revision': DEFAULT_TTVC_REVISION,
                lastInteractionFinish: {
                  start: lastInteractionFinishStart,
                  end: lastInteractionFinishEnd,
                  ttai: normalTTAI,
                  vc90: lastInteractionFinishVC90,
                  vcClean: lastInteractionFinishVCClean
                }
              }
            }
          };
          payload.attributes.properties['event:sizeInKb'] = getPayloadSize(payload.attributes.properties);
          return _context.abrupt("return", payload);
        case 51:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _createInteractionExtraLogPayload.apply(this, arguments);
}
export default createInteractionExtraLogPayload;