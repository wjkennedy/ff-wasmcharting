import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
var BUFFER_MAX_LENGTH = 1000; // ensure we don't blow up this buffer
var pressureRecordBuffer = [];
var pressureObserver = null;
var memoryRecordBuffer = [];
var memoryInterval;
export function resetPressureRecordBuffer() {
  pressureRecordBuffer.length = 0;
}
export function resetMemoryRecordBuffer() {
  memoryRecordBuffer.length = 0;
}
export function removeOldPressureBufferRecords(filter) {
  pressureRecordBuffer = pressureRecordBuffer.filter(function (_ref) {
    var time = _ref.time;
    return time > filter;
  });
}
export function removeOldMemoryBufferRecords(filter) {
  memoryRecordBuffer = memoryRecordBuffer.filter(function (_ref2) {
    var time = _ref2.time;
    return time > filter;
  });
}
export function createPressureStateReport(start, end) {
  try {
    // To differentiate between the API not available, vs no PressureRecords added
    if (!('PressureObserver' in globalThis)) {
      return null;
    }
    var pressureStateCount = pressureRecordBuffer.reduce(function (pressureReport, _ref3) {
      var time = _ref3.time,
        state = _ref3.state;
      if (time >= start && time <= end) {
        pressureReport[state] += 1;
      }
      return pressureReport;
    }, {
      nominal: 0,
      fair: 0,
      serious: 0,
      critical: 0
    });
    var pressureStateTotal = Object.values(pressureStateCount).reduce(function (total, count) {
      return total + count;
    }) || 1;
    removeOldPressureBufferRecords(end);
    return {
      count: pressureStateCount,
      percentage: {
        nominal: Math.round(pressureStateCount.nominal / pressureStateTotal * 100),
        fair: Math.round(pressureStateCount.fair / pressureStateTotal * 100),
        serious: Math.round(pressureStateCount.serious / pressureStateTotal * 100),
        critical: Math.round(pressureStateCount.critical / pressureStateTotal * 100)
      }
    };
  } catch (_unused) {
    return null;
  }
}
function convertBytesToMegabytes(bytes) {
  return Math.round(Math.round(bytes / (1024 * 1024) * 100) / 100);
}
export function createMemoryStateReport(start, end) {
  try {
    if (!('memory' in performance)) {
      return null;
    }
    var accumulatedMemoryUsage = memoryRecordBuffer.reduce(function (acc, snapshot) {
      if (snapshot.time >= start && snapshot.time <= end) {
        acc.totalJSHeapSize += snapshot.totalJSHeapSize;
        acc.usedJSHeapSize += snapshot.usedJSHeapSize;
        acc.snapshotCount += 1;
      }
      return acc;
    }, {
      totalJSHeapSize: 0,
      usedJSHeapSize: 0,
      snapshotCount: 0
    });
    var memoryStateReport = {
      jsHeapSizeLimitInMB: convertBytesToMegabytes(memoryRecordBuffer[0].jsHeapSizeLimit),
      // just use the first record, since this value always remains the same over time
      avgTotalJSHeapSizeInMB: convertBytesToMegabytes(accumulatedMemoryUsage.totalJSHeapSize / accumulatedMemoryUsage.snapshotCount),
      avgUsedJSHeapSizeInMB: convertBytesToMegabytes(accumulatedMemoryUsage.usedJSHeapSize / accumulatedMemoryUsage.snapshotCount)
    };
    removeOldMemoryBufferRecords(end);
    return memoryStateReport;
  } catch (_unused2) {
    return null;
  }
}
export function initialisePressureObserver() {
  try {
    if ('PressureObserver' in globalThis) {
      pressureObserver = new PressureObserver(function (records) {
        if (pressureRecordBuffer.length + records.length <= BUFFER_MAX_LENGTH) {
          var _pressureRecordBuffer;
          (_pressureRecordBuffer = pressureRecordBuffer).push.apply(_pressureRecordBuffer, _toConsumableArray(records));
        }
      });
      pressureObserver.observe('cpu', {
        sampleInterval: 100
      }).catch(function () {
        // Silently handle permission policy restrictions or other observe failures
        // This prevents unhandled promise rejections from being reported to Sentry
      });
    }
  } catch (_unused3) {
    /* do nothing, this is a best efforts metric */
  }
}
export function initialiseMemoryObserver() {
  try {
    // only set up the interval if `performance.memory` is available in the browser
    if ('memory' in performance) {
      memoryInterval = setInterval(function () {
        // another check of `performance.memory` availability to satisfy typescript
        if ('memory' in performance) {
          var memory = performance.memory;
          if (memoryRecordBuffer.length <= BUFFER_MAX_LENGTH) {
            memoryRecordBuffer.push({
              time: performance.now(),
              jsHeapSizeLimit: memory.jsHeapSizeLimit,
              totalJSHeapSize: memory.totalJSHeapSize,
              usedJSHeapSize: memory.usedJSHeapSize
            });
          }
        }
      }, 100);
    }
  } catch (_unused4) {
    /* do nothing, this is a best efforts metric */
  }
}
export function disconnectMemoryObserver() {
  clearInterval(memoryInterval);
}
export function disconnectPressureObserver() {
  var _pressureObserver;
  (_pressureObserver = pressureObserver) === null || _pressureObserver === void 0 || _pressureObserver.disconnect();
}