import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _typeof from "@babel/runtime/helpers/typeof";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { fg } from '@atlaskit/platform-feature-flags';
import { isVCRevisionEnabled } from '../../config';
import { getActiveInteraction } from '../../interaction-metrics';
import { SSRPlaceholderHandlers } from '../vc-observer/observers/ssr-placeholders';
import EntriesTimeline from './entries-timeline';
import _getElementName from './get-element-name';
import VCCalculator_FY25_03 from './metric-calculator/fy25_03';
import VCCalculator_FY26_04 from './metric-calculator/fy26_04';
import getViewportHeight from './metric-calculator/utils/get-viewport-height';
import getViewportWidth from './metric-calculator/utils/get-viewport-width';
import VCCalculator_Next from './metric-calculator/vc-next';
import RawDataHandler from './raw-data-handler';
import ViewportObserver from './viewport-observer';
import WindowEventObserver from './window-event-observer';
var SSRState = {
  normal: 1,
  waitingForFirstRender: 2,
  ignoring: 3
};
var DEFAULT_SELECTOR_CONFIG = {
  id: false,
  testId: true,
  role: false,
  className: false,
  dataVC: true
};
var hasAbortingEventDuringSSR = false;
export function getHasAbortingEventDuringSSR() {
  return hasAbortingEventDuringSSR;
}
var VCObserverNew = /*#__PURE__*/function () {
  function VCObserverNew(config) {
    var _config$isPostInterac,
      _config$selectorConfi,
      _this = this;
    _classCallCheck(this, VCObserverNew);
    _defineProperty(this, "viewportObserver", null);
    _defineProperty(this, "windowEventObserver", null);
    // SSR related properties
    _defineProperty(this, "ssrPlaceholderHandler", null);
    _defineProperty(this, "ssr", {
      state: SSRState.normal,
      reactRootElement: null,
      renderStart: -1,
      renderStop: -1
    });
    this.entriesTimeline = new EntriesTimeline();
    this.isPostInteraction = (_config$isPostInterac = config.isPostInteraction) !== null && _config$isPostInterac !== void 0 ? _config$isPostInterac : false;
    this.selectorConfig = (_config$selectorConfi = config.selectorConfig) !== null && _config$selectorConfi !== void 0 ? _config$selectorConfi : DEFAULT_SELECTOR_CONFIG;

    // Use shared SSR placeholder handler if provided, otherwise create new one if feature flag is enabled
    if (config.ssrPlaceholderHandler) {
      this.ssrPlaceholderHandler = config.ssrPlaceholderHandler;
    } else {
      var _config$SSRConfig$ena, _config$SSRConfig;
      this.ssrPlaceholderHandler = new SSRPlaceholderHandlers({
        enablePageLayoutPlaceholder: (_config$SSRConfig$ena = (_config$SSRConfig = config.SSRConfig) === null || _config$SSRConfig === void 0 ? void 0 : _config$SSRConfig.enablePageLayoutPlaceholder) !== null && _config$SSRConfig$ena !== void 0 ? _config$SSRConfig$ena : false
      });
    }
    this.viewportObserver = new ViewportObserver({
      onChange: function onChange(onChangeArg) {
        var time = onChangeArg.time,
          type = onChangeArg.type,
          elementRef = onChangeArg.elementRef,
          visible = onChangeArg.visible,
          rect = onChangeArg.rect,
          previousRect = onChangeArg.previousRect,
          mutationData = onChangeArg.mutationData;
        var elementName = 'unknown';
        var element = elementRef.deref();
        if (element) {
          elementName = _this.getElementName(element);
        }
        var data = {
          type: type,
          elementName: elementName,
          rect: rect,
          previousRect: previousRect,
          visible: visible,
          attributeName: mutationData === null || mutationData === void 0 ? void 0 : mutationData.attributeName,
          oldValue: mutationData === null || mutationData === void 0 ? void 0 : mutationData.oldValue,
          newValue: mutationData === null || mutationData === void 0 ? void 0 : mutationData.newValue
        };
        if (element) {
          var labelStacks = getLabelStacks(element);
          if (labelStacks) {
            Object.assign(data, {
              labelStacks: labelStacks
            });
          }
        }
        _this.entriesTimeline.push({
          time: time,
          data: data
        });
      },
      // Pass SSR context to ViewportObserver
      getSSRState: function getSSRState() {
        return _this.getSSRState();
      },
      getSSRPlaceholderHandler: function getSSRPlaceholderHandler() {
        return _this.getSSRPlaceholderHandler();
      },
      searchPageConfig: config.searchPageConfig
    });
    this.windowEventObserver = new WindowEventObserver({
      onEvent: function onEvent(_ref) {
        var time = _ref.time,
          type = _ref.type;
        // Don't abort press interactions on keydown events, as keydown is expected
        // when users press Enter/Space to activate buttons or other interactive elements
        if (type === 'keydown' && fg('platform_ufo_keypress_interaction_abort')) {
          var interaction = getActiveInteraction();
          if ((interaction === null || interaction === void 0 ? void 0 : interaction.type) === 'press') {
            return;
          }
        }
        _this.entriesTimeline.push({
          time: time,
          data: {
            type: 'window:event',
            eventType: type
          }
        });
      }
    });
  }
  return _createClass(VCObserverNew, [{
    key: "start",
    value: function start(_) {
      var _this$viewportObserve,
        _this2 = this;
      // Reset SSR state on start (matches old VCObserver behavior)
      this.ssr = {
        state: SSRState.normal,
        reactRootElement: null,
        // Reset to null (matches old VCObserver)
        renderStart: -1,
        renderStop: -1
      };
      (_this$viewportObserve = this.viewportObserver) === null || _this$viewportObserve === void 0 || _this$viewportObserve.start();
      if (fg('ufo_fix_aborting_interaction_detection_during_ssr')) {
        var _window, _this$windowEventObse;
        this.entriesTimeline.clear();
        if ((_window = window) !== null && _window !== void 0 && _window.__SSR_ABORT_LISTENERS__) {
          var abortListeners = window.__SSR_ABORT_LISTENERS__;
          var aborts = abortListeners.aborts;
          if (aborts && _typeof(aborts) === 'object') {
            Object.entries(aborts).forEach(function (_ref2) {
              var _ref3 = _slicedToArray(_ref2, 2),
                key = _ref3[0],
                time = _ref3[1];
              if (typeof time === 'number') {
                _this2.entriesTimeline.push({
                  time: time,
                  data: {
                    type: 'window:event',
                    eventType: key
                  }
                });
              }
            });
          }
        }
        (_this$windowEventObse = this.windowEventObserver) === null || _this$windowEventObse === void 0 || _this$windowEventObse.start();
      } else {
        var _window2, _this$windowEventObse2;
        if ((_window2 = window) !== null && _window2 !== void 0 && _window2.__SSR_ABORT_LISTENERS__) {
          var _abortListeners = window.__SSR_ABORT_LISTENERS__;
          var _aborts = _abortListeners.aborts;
          if (_aborts && _typeof(_aborts) === 'object') {
            Object.entries(_aborts).forEach(function (_ref4) {
              var _ref5 = _slicedToArray(_ref4, 2),
                key = _ref5[0],
                time = _ref5[1];
              if (typeof time === 'number') {
                _this2.entriesTimeline.push({
                  time: time,
                  data: {
                    type: 'window:event',
                    eventType: key
                  }
                });
                if (fg('ufo_detect_aborting_interaction_during_ssr')) {
                  hasAbortingEventDuringSSR = true;
                }
              }
            });
          }
        }
        (_this$windowEventObse2 = this.windowEventObserver) === null || _this$windowEventObse2 === void 0 || _this$windowEventObse2.start();
        this.entriesTimeline.clear();
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      var _this$viewportObserve2, _this$windowEventObse3;
      (_this$viewportObserve2 = this.viewportObserver) === null || _this$viewportObserve2 === void 0 || _this$viewportObserve2.stop();
      (_this$windowEventObse3 = this.windowEventObserver) === null || _this$windowEventObse3 === void 0 || _this$windowEventObse3.stop();

      // Clear SSR state on stop (matches old VCObserver behavior)
      this.ssr.reactRootElement = null;
    }

    // SSR related methods
  }, {
    key: "setReactRootElement",
    value: function setReactRootElement(element) {
      this.ssr.reactRootElement = element;
    }
  }, {
    key: "setReactRootRenderStart",
    value: function setReactRootRenderStart() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();
      this.ssr.renderStart = startTime;
      this.ssr.state = SSRState.waitingForFirstRender;
    }
  }, {
    key: "setReactRootRenderStop",
    value: function setReactRootRenderStop() {
      var stopTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();
      this.ssr.renderStop = stopTime;
    }
  }, {
    key: "collectSSRPlaceholders",
    value: function collectSSRPlaceholders() {
      // This is handled by the shared SSRPlaceholderHandlers in VCObserverWrapper
      // Individual observers don't need to implement this
    }

    // Internal methods for ViewportObserver to access SSR state
  }, {
    key: "getSSRState",
    value: function getSSRState() {
      return this.ssr;
    }
  }, {
    key: "getSSRPlaceholderHandler",
    value: function getSSRPlaceholderHandler() {
      return this.ssrPlaceholderHandler;
    }
  }, {
    key: "addSSR",
    value: function addSSR(ssr) {
      this.entriesTimeline.push({
        time: ssr,
        data: {
          elementName: 'SSR',
          type: 'mutation:element',
          rect: {
            height: getViewportHeight(),
            width: getViewportWidth(),
            left: 0,
            top: 0,
            x: 0,
            y: 0,
            bottom: getViewportHeight(),
            right: getViewportWidth(),
            toJSON: function toJSON() {
              return null;
            }
          },
          visible: true
        }
      });
    }
  }, {
    key: "getVCResult",
    value: function () {
      var _getVCResult = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(param) {
        var start, stop, interactionId, interactionType, interactionAbortReason, isPageVisible, include3p, includeSSRRatio, excludeSmartAnswersInSearch, includeRawData, rawDataStopTime, results, feVCCalculationStartTime, calculator_fy25_03, orderedEntries, fy25_03, calculator_fy26_04, calculator_next, calculatorParams, _yield$Promise$all, _yield$Promise$all2, fy26_04, vcNext, feVCCalculationEndTime, rawVCCalculationStartTime, rawHandler, rawStopTime, rawOrderedEntries, raw;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              start = param.start, stop = param.stop, interactionId = param.interactionId, interactionType = param.interactionType, interactionAbortReason = param.interactionAbortReason, isPageVisible = param.isPageVisible, include3p = param.include3p, includeSSRRatio = param.includeSSRRatio, excludeSmartAnswersInSearch = param.excludeSmartAnswersInSearch, includeRawData = param.includeRawData, rawDataStopTime = param.rawDataStopTime;
              results = [];
              this.addStartEntry(start);
              feVCCalculationStartTime = performance.now();
              calculator_fy25_03 = new VCCalculator_FY25_03();
              if (param.includeSSRInV3 && param.ssr) {
                this.addSSR(param.ssr);
              }
              orderedEntries = this.entriesTimeline.getOrderedEntries({
                start: start,
                stop: stop
              });
              if (!isVCRevisionEnabled('fy25.03')) {
                _context.next = 13;
                break;
              }
              _context.next = 10;
              return calculator_fy25_03.calculate({
                orderedEntries: orderedEntries,
                startTime: start,
                stopTime: stop,
                interactionId: interactionId,
                interactionType: interactionType,
                isPostInteraction: this.isPostInteraction,
                include3p: include3p,
                excludeSmartAnswersInSearch: excludeSmartAnswersInSearch,
                includeSSRRatio: includeSSRRatio,
                isPageVisible: isPageVisible,
                interactionAbortReason: interactionAbortReason
              });
            case 10:
              _context.t0 = _context.sent;
              _context.next = 14;
              break;
            case 13:
              _context.t0 = null;
            case 14:
              fy25_03 = _context.t0;
              if (fy25_03) {
                results.push(fy25_03);
              }

              // From TTVC v4 onwards, ensuring that SSR entry is always auto-added, whenever it is configured.
              if (param.ssr) {
                this.addSSR(param.ssr);
              }
              calculator_fy26_04 = new VCCalculator_FY26_04();
              calculator_next = new VCCalculator_Next();
              calculatorParams = {
                orderedEntries: orderedEntries,
                startTime: start,
                stopTime: stop,
                interactionId: interactionId,
                interactionType: interactionType,
                isPostInteraction: this.isPostInteraction,
                include3p: include3p,
                excludeSmartAnswersInSearch: excludeSmartAnswersInSearch,
                includeSSRRatio: includeSSRRatio,
                isPageVisible: isPageVisible,
                interactionAbortReason: interactionAbortReason
              };
              _context.next = 22;
              return Promise.all([isVCRevisionEnabled('fy26.04') ? calculator_fy26_04.calculate(calculatorParams) : null, isVCRevisionEnabled('next') ? calculator_next.calculate(calculatorParams) : null]);
            case 22:
              _yield$Promise$all = _context.sent;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
              fy26_04 = _yield$Promise$all2[0];
              vcNext = _yield$Promise$all2[1];
              if (fy26_04) {
                results.push(fy26_04);
              }
              if (vcNext) {
                results.push(vcNext);
              }
              feVCCalculationEndTime = performance.now();
              if (!(includeRawData && fg('platform_ufo_enable_vc_raw_data'))) {
                _context.next = 39;
                break;
              }
              rawVCCalculationStartTime = performance.now();
              rawHandler = new RawDataHandler(); // Use rawDataStopTime (end3p) when available to capture observations during 3p holds
              rawStopTime = rawDataStopTime !== null && rawDataStopTime !== void 0 ? rawDataStopTime : stop;
              rawOrderedEntries = rawDataStopTime ? this.entriesTimeline.getOrderedEntries({
                start: start,
                stop: rawStopTime
              }) : orderedEntries;
              _context.next = 36;
              return rawHandler.getRawData({
                entries: rawOrderedEntries,
                startTime: start,
                stopTime: rawStopTime,
                isPageVisible: isPageVisible
              });
            case 36:
              raw = _context.sent;
              results.forEach(function (result) {
                delete result.vcDetails;
                delete result.ratios;
              });
              if (raw) {
                raw.rawVCTime = Number((performance.now() - rawVCCalculationStartTime).toFixed(2));
                raw.feVCTime = Number((feVCCalculationEndTime - feVCCalculationStartTime).toFixed(2));
                results.push(raw);
              }
            case 39:
              return _context.abrupt("return", results);
            case 40:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getVCResult(_x) {
        return _getVCResult.apply(this, arguments);
      }
      return getVCResult;
    }()
  }, {
    key: "addStartEntry",
    value: function addStartEntry(startTime) {
      this.entriesTimeline.push({
        time: startTime,
        data: {
          type: 'mutation:element',
          elementName: 'START',
          visible: true,
          rect: {
            x: 0,
            y: 0,
            width: window.innerWidth,
            height: window.innerHeight,
            top: 0,
            left: 0,
            bottom: window.innerHeight,
            right: window.innerWidth,
            toJSON: function toJSON() {
              return {
                x: this.x,
                y: this.y,
                width: this.width,
                height: this.height,
                top: this.top,
                left: this.left,
                bottom: this.bottom,
                right: this.right
              };
            }
          }
        }
      });
    }
  }, {
    key: "getElementName",
    value: function getElementName(element) {
      return _getElementName(this.selectorConfig, element);
    }
  }]);
}();
export { VCObserverNew as default };
function labelStackFromFiber(fiber) {
  var _fiber$child;
  var value = fiber === null || fiber === void 0 || (_fiber$child = fiber.child) === null || _fiber$child === void 0 || (_fiber$child = _fiber$child.memoizedProps) === null || _fiber$child === void 0 ? void 0 : _fiber$child.value;
  return Array.isArray(value === null || value === void 0 ? void 0 : value.labelStack) ? value.labelStack : [];
}
function labelStackToString(labelStack) {
  return labelStack.map(function (label) {
    return label.name;
  }).join('/');
}
function labelStackToSegment(labelStack) {
  var segmentIndex = -1;
  for (var i = labelStack.length - 1; i >= 0; i--) {
    if (labelStack[i].segmentId) {
      segmentIndex = i;
      break;
    }
  }
  return labelStack.slice(0, segmentIndex + 1).map(function (label) {
    return label.name;
  }).join('/');
}
function traverseFiber(fiber) {
  var segment = 'unknown';
  var labelStackString = 'unknown';
  var currentFiber = fiber;
  while (currentFiber) {
    if (currentFiber.type) {
      var componentName = currentFiber.type.displayName || currentFiber.type.name;
      if (componentName === 'UFOSegment' || componentName === 'UFOLabel') {
        var labelStack = labelStackFromFiber(currentFiber);
        labelStackString = labelStackToString(labelStack) || 'unknown';
        segment = labelStackToSegment(labelStack) || 'unknown';
        break;
      }
    }
    currentFiber = currentFiber.return;
  }
  return {
    segment: segment,
    labelStack: labelStackString
  };
}
function getLabelStacks(element) {
  var reactFiberKey = Object.keys(element).find(function (key) {
    return key.startsWith('__reactFiber$');
  });
  if (!reactFiberKey) {
    return null;
  }
  var fiber = element[reactFiberKey];
  return fiber ? traverseFiber(fiber) : null;
}