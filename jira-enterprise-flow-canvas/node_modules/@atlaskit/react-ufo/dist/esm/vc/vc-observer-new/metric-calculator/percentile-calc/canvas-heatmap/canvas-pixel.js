import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import taskYield from '../../utils/task-yield';

// 24-bit color value

/**
 * Class responsible for managing a scaled canvas and tracking pixel drawing operations.
 * It uses either an OffscreenCanvas (if available) or a regular HTML Canvas for better performance
 * and maintains a mapping between colors and timestamps for pixel counting purposes.
 */
export var ViewportCanvas = /*#__PURE__*/function () {
  /** The underlying Canvas instance (either OffscreenCanvas or HTMLCanvasElement) */

  /** The 2D rendering context of the canvas */

  /** Scale factor applied to the canvas (affects final pixel counts) */

  /** Maps unique colors to their corresponding timestamps */

  /** Counter used to generate unique colors */

  /**
   * Creates a new ViewportCanvas instance.
   * @param viewport - The dimensions of the viewport
   * @param scaleFactor - Scale factor to apply to the canvas (default: 0.5)
   * @throws {Error} If canvas context cannot be obtained
   */
  function ViewportCanvas(viewport) {
    var scaleFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    _classCallCheck(this, ViewportCanvas);
    this.scaleFactor = scaleFactor;
    this.colorCounter = 1;
    this.colorTimeMap = new Map();
    var safeViewportWidth = Math.max(viewport.width, 1);
    var safeViewportHeight = Math.max(viewport.height, 1);

    // Calculate scaled dimensions
    this.scaledWidth = Math.max(Math.ceil(safeViewportWidth * scaleFactor), 1);
    this.scaledHeight = Math.max(Math.ceil(safeViewportHeight * scaleFactor), 1);
    this.scaleX = this.scaledWidth / safeViewportWidth;
    this.scaleY = this.scaledHeight / safeViewportHeight;

    // Initialize canvas with scaled dimensions
    this.canvas = this.createCanvas(this.scaledWidth, this.scaledHeight);
    var ctx = this.canvas.getContext('2d', {
      alpha: false,
      // Disable alpha channel for better performance
      willReadFrequently: true,
      // Optimize for frequent pixel reading
      colorSpace: 'srgb' // Use standard RGB color space
    });
    if (!ctx) {
      throw new Error('Could not get canvas context');
    }
    this.ctx = ctx;
    this.ctx.globalCompositeOperation = 'source-over';
    this.ctx.imageSmoothingEnabled = false; // Disable image smoothing for better performance

    this.clear();
  }

  /**
   * Creates a canvas instance, falling back to HTMLCanvasElement if OffscreenCanvas is not available
   */
  return _createClass(ViewportCanvas, [{
    key: "createCanvas",
    value: function createCanvas(width, height) {
      if (typeof OffscreenCanvas !== 'undefined') {
        return new OffscreenCanvas(width, height);
      }
      var canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      return canvas;
    }
  }, {
    key: "getScaledDimensions",
    value: function getScaledDimensions() {
      return {
        width: this.scaledWidth,
        height: this.scaledHeight
      };
    }

    /**
     * Clears the entire canvas by removing all drawn content.
     * @private
     */
  }, {
    key: "clear",
    value: function clear() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    /**
     * Generates a unique RGB color from an incrementing counter.
     * Uses a 24-bit color space (16,777,216 possible colors).
     *
     * @private
     * @returns A unique RGB color string
     *
     * @example
     * // Example bit operations for color 0x00FF8040:
     * // Red:   (0x00FF8040 >> 16) & 0xFF = 0xFF = 255
     * // Green: (0x00FF8040 >> 8) & 0xFF  = 0x80 = 128
     * // Blue:   0x00FF8040 & 0xFF        = 0x40 = 64
     */
  }, {
    key: "generateColor",
    value: function generateColor() {
      // Wrap around at 16,777,215 (0x00FFFFFF) to stay within 24-bit color space
      var rgbColor = this.colorCounter++ % 0x00ffffff;
      return getRGBComponents(rgbColor);
    }

    /**
     * Draws a rectangle on the canvas with a unique color and associates it with a timestamp.
     * Each drawn rectangle gets a unique color which is mapped to the provided timestamp.
     *
     * @param rect - The rectangle dimensions to draw
     * @param timestamp - The timestamp to associate with this drawing operation
     */
  }, {
    key: "drawRect",
    value: function drawRect(rect, timestamp) {
      var color = this.generateColor();
      this.colorTimeMap.set(color, timestamp);
      this.ctx.fillStyle = color;
      if (this.scaleFactor === 1) {
        return this.ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
      }
      var scaledX = rect.x * this.scaleX;
      var scaledY = rect.y * this.scaleY;
      var scaledWidth = rect.width * this.scaleX;
      var scaledHeight = rect.height * this.scaleY;
      this.ctx.fillRect(Math.floor(scaledX), Math.ceil(scaledY), Math.max(scaledWidth, 1), Math.max(scaledHeight, 1));
    }

    /**
     * Calculates the number of pixels drawn for each timestamp.
     * This method:
     * 1. Reads the pixel data from the canvas
     * 2. Counts pixels of each unique color
     * 3. Maps colors back to their timestamps
     * 4. Adjusts counts based on the scale factor
     *
     * @returns A Map containing timestamp to pixel count mappings
     */
  }, {
    key: "getPixelCounts",
    value: (function () {
      var _getPixelCounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var imageData, timestampsAmount, pixelCounts, timePixelCounts, i, count, color, rgbColor, timestamp;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
              timestampsAmount = this.colorTimeMap.size;
              _context.next = 4;
              return calculateDrawnPixelsRaw(imageData, this.scaleFactor, timestampsAmount);
            case 4:
              pixelCounts = _context.sent;
              // Convert color counts to timestamp counts
              timePixelCounts = new Map();
              i = 0;
            case 7:
              if (!(i < pixelCounts.length)) {
                _context.next = 18;
                break;
              }
              count = pixelCounts[i];
              if (!(typeof count !== 'number')) {
                _context.next = 11;
                break;
              }
              return _context.abrupt("continue", 15);
            case 11:
              color = i + 1;
              rgbColor = getRGBComponents(color);
              timestamp = this.colorTimeMap.get(rgbColor);
              if (timestamp !== undefined) {
                timePixelCounts.set(timestamp, (timePixelCounts.get(timestamp) || 0) + count);
              }
            case 15:
              i++;
              _context.next = 7;
              break;
            case 18:
              return _context.abrupt("return", timePixelCounts);
            case 19:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getPixelCounts() {
        return _getPixelCounts.apply(this, arguments);
      }
      return getPixelCounts;
    }())
  }]);
}();

/**
 * Converts a number into RGB components in such a way that they can be recombined
 * to form the original number using bitwise operations.
 * @param number - The input number to be split into RGB components.
 * @returns The RGB color string in the format "rgb(r, g, b)".
 */
export function getRGBComponents(n) {
  // Ensure the input is within the valid range for a 24-bit color
  if (n < 0 || n > 0xffffff) {
    throw new Error('Input number must be between 0 and 16777215 (inclusive).');
  }

  // Extract blue component (bits 0-7)
  var blue = n & 0xff;

  // Extract green component (bits 8-15)
  var green = n >> 8 & 0xff;

  // Extract red component (bits 16-23)
  var red = n >> 16 & 0xff;
  return "rgb(".concat(red, ", ").concat(green, ", ").concat(blue, ")");
}

/**
 * Calculates the number of pixels drawn for each color in the image data.
 * @param imageData - The image data to analyze.
 * @param scaleFactor - The scale factor applied to the canvas.
 * @param arraySize - The amount of timestamps that were drawn in the viewport
 * @returns A Map containing color to pixel count mappings.
 */
export function calculateDrawnPixelsRaw(_x, _x2, _x3) {
  return _calculateDrawnPixelsRaw.apply(this, arguments);
}
function _calculateDrawnPixelsRaw() {
  _calculateDrawnPixelsRaw = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(imageData, _, arraySize) {
    var data, arr, i, color, colorIndex;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          data = imageData.data;
          arr = new Uint32Array(arraySize);
          i = 0;
        case 3:
          if (!(i < data.length)) {
            _context2.next = 11;
            break;
          }
          // Check alpha
          if (data[i + 3] !== 0) {
            // Combine RGB components into a single 24-bit color value:
            // (data[i] << 16)   - Shift red component left 16 bits   (bits 16-23)
            // (data[i + 1] << 8) - Shift green component left 8 bits (bits 8-15)
            // data[i + 2]       - Blue component stays as is         (bits 0-7)
            // The | operator combines all bits together
            color = data[i] << 16 | data[i + 1] << 8 | data[i + 2];
            colorIndex = color - 1;
            arr[colorIndex] = (arr[colorIndex] || 0) + 1;
          }
          if (!(i % 10000 === 0)) {
            _context2.next = 8;
            break;
          }
          _context2.next = 8;
          return taskYield();
        case 8:
          i += 4;
          _context2.next = 3;
          break;
        case 11:
          return _context2.abrupt("return", arr);
        case 12:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _calculateDrawnPixelsRaw.apply(this, arguments);
}