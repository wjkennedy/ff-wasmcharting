import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _typeof from "@babel/runtime/helpers/typeof";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { fg } from '@atlaskit/platform-feature-flags';
var config;
export var DEFAULT_TTVC_REVISION = 'fy25.03';
export var UNKNOWN_INTERACTION_RATE = 1000;

// Defensively typed, since this is directly user-editable
// and they could delete empty members

export function setUFOConfig(newConfig) {
  var _newConfig$vc;
  // Handle edge cases with `enabledVCRevisions`
  var _ref = (_newConfig$vc = newConfig === null || newConfig === void 0 ? void 0 : newConfig.vc) !== null && _newConfig$vc !== void 0 ? _newConfig$vc : {},
    enabledVCRevisions = _ref.enabledVCRevisions;
  if (_typeof(enabledVCRevisions === null || enabledVCRevisions === void 0 ? void 0 : enabledVCRevisions.byExperience) === 'object') {
    config = _objectSpread(_objectSpread({}, newConfig), {}, {
      vc: _objectSpread(_objectSpread({}, newConfig.vc), {}, {
        enabledVCRevisions: {
          // enforce axiom about `enabledVCRevisions.all` config
          all: Array.from(new Set([DEFAULT_TTVC_REVISION].concat(_toConsumableArray(enabledVCRevisions === null || enabledVCRevisions === void 0 ? void 0 : enabledVCRevisions.all), _toConsumableArray(Object.values(enabledVCRevisions === null || enabledVCRevisions === void 0 ? void 0 : enabledVCRevisions.byExperience).flat())))),
          byExperience: _objectSpread({}, enabledVCRevisions === null || enabledVCRevisions === void 0 ? void 0 : enabledVCRevisions.byExperience)
        }
      })
    });
  } else {
    config = newConfig;
  }
}
export function getConfig() {
  return config;
}
var isValidConfigArray = function isValidConfigArray(array) {
  return Array.isArray(array) && array.length > 0;
};
export function getEnabledVCRevisions() {
  var experienceKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  try {
    var _config$vc;
    if (!config) {
      return [];
    }
    if ((_config$vc = config.vc) !== null && _config$vc !== void 0 && _config$vc.enabled) {
      var _config$vc2, _enabledVCRevisions$b;
      var _ref2 = (_config$vc2 = config.vc) !== null && _config$vc2 !== void 0 ? _config$vc2 : {},
        enabledVCRevisions = _ref2.enabledVCRevisions;
      if (isValidConfigArray(enabledVCRevisions === null || enabledVCRevisions === void 0 || (_enabledVCRevisions$b = enabledVCRevisions.byExperience) === null || _enabledVCRevisions$b === void 0 ? void 0 : _enabledVCRevisions$b[experienceKey])) {
        var _enabledVCRevisions$b2;
        return (_enabledVCRevisions$b2 = enabledVCRevisions.byExperience) === null || _enabledVCRevisions$b2 === void 0 ? void 0 : _enabledVCRevisions$b2[experienceKey];
      }
      if (isValidConfigArray(enabledVCRevisions === null || enabledVCRevisions === void 0 ? void 0 : enabledVCRevisions.all)) {
        return enabledVCRevisions.all;
      }
      return [DEFAULT_TTVC_REVISION];
    }
    return [];
  } catch (_unused) {
    return [];
  }
}
export function isVCRevisionEnabled(revision, experienceKey) {
  return getEnabledVCRevisions(experienceKey).includes(revision);
}
export function getMostRecentVCRevision() {
  var experienceKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var enabledVCRevisions = getEnabledVCRevisions(experienceKey);
  return enabledVCRevisions[enabledVCRevisions.length - 1];
}
export function getReactHydrationStats() {
  if (!config) {
    return undefined;
  }
  try {
    var _config, _config$getReactHydra;
    var stats = (_config = config) === null || _config === void 0 || (_config$getReactHydra = _config.getReactHydrationStats) === null || _config$getReactHydra === void 0 ? void 0 : _config$getReactHydra.call(_config);
    return stats !== null && stats !== void 0 ? stats : undefined;
  } catch (e) {
    // eslint-disable-next-line no-console
    console.error('getReactHydrationStats threw an error: ', e);
    return undefined;
  }
}
export function getInteractionRate(name, interactionKind) {
  try {
    if (!config) {
      return 0;
    }
    var _config2 = config,
      killswitch = _config2.killswitch,
      rates = _config2.rates,
      rules = _config2.rules,
      kind = _config2.kind,
      autoGeneratedRate = _config2.autoGeneratedRate;
    if (killswitch != null) {
      // Specifically kill certain events
      if (killswitch.includes(name)) {
        return 0;
      }
    }
    var isUnknown = name === 'unknown';
    if (isUnknown) {
      if ((rates === null || rates === void 0 ? void 0 : rates[name]) != null) {
        return rates[name];
      }
      // Return default rate for unknown events when no explicit rate is configured
      return UNKNOWN_INTERACTION_RATE;
    }
    if (rates != null) {
      // Decide the rate explicitly
      if (rates[name] != null) {
        return rates[name];
      }
    }
    if (rules != null) {
      for (var i = 0; i < rules.length; i++) {
        var rule = rules[i];
        var test = rule.test,
          rate = rule.rate;
        if (test != null && rate != null) {
          var regexp = new RegExp(test, 'ig');
          if (regexp.test(name)) {
            return rate;
          }
        }
      }
    }
    var isAutogenerated = name === null || name === void 0 ? void 0 : name.startsWith('auto-generated');
    if (isAutogenerated) {
      var _rate = autoGeneratedRate;
      if (_rate != null) {
        return _rate;
      }
    }
    if (kind != null) {
      var _rate2 = kind[interactionKind];
      if (_rate2 != null) {
        return _rate2;
      }
    }
    return 0;
  } catch (_unused2) {
    // Fallback
    return 0;
  }
}
export function getExperimentalInteractionRate(name, interactionType) {
  try {
    if (!config) {
      return 0;
    }
    var _config3 = config,
      experimentalInteractionMetrics = _config3.experimentalInteractionMetrics;
    if (!(experimentalInteractionMetrics !== null && experimentalInteractionMetrics !== void 0 && experimentalInteractionMetrics.enabled)) {
      return 0;
    }
    if (experimentalInteractionMetrics.rates && typeof experimentalInteractionMetrics.rates[name] === 'number') {
      return experimentalInteractionMetrics.rates[name];
    }
    if (experimentalInteractionMetrics.kind && typeof experimentalInteractionMetrics.kind[interactionType] === 'number') {
      return experimentalInteractionMetrics.kind[interactionType];
    }
    return 0;
  } catch (_unused3) {
    return 0;
  }
}
export function getVCRawDataInteractionRate(name, interactionType) {
  return getConfigRate(name, interactionType, 'enableVCRawDataRates');
}
export function shouldUseRawDataThirdPartyBehavior(name, interactionType) {
  if (!fg('platform_ufo_raw_data_thirdparty')) {
    return false;
  }
  return getVCRawDataInteractionRate(name, interactionType) > 0;
}
export function getPostInteractionRate(name, interactionType) {
  return getConfigRate(name, interactionType, 'postInteractionLog');
}
export function getCapabilityRate(capability) {
  if (fg('platform_ufo_remove_deprecated_config_fields')) {
    return 1;
  }
  try {
    if (!config) {
      return 0;
    }
    var _config4 = config,
      capabilityRate = _config4.capability;
    if (capabilityRate != null) {
      var rate = capabilityRate[capability];
      if (rate != null) {
        return rate;
      }
    }
    return 0;
  } catch (_unused4) {
    return 0;
  }
}
function getConfigRate(name, interactionType, configName) {
  try {
    if (!config) {
      return 0;
    }
    var gotConfig = config[configName];
    if (!(gotConfig !== null && gotConfig !== void 0 && gotConfig.enabled)) {
      return 0;
    }
    if (interactionType !== 'page_load' && interactionType !== 'transition') {
      return 0;
    }
    if (gotConfig.rates && typeof gotConfig.rates[name] === 'number') {
      return gotConfig.rates[name];
    }
    if ('kind' in gotConfig && gotConfig.kind && typeof gotConfig.kind[interactionType] === 'number') {
      return gotConfig.kind[interactionType];
    }
    return 0;
  } catch (_unused5) {
    return 0;
  }
}
export function getExtraInteractionRate(name, interactionType) {
  return getConfigRate(name, interactionType, 'extraInteractionMetrics');
}
var validTypingMethods = ['timeout', 'timeoutNoAlloc', 'mutationObserver'];
export function getTypingPerformanceTracingMethod() {
  var defaultMethod = 'timeout';
  try {
    if (!config) {
      return defaultMethod;
    }
    var _config5 = config,
      typingMethod = _config5.typingMethod;
    if (typingMethod != null && validTypingMethods.find(function (m) {
      return m === typingMethod;
    })) {
      return typingMethod;
    } else {
      return defaultMethod;
    }
  } catch (_unused6) {
    return defaultMethod;
  }
}

// Will ask UFO to wait for BM3 TTI for all events on this list
export function getAwaitBM3TTIList() {
  try {
    if (!config) {
      return [];
    }
    var _config6 = config,
      awaitBM3TTI = _config6.awaitBM3TTI;
    if (awaitBM3TTI != null) {
      return awaitBM3TTI;
    } else {
      return [];
    }
  } catch (_unused7) {
    return [];
  }
}

// Will ask UFO to override ufoName => experienceKey to the apdex key
// This is to cover use cases where one rUFO route is split into multiple BM3 keys (1:N)
// This workaround should only be used as last resource,
// when we find router limitations preventing teams from splliting these routes
export function getUfoNameOverrides() {
  try {
    if (!config) {
      return undefined;
    }
    var _config7 = config,
      ufoNameOverrides = _config7.ufoNameOverrides;
    if (ufoNameOverrides != null) {
      return ufoNameOverrides;
    }
    return undefined;
  } catch (_unused8) {
    return undefined;
  }
}
export function getMinorInteractions() {
  try {
    if (!config) {
      return undefined;
    }
    var _config8 = config,
      minorInteractions = _config8.minorInteractions;
    return minorInteractions;
  } catch (_unused9) {
    return undefined;
  }
}

// Contains the list of interactions that do not abort existing known interactions
export function getDoNotAbortActivePressInteraction() {
  try {
    if (!config) {
      return undefined;
    }
    var _config9 = config,
      doNotAbortActivePressInteraction = _config9.doNotAbortActivePressInteraction;
    return doNotAbortActivePressInteraction;
  } catch (_unused0) {
    return undefined;
  }
}

// Contains the list of interactions that do not abort on transitions
export function getDoNotAbortActivePressInteractionOnTransition() {
  try {
    if (!config) {
      return undefined;
    }
    var _config0 = config,
      doNotAbortActivePressInteractionOnTransition = _config0.doNotAbortActivePressInteractionOnTransition;
    return doNotAbortActivePressInteractionOnTransition;
  } catch (_unused1) {
    return undefined;
  }
}

// Contains the list of interactions that do not abort on transitions
export function getFinishInteractionOnTransition() {
  try {
    if (!config) {
      return undefined;
    }
    var _config1 = config,
      finishInteractionOnTransition = _config1.finishInteractionOnTransition;
    return finishInteractionOnTransition;
  } catch (_unused10) {
    return undefined;
  }
}
export var CLEANUP_TIMEOUT = 60 * 1000;
export function getInteractionTimeout(ufoName) {
  try {
    if (!config) {
      return CLEANUP_TIMEOUT;
    }
    var _config10 = config,
      interactionTimeout = _config10.interactionTimeout;
    if (interactionTimeout != null && interactionTimeout[ufoName] != null) {
      return interactionTimeout[ufoName];
    }
    if (interactionTimeout != null && interactionTimeout.__globalInteractionTimeout != null) {
      return interactionTimeout.__globalInteractionTimeout;
    } else {
      return CLEANUP_TIMEOUT;
    }
  } catch (_unused11) {
    return CLEANUP_TIMEOUT;
  }
}