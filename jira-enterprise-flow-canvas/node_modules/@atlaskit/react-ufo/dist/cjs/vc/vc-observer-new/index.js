"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.getHasAbortingEventDuringSSR = getHasAbortingEventDuringSSR;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _config = require("../../config");
var _interactionMetrics = require("../../interaction-metrics");
var _ssrPlaceholders = require("../vc-observer/observers/ssr-placeholders");
var _entriesTimeline = _interopRequireDefault(require("./entries-timeline"));
var _getElementName2 = _interopRequireDefault(require("./get-element-name"));
var _fy25_ = _interopRequireDefault(require("./metric-calculator/fy25_03"));
var _fy26_ = _interopRequireDefault(require("./metric-calculator/fy26_04"));
var _getViewportHeight = _interopRequireDefault(require("./metric-calculator/utils/get-viewport-height"));
var _getViewportWidth = _interopRequireDefault(require("./metric-calculator/utils/get-viewport-width"));
var _vcNext = _interopRequireDefault(require("./metric-calculator/vc-next"));
var _rawDataHandler = _interopRequireDefault(require("./raw-data-handler"));
var _viewportObserver = _interopRequireDefault(require("./viewport-observer"));
var _windowEventObserver = _interopRequireDefault(require("./window-event-observer"));
var SSRState = {
  normal: 1,
  waitingForFirstRender: 2,
  ignoring: 3
};
var DEFAULT_SELECTOR_CONFIG = {
  id: false,
  testId: true,
  role: false,
  className: false,
  dataVC: true
};
var hasAbortingEventDuringSSR = false;
function getHasAbortingEventDuringSSR() {
  return hasAbortingEventDuringSSR;
}
var VCObserverNew = exports.default = /*#__PURE__*/function () {
  function VCObserverNew(config) {
    var _config$isPostInterac,
      _config$selectorConfi,
      _this = this;
    (0, _classCallCheck2.default)(this, VCObserverNew);
    (0, _defineProperty2.default)(this, "viewportObserver", null);
    (0, _defineProperty2.default)(this, "windowEventObserver", null);
    // SSR related properties
    (0, _defineProperty2.default)(this, "ssrPlaceholderHandler", null);
    (0, _defineProperty2.default)(this, "ssr", {
      state: SSRState.normal,
      reactRootElement: null,
      renderStart: -1,
      renderStop: -1
    });
    this.entriesTimeline = new _entriesTimeline.default();
    this.isPostInteraction = (_config$isPostInterac = config.isPostInteraction) !== null && _config$isPostInterac !== void 0 ? _config$isPostInterac : false;
    this.selectorConfig = (_config$selectorConfi = config.selectorConfig) !== null && _config$selectorConfi !== void 0 ? _config$selectorConfi : DEFAULT_SELECTOR_CONFIG;

    // Use shared SSR placeholder handler if provided, otherwise create new one if feature flag is enabled
    if (config.ssrPlaceholderHandler) {
      this.ssrPlaceholderHandler = config.ssrPlaceholderHandler;
    } else {
      var _config$SSRConfig$ena, _config$SSRConfig;
      this.ssrPlaceholderHandler = new _ssrPlaceholders.SSRPlaceholderHandlers({
        enablePageLayoutPlaceholder: (_config$SSRConfig$ena = (_config$SSRConfig = config.SSRConfig) === null || _config$SSRConfig === void 0 ? void 0 : _config$SSRConfig.enablePageLayoutPlaceholder) !== null && _config$SSRConfig$ena !== void 0 ? _config$SSRConfig$ena : false
      });
    }
    this.viewportObserver = new _viewportObserver.default({
      onChange: function onChange(onChangeArg) {
        var time = onChangeArg.time,
          type = onChangeArg.type,
          elementRef = onChangeArg.elementRef,
          visible = onChangeArg.visible,
          rect = onChangeArg.rect,
          previousRect = onChangeArg.previousRect,
          mutationData = onChangeArg.mutationData;
        var elementName = 'unknown';
        var element = elementRef.deref();
        if (element) {
          elementName = _this.getElementName(element);
        }
        var data = {
          type: type,
          elementName: elementName,
          rect: rect,
          previousRect: previousRect,
          visible: visible,
          attributeName: mutationData === null || mutationData === void 0 ? void 0 : mutationData.attributeName,
          oldValue: mutationData === null || mutationData === void 0 ? void 0 : mutationData.oldValue,
          newValue: mutationData === null || mutationData === void 0 ? void 0 : mutationData.newValue
        };
        if (element) {
          var labelStacks = getLabelStacks(element);
          if (labelStacks) {
            Object.assign(data, {
              labelStacks: labelStacks
            });
          }
        }
        _this.entriesTimeline.push({
          time: time,
          data: data
        });
      },
      // Pass SSR context to ViewportObserver
      getSSRState: function getSSRState() {
        return _this.getSSRState();
      },
      getSSRPlaceholderHandler: function getSSRPlaceholderHandler() {
        return _this.getSSRPlaceholderHandler();
      },
      searchPageConfig: config.searchPageConfig
    });
    this.windowEventObserver = new _windowEventObserver.default({
      onEvent: function onEvent(_ref) {
        var time = _ref.time,
          type = _ref.type;
        // Don't abort press interactions on keydown events, as keydown is expected
        // when users press Enter/Space to activate buttons or other interactive elements
        if (type === 'keydown' && (0, _platformFeatureFlags.fg)('platform_ufo_keypress_interaction_abort')) {
          var interaction = (0, _interactionMetrics.getActiveInteraction)();
          if ((interaction === null || interaction === void 0 ? void 0 : interaction.type) === 'press') {
            return;
          }
        }
        _this.entriesTimeline.push({
          time: time,
          data: {
            type: 'window:event',
            eventType: type
          }
        });
      }
    });
  }
  return (0, _createClass2.default)(VCObserverNew, [{
    key: "start",
    value: function start(_) {
      var _this$viewportObserve,
        _this2 = this;
      // Reset SSR state on start (matches old VCObserver behavior)
      this.ssr = {
        state: SSRState.normal,
        reactRootElement: null,
        // Reset to null (matches old VCObserver)
        renderStart: -1,
        renderStop: -1
      };
      (_this$viewportObserve = this.viewportObserver) === null || _this$viewportObserve === void 0 || _this$viewportObserve.start();
      if ((0, _platformFeatureFlags.fg)('ufo_fix_aborting_interaction_detection_during_ssr')) {
        var _window, _this$windowEventObse;
        this.entriesTimeline.clear();
        if ((_window = window) !== null && _window !== void 0 && _window.__SSR_ABORT_LISTENERS__) {
          var abortListeners = window.__SSR_ABORT_LISTENERS__;
          var aborts = abortListeners.aborts;
          if (aborts && (0, _typeof2.default)(aborts) === 'object') {
            Object.entries(aborts).forEach(function (_ref2) {
              var _ref3 = (0, _slicedToArray2.default)(_ref2, 2),
                key = _ref3[0],
                time = _ref3[1];
              if (typeof time === 'number') {
                _this2.entriesTimeline.push({
                  time: time,
                  data: {
                    type: 'window:event',
                    eventType: key
                  }
                });
              }
            });
          }
        }
        (_this$windowEventObse = this.windowEventObserver) === null || _this$windowEventObse === void 0 || _this$windowEventObse.start();
      } else {
        var _window2, _this$windowEventObse2;
        if ((_window2 = window) !== null && _window2 !== void 0 && _window2.__SSR_ABORT_LISTENERS__) {
          var _abortListeners = window.__SSR_ABORT_LISTENERS__;
          var _aborts = _abortListeners.aborts;
          if (_aborts && (0, _typeof2.default)(_aborts) === 'object') {
            Object.entries(_aborts).forEach(function (_ref4) {
              var _ref5 = (0, _slicedToArray2.default)(_ref4, 2),
                key = _ref5[0],
                time = _ref5[1];
              if (typeof time === 'number') {
                _this2.entriesTimeline.push({
                  time: time,
                  data: {
                    type: 'window:event',
                    eventType: key
                  }
                });
                if ((0, _platformFeatureFlags.fg)('ufo_detect_aborting_interaction_during_ssr')) {
                  hasAbortingEventDuringSSR = true;
                }
              }
            });
          }
        }
        (_this$windowEventObse2 = this.windowEventObserver) === null || _this$windowEventObse2 === void 0 || _this$windowEventObse2.start();
        this.entriesTimeline.clear();
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      var _this$viewportObserve2, _this$windowEventObse3;
      (_this$viewportObserve2 = this.viewportObserver) === null || _this$viewportObserve2 === void 0 || _this$viewportObserve2.stop();
      (_this$windowEventObse3 = this.windowEventObserver) === null || _this$windowEventObse3 === void 0 || _this$windowEventObse3.stop();

      // Clear SSR state on stop (matches old VCObserver behavior)
      this.ssr.reactRootElement = null;
    }

    // SSR related methods
  }, {
    key: "setReactRootElement",
    value: function setReactRootElement(element) {
      this.ssr.reactRootElement = element;
    }
  }, {
    key: "setReactRootRenderStart",
    value: function setReactRootRenderStart() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();
      this.ssr.renderStart = startTime;
      this.ssr.state = SSRState.waitingForFirstRender;
    }
  }, {
    key: "setReactRootRenderStop",
    value: function setReactRootRenderStop() {
      var stopTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();
      this.ssr.renderStop = stopTime;
    }
  }, {
    key: "collectSSRPlaceholders",
    value: function collectSSRPlaceholders() {
      // This is handled by the shared SSRPlaceholderHandlers in VCObserverWrapper
      // Individual observers don't need to implement this
    }

    // Internal methods for ViewportObserver to access SSR state
  }, {
    key: "getSSRState",
    value: function getSSRState() {
      return this.ssr;
    }
  }, {
    key: "getSSRPlaceholderHandler",
    value: function getSSRPlaceholderHandler() {
      return this.ssrPlaceholderHandler;
    }
  }, {
    key: "addSSR",
    value: function addSSR(ssr) {
      this.entriesTimeline.push({
        time: ssr,
        data: {
          elementName: 'SSR',
          type: 'mutation:element',
          rect: {
            height: (0, _getViewportHeight.default)(),
            width: (0, _getViewportWidth.default)(),
            left: 0,
            top: 0,
            x: 0,
            y: 0,
            bottom: (0, _getViewportHeight.default)(),
            right: (0, _getViewportWidth.default)(),
            toJSON: function toJSON() {
              return null;
            }
          },
          visible: true
        }
      });
    }
  }, {
    key: "getVCResult",
    value: function () {
      var _getVCResult = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(param) {
        var start, stop, interactionId, interactionType, interactionAbortReason, isPageVisible, include3p, includeSSRRatio, excludeSmartAnswersInSearch, includeRawData, rawDataStopTime, results, feVCCalculationStartTime, calculator_fy25_03, orderedEntries, fy25_03, calculator_fy26_04, calculator_next, calculatorParams, _yield$Promise$all, _yield$Promise$all2, fy26_04, vcNext, feVCCalculationEndTime, rawVCCalculationStartTime, rawHandler, rawStopTime, rawOrderedEntries, raw;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              start = param.start, stop = param.stop, interactionId = param.interactionId, interactionType = param.interactionType, interactionAbortReason = param.interactionAbortReason, isPageVisible = param.isPageVisible, include3p = param.include3p, includeSSRRatio = param.includeSSRRatio, excludeSmartAnswersInSearch = param.excludeSmartAnswersInSearch, includeRawData = param.includeRawData, rawDataStopTime = param.rawDataStopTime;
              results = [];
              this.addStartEntry(start);
              feVCCalculationStartTime = performance.now();
              calculator_fy25_03 = new _fy25_.default();
              if (param.includeSSRInV3 && param.ssr) {
                this.addSSR(param.ssr);
              }
              orderedEntries = this.entriesTimeline.getOrderedEntries({
                start: start,
                stop: stop
              });
              if (!(0, _config.isVCRevisionEnabled)('fy25.03')) {
                _context.next = 13;
                break;
              }
              _context.next = 10;
              return calculator_fy25_03.calculate({
                orderedEntries: orderedEntries,
                startTime: start,
                stopTime: stop,
                interactionId: interactionId,
                interactionType: interactionType,
                isPostInteraction: this.isPostInteraction,
                include3p: include3p,
                excludeSmartAnswersInSearch: excludeSmartAnswersInSearch,
                includeSSRRatio: includeSSRRatio,
                isPageVisible: isPageVisible,
                interactionAbortReason: interactionAbortReason
              });
            case 10:
              _context.t0 = _context.sent;
              _context.next = 14;
              break;
            case 13:
              _context.t0 = null;
            case 14:
              fy25_03 = _context.t0;
              if (fy25_03) {
                results.push(fy25_03);
              }

              // From TTVC v4 onwards, ensuring that SSR entry is always auto-added, whenever it is configured.
              if (param.ssr) {
                this.addSSR(param.ssr);
              }
              calculator_fy26_04 = new _fy26_.default();
              calculator_next = new _vcNext.default();
              calculatorParams = {
                orderedEntries: orderedEntries,
                startTime: start,
                stopTime: stop,
                interactionId: interactionId,
                interactionType: interactionType,
                isPostInteraction: this.isPostInteraction,
                include3p: include3p,
                excludeSmartAnswersInSearch: excludeSmartAnswersInSearch,
                includeSSRRatio: includeSSRRatio,
                isPageVisible: isPageVisible,
                interactionAbortReason: interactionAbortReason
              };
              _context.next = 22;
              return Promise.all([(0, _config.isVCRevisionEnabled)('fy26.04') ? calculator_fy26_04.calculate(calculatorParams) : null, (0, _config.isVCRevisionEnabled)('next') ? calculator_next.calculate(calculatorParams) : null]);
            case 22:
              _yield$Promise$all = _context.sent;
              _yield$Promise$all2 = (0, _slicedToArray2.default)(_yield$Promise$all, 2);
              fy26_04 = _yield$Promise$all2[0];
              vcNext = _yield$Promise$all2[1];
              if (fy26_04) {
                results.push(fy26_04);
              }
              if (vcNext) {
                results.push(vcNext);
              }
              feVCCalculationEndTime = performance.now();
              if (!(includeRawData && (0, _platformFeatureFlags.fg)('platform_ufo_enable_vc_raw_data'))) {
                _context.next = 39;
                break;
              }
              rawVCCalculationStartTime = performance.now();
              rawHandler = new _rawDataHandler.default(); // Use rawDataStopTime (end3p) when available to capture observations during 3p holds
              rawStopTime = rawDataStopTime !== null && rawDataStopTime !== void 0 ? rawDataStopTime : stop;
              rawOrderedEntries = rawDataStopTime ? this.entriesTimeline.getOrderedEntries({
                start: start,
                stop: rawStopTime
              }) : orderedEntries;
              _context.next = 36;
              return rawHandler.getRawData({
                entries: rawOrderedEntries,
                startTime: start,
                stopTime: rawStopTime,
                isPageVisible: isPageVisible
              });
            case 36:
              raw = _context.sent;
              results.forEach(function (result) {
                delete result.vcDetails;
                delete result.ratios;
              });
              if (raw) {
                raw.rawVCTime = Number((performance.now() - rawVCCalculationStartTime).toFixed(2));
                raw.feVCTime = Number((feVCCalculationEndTime - feVCCalculationStartTime).toFixed(2));
                results.push(raw);
              }
            case 39:
              return _context.abrupt("return", results);
            case 40:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getVCResult(_x) {
        return _getVCResult.apply(this, arguments);
      }
      return getVCResult;
    }()
  }, {
    key: "addStartEntry",
    value: function addStartEntry(startTime) {
      this.entriesTimeline.push({
        time: startTime,
        data: {
          type: 'mutation:element',
          elementName: 'START',
          visible: true,
          rect: {
            x: 0,
            y: 0,
            width: window.innerWidth,
            height: window.innerHeight,
            top: 0,
            left: 0,
            bottom: window.innerHeight,
            right: window.innerWidth,
            toJSON: function toJSON() {
              return {
                x: this.x,
                y: this.y,
                width: this.width,
                height: this.height,
                top: this.top,
                left: this.left,
                bottom: this.bottom,
                right: this.right
              };
            }
          }
        }
      });
    }
  }, {
    key: "getElementName",
    value: function getElementName(element) {
      return (0, _getElementName2.default)(this.selectorConfig, element);
    }
  }]);
}();
function labelStackFromFiber(fiber) {
  var _fiber$child;
  var value = fiber === null || fiber === void 0 || (_fiber$child = fiber.child) === null || _fiber$child === void 0 || (_fiber$child = _fiber$child.memoizedProps) === null || _fiber$child === void 0 ? void 0 : _fiber$child.value;
  return Array.isArray(value === null || value === void 0 ? void 0 : value.labelStack) ? value.labelStack : [];
}
function labelStackToString(labelStack) {
  return labelStack.map(function (label) {
    return label.name;
  }).join('/');
}
function labelStackToSegment(labelStack) {
  var segmentIndex = -1;
  for (var i = labelStack.length - 1; i >= 0; i--) {
    if (labelStack[i].segmentId) {
      segmentIndex = i;
      break;
    }
  }
  return labelStack.slice(0, segmentIndex + 1).map(function (label) {
    return label.name;
  }).join('/');
}
function traverseFiber(fiber) {
  var segment = 'unknown';
  var labelStackString = 'unknown';
  var currentFiber = fiber;
  while (currentFiber) {
    if (currentFiber.type) {
      var componentName = currentFiber.type.displayName || currentFiber.type.name;
      if (componentName === 'UFOSegment' || componentName === 'UFOLabel') {
        var labelStack = labelStackFromFiber(currentFiber);
        labelStackString = labelStackToString(labelStack) || 'unknown';
        segment = labelStackToSegment(labelStack) || 'unknown';
        break;
      }
    }
    currentFiber = currentFiber.return;
  }
  return {
    segment: segment,
    labelStack: labelStackString
  };
}
function getLabelStacks(element) {
  var reactFiberKey = Object.keys(element).find(function (key) {
    return key.startsWith('__reactFiber$');
  });
  if (!reactFiberKey) {
    return null;
  }
  var fiber = element[reactFiberKey];
  return fiber ? traverseFiber(fiber) : null;
}