"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _getViewportHeight = _interopRequireDefault(require("../metric-calculator/utils/get-viewport-height"));
var _getViewportWidth = _interopRequireDefault(require("../metric-calculator/utils/get-viewport-width"));
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var ABORTING_WINDOW_EVENT = ['wheel', 'scroll', 'keydown', 'resize'];
var MAX_OBSERVATIONS = 200;
function isWindowEventEntryData(data) {
  return data.type === 'window:event' && 'eventType' in data;
}
var RawDataHandler = exports.default = /*#__PURE__*/function () {
  function RawDataHandler() {
    (0, _classCallCheck2.default)(this, RawDataHandler);
    (0, _defineProperty2.default)(this, "revisionNo", 'raw-handler');
  }
  return (0, _createClass2.default)(RawDataHandler, [{
    key: "getVCCleanStatus",
    value: function getVCCleanStatus(filteredEntries) {
      var dirtyReason = '';
      var abortTimestamp = -1;
      var hasAbortEvent = filteredEntries.some(function (entry) {
        if (entry.data.type === 'window:event') {
          var data = entry.data;
          if (ABORTING_WINDOW_EVENT.includes(data.eventType)) {
            dirtyReason = data.eventType === 'keydown' ? 'keypress' : data.eventType;
            abortTimestamp = Math.round(entry.time);
            return true;
          }
        }
        return false;
      });
      if (hasAbortEvent && dirtyReason) {
        return {
          isVCClean: false,
          dirtyReason: dirtyReason,
          abortTimestamp: abortTimestamp
        };
      }
      return {
        isVCClean: true
      };
    }
  }, {
    key: "getRawData",
    value: function () {
      var _getRawData = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(_ref) {
        var entries, startTime, stopTime, isPageVisible, isVCClean, dirtyReason, getVCCleanStatusResult, viewportEntries, windowEventEntries, targetNameToIdMap, elementMapEntriesMap, nextElementId, typeMap, typeMapEntriesMap, nextTypeId, attributeMap, attributeEntriesMap, nextAttributeId, eventTypeMap, eventTypeMapEntriesMap, nextEventTypeId, rawObservations, rawEventObservations, firstObservation, lastObservations, ssrEid, ssrObservation, ssrAlreadyIncluded, referencedEids, referencedChgs, referencedAtts, _iterator, _step, observation, _iterator2, _step2, eid, _iterator3, _step3, chg, _iterator4, _step4, att, firstEventObservation, lastEventObservations, referencedEvts, _iterator5, _step5, _observation, _iterator6, _step6, evt, result;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              entries = _ref.entries, startTime = _ref.startTime, stopTime = _ref.stopTime, isPageVisible = _ref.isPageVisible;
              getVCCleanStatusResult = this.getVCCleanStatus(entries);
              isVCClean = getVCCleanStatusResult.isVCClean;
              dirtyReason = getVCCleanStatusResult.dirtyReason;
              if (isPageVisible) {
                _context.next = 6;
                break;
              }
              return _context.abrupt("return", {
                revision: this.revisionNo,
                clean: false,
                'metric:vc90': null,
                abortReason: 'browser_backgrounded',
                abortTimestamp: -1,
                viewport: {
                  w: (0, _getViewportWidth.default)(),
                  h: (0, _getViewportHeight.default)()
                }
              });
            case 6:
              viewportEntries = entries.filter(function (entry) {
                return entry.time >= startTime && entry.time <= stopTime && entry.data && entry.data.visible;
              });
              windowEventEntries = entries.filter(function (entry) {
                return entry.time >= startTime && entry.time <= stopTime && entry.data && isWindowEventEntryData(entry.data);
              });
              targetNameToIdMap = new Map();
              elementMapEntriesMap = {};
              nextElementId = 1;
              typeMap = new Map();
              typeMapEntriesMap = {};
              nextTypeId = 1;
              attributeMap = new Map();
              attributeEntriesMap = {};
              nextAttributeId = 1;
              eventTypeMap = new Map();
              eventTypeMapEntriesMap = {};
              nextEventTypeId = 1;
              rawObservations = viewportEntries.map(function (entry) {
                var viewportEntry = entry.data;
                var targetName = viewportEntry.elementName || '';
                var type = viewportEntry.type || '';
                var rect = viewportEntry.rect;
                var attributeName = viewportEntry.attributeName || '';
                var eid = targetNameToIdMap.get(viewportEntry.elementName || '') || 0;
                if (eid === 0) {
                  eid = nextElementId;
                  nextElementId += 1;
                  targetNameToIdMap.set(targetName, eid);
                  elementMapEntriesMap[eid] = targetName;
                }
                var chg = typeMap.get(type || '') || 0;
                if (chg === 0) {
                  chg = nextTypeId;
                  nextTypeId += 1;
                  typeMap.set(type, chg);
                  typeMapEntriesMap[chg] = type;
                }
                var att = 0;
                if (attributeName) {
                  att = attributeMap.get(attributeName) || 0;
                  if (att === 0) {
                    att = nextAttributeId;
                    nextAttributeId += 1;
                    attributeMap.set(attributeName, att);
                    attributeEntriesMap[att] = attributeName;
                  }
                }
                var observation = _objectSpread({
                  t: Math.round(entry.time - startTime),
                  r: [Math.round(rect.left * 10) / 10, Math.round(rect.top * 10) / 10, Math.round(rect.right * 10) / 10, Math.round(rect.bottom * 10) / 10],
                  chg: chg,
                  eid: eid || 0
                }, att > 0 ? {
                  att: att
                } : {});
                return observation;
              });
              rawEventObservations = windowEventEntries.map(function (entry) {
                var windowEventEntry = entry.data;
                var eventType = windowEventEntry.eventType;
                var evtId = eventTypeMap.get(eventType) || 0;
                if (evtId === 0) {
                  evtId = nextEventTypeId;
                  nextEventTypeId += 1;
                  eventTypeMap.set(eventType, evtId);
                  eventTypeMapEntriesMap[evtId] = eventType;
                }
                var eventObservation = {
                  t: Math.round(entry.time - startTime),
                  evt: evtId
                };
                return eventObservation;
              }); // If the number of observations is greater than the maximum allowed, we need to trim the observations to the maximum allowed.
              // We do this by keeping the first observation, the SSR observation (if present), and the last MAX_OBSERVATIONS observations.
              // We then collect the referenced IDs from the remaining observations and remove the unreferenced entries from the maps
              if (rawObservations.length > MAX_OBSERVATIONS) {
                firstObservation = rawObservations[0];
                lastObservations = rawObservations.slice(-MAX_OBSERVATIONS); // Find the SSR observation by looking up the eid that corresponds to 'SSR' element name
                ssrEid = targetNameToIdMap.get('SSR');
                ssrObservation = ssrEid ? rawObservations.find(function (obs) {
                  return obs.eid === ssrEid && obs !== firstObservation;
                }) : undefined; // Include SSR observation if it exists and is not already in the kept observations
                ssrAlreadyIncluded = ssrObservation && lastObservations.some(function (obs) {
                  return obs === ssrObservation;
                });
                rawObservations = [firstObservation].concat((0, _toConsumableArray2.default)(ssrObservation && !ssrAlreadyIncluded ? [ssrObservation] : []), (0, _toConsumableArray2.default)(lastObservations));

                // Collect referenced IDs from remaining observations
                referencedEids = new Set();
                referencedChgs = new Set();
                referencedAtts = new Set();
                _iterator = _createForOfIteratorHelper(rawObservations);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    observation = _step.value;
                    if (observation.eid > 0) {
                      referencedEids.add(observation.eid);
                    }
                    if (typeof observation.chg === 'number' && observation.chg > 0) {
                      referencedChgs.add(observation.chg);
                    }
                    if (observation.att !== undefined && observation.att > 0) {
                      referencedAtts.add(observation.att);
                    }
                  }

                  // Remove unreferenced entries from maps
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                _iterator2 = _createForOfIteratorHelper(Object.keys(elementMapEntriesMap).map(Number));
                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    eid = _step2.value;
                    if (!referencedEids.has(eid)) {
                      delete elementMapEntriesMap[eid];
                    }
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }
                _iterator3 = _createForOfIteratorHelper(Object.keys(typeMapEntriesMap).map(Number));
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    chg = _step3.value;
                    if (!referencedChgs.has(chg)) {
                      delete typeMapEntriesMap[chg];
                    }
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
                _iterator4 = _createForOfIteratorHelper(Object.keys(attributeEntriesMap).map(Number));
                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                    att = _step4.value;
                    if (!referencedAtts.has(att)) {
                      delete attributeEntriesMap[att];
                    }
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }
              }

              // If the number of event observations is greater than the maximum allowed, we need to trim the event observations to the maximum allowed.
              // We do this by keeping the first observation and the last MAX_OBSERVATIONS observations.
              // We then collect the referenced IDs from the remaining observations and remove the unreferenced entries from the maps
              if (rawEventObservations.length > MAX_OBSERVATIONS) {
                firstEventObservation = rawEventObservations[0];
                lastEventObservations = rawEventObservations.slice(-MAX_OBSERVATIONS);
                rawEventObservations = [firstEventObservation].concat((0, _toConsumableArray2.default)(lastEventObservations));

                // Collect referenced IDs from remaining observations
                referencedEvts = new Set();
                _iterator5 = _createForOfIteratorHelper(rawEventObservations);
                try {
                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                    _observation = _step5.value;
                    if (_observation.evt > 0) {
                      referencedEvts.add(_observation.evt);
                    }
                  }

                  // Remove unreferenced entries from maps
                } catch (err) {
                  _iterator5.e(err);
                } finally {
                  _iterator5.f();
                }
                _iterator6 = _createForOfIteratorHelper(Object.keys(eventTypeMapEntriesMap).map(Number));
                try {
                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                    evt = _step6.value;
                    if (!referencedEvts.has(evt)) {
                      delete eventTypeMapEntriesMap[evt];
                    }
                  }
                } catch (err) {
                  _iterator6.e(err);
                } finally {
                  _iterator6.f();
                }
              }
              result = {
                revision: this.revisionNo,
                clean: isVCClean,
                'metric:vc90': null,
                rawData: {
                  obs: rawObservations !== null && rawObservations !== void 0 ? rawObservations : undefined,
                  eid: elementMapEntriesMap !== null && elementMapEntriesMap !== void 0 ? elementMapEntriesMap : undefined,
                  chg: typeMapEntriesMap !== null && typeMapEntriesMap !== void 0 ? typeMapEntriesMap : undefined,
                  att: attributeEntriesMap !== null && attributeEntriesMap !== void 0 ? attributeEntriesMap : undefined,
                  evts: rawEventObservations.length > 0 ? rawEventObservations : undefined,
                  evt: Object.keys(eventTypeMapEntriesMap).length > 0 ? eventTypeMapEntriesMap : undefined
                },
                abortReason: dirtyReason,
                abortTimestamp: getVCCleanStatusResult.abortTimestamp,
                viewport: {
                  w: (0, _getViewportWidth.default)(),
                  h: (0, _getViewportHeight.default)()
                }
              };
              return _context.abrupt("return", result);
            case 26:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getRawData(_x) {
        return _getRawData.apply(this, arguments);
      }
      return getRawData;
    }()
  }]);
}();