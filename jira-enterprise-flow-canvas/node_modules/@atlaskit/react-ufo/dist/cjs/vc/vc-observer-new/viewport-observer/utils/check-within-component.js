"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cleanupCaches = cleanupCaches;
exports.default = checkWithinComponent;
var _coinflip = _interopRequireDefault(require("../../../../coinflip"));
var _checkFiberWithinComponent = _interopRequireDefault(require("./check-fiber-within-component"));
var _findFiberWithCache = _interopRequireDefault(require("./find-fiber-with-cache"));
var DEFAULT_MAX_LEVEL = 20;

// Cache cleanup
var callCount = 0;
var CLEANUP_THRESHOLD = 50;
function maybeCleanup(resultCache) {
  callCount++;
  if (callCount >= CLEANUP_THRESHOLD && (0, _coinflip.default)(0.3)) {
    cleanupCaches(resultCache);
  }
}
function cleanupCaches(resultCache) {
  resultCache = new WeakMap();
  callCount = 0;
  return resultCache;
}
function checkWithinComponent(node, targetComponentName, resultCache) {
  maybeCleanup(resultCache);
  if (resultCache.has(node)) {
    var _resultCache$get;
    return {
      isWithin: (_resultCache$get = resultCache.get(node)) !== null && _resultCache$get !== void 0 ? _resultCache$get : false
    };
  }
  var fiber = null;
  var checkedNodes = [];

  // Always use cached fiber strategy to handle non-React elements reliably
  fiber = (0, _findFiberWithCache.default)(node, DEFAULT_MAX_LEVEL, checkedNodes);
  if (!fiber) {
    checkedNodes.forEach(function (checkedNode) {
      resultCache.set(checkedNode, false);
    });
    return {
      isWithin: false
    };
  }
  var isWithin = (0, _checkFiberWithinComponent.default)(fiber, targetComponentName, DEFAULT_MAX_LEVEL);
  checkedNodes.forEach(function (checkedNode) {
    resultCache.set(checkedNode, isWithin);
  });
  return {
    isWithin: isWithin
  };
}