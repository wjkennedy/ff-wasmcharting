"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Observers = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _vcUtils = require("../media-wrapper/vc-utils");
var _isNonVisualStyleMutation = _interopRequireDefault(require("./non-visual-styles/is-non-visual-style-mutation"));
var _rllPlaceholders = require("./rll-placeholders");
var _ssrPlaceholders = require("./ssr-placeholders");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var state = {
  normal: 1,
  waitingForFirstRender: 2,
  ignoring: 3
};
function isElementVisible(target) {
  if (!target || typeof target.checkVisibility !== 'function') {
    return true;
  }
  var isVisible = target.checkVisibility({
    contentVisibilityAuto: true,
    opacityProperty: true,
    visibilityProperty: true
  });
  return isVisible;
}
var Observers = exports.Observers = /*#__PURE__*/function () {
  function Observers(opts) {
    var _this = this;
    (0, _classCallCheck2.default)(this, Observers);
    (0, _defineProperty2.default)(this, "observedMutations", new WeakMap());
    (0, _defineProperty2.default)(this, "elementsInView", new Set());
    (0, _defineProperty2.default)(this, "callbacks", new Set());
    (0, _defineProperty2.default)(this, "totalTime", 0);
    (0, _defineProperty2.default)(this, "_startMeasureTimestamp", -1);
    (0, _defineProperty2.default)(this, "ssr", {
      state: state.normal,
      reactRootElement: null,
      renderStart: -1,
      renderStop: -1
    });
    (0, _defineProperty2.default)(this, "selectorConfig", {
      id: false,
      testId: false,
      role: false,
      className: true,
      dataVC: true
    });
    (0, _defineProperty2.default)(this, "subscribeResults", function (cb) {
      _this.callbacks.add(cb);
    });
    (0, _defineProperty2.default)(this, "observeElement", function (node, mutation, type, ignoreReason, attributeName) {
      var _this$intersectionObs;
      var oldValue = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var newValue = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
      (_this$intersectionObs = _this.intersectionObserver) === null || _this$intersectionObs === void 0 || _this$intersectionObs.observe(node);
      _this.observedMutations.set(node, {
        mutation: mutation,
        ignoreReason: ignoreReason,
        type: type,
        attributeName: attributeName,
        oldValue: oldValue,
        newValue: newValue
      });
    });
    this.selectorConfig = _objectSpread(_objectSpread({}, this.selectorConfig), opts.selectorConfig);
    this.intersectionObserver = this.getIntersectionObserver();
    this.mutationObserver = this.getMutationObserver();

    // Use shared SSR placeholder handler if provided, otherwise create new one
    if (opts.ssrPlaceholderHandler) {
      this.ssrPlaceholderHandler = opts.ssrPlaceholderHandler;
    } else {
      var _opts$SSRConfig;
      this.ssrPlaceholderHandler = new _ssrPlaceholders.SSRPlaceholderHandlers({
        enablePageLayoutPlaceholder: (_opts$SSRConfig = opts.SSRConfig) === null || _opts$SSRConfig === void 0 ? void 0 : _opts$SSRConfig.enablePageLayoutPlaceholder
      });
    }
  }
  return (0, _createClass2.default)(Observers, [{
    key: "isBrowserSupported",
    value: function isBrowserSupported() {
      return typeof window.IntersectionObserver === 'function' && typeof window.MutationObserver === 'function';
    }
  }, {
    key: "observe",
    value: function observe() {
      var _this$mutationObserve;
      this.totalTime = 0;
      this.ssr = {
        state: state.normal,
        reactRootElement: null,
        renderStart: -1,
        renderStop: -1
      };
      (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 || _this$mutationObserve.observe(document.body, {
        attributeFilter: ['hidden', 'style', 'src', 'class'],
        attributeOldValue: true,
        attributes: true,
        childList: true,
        subtree: true
      });
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      var _this$mutationObserve2, _this$intersectionObs2;
      (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 || _this$mutationObserve2.disconnect();
      (_this$intersectionObs2 = this.intersectionObserver) === null || _this$intersectionObs2 === void 0 || _this$intersectionObs2.disconnect();
      this.observedMutations = new WeakMap();
      this.elementsInView.clear();
      this.callbacks.clear();
      this.ssr.reactRootElement = null;
      this.ssrPlaceholderHandler.clear();
    }
  }, {
    key: "getTotalTime",
    value: function getTotalTime() {
      return this.totalTime;
    }
  }, {
    key: "setReactRootElement",
    value: function setReactRootElement(element) {
      this.ssr.reactRootElement = element;
    }
  }, {
    key: "setReactRootRenderStart",
    value: function setReactRootRenderStart() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();
      this.ssr.renderStart = startTime;
      this.ssr.state = state.waitingForFirstRender;
    }
  }, {
    key: "setReactRootRenderStop",
    value: function setReactRootRenderStop() {
      var stopTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();
      this.ssr.renderStop = stopTime;
    }
  }, {
    key: "getMutationObserver",
    value: function getMutationObserver() {
      var _this2 = this;
      if (!this.isBrowserSupported()) {
        return null;
      }
      return new MutationObserver(function (mutations) {
        _this2.measureStart();
        mutations.forEach(function (mutation) {
          // patching element if timestamp not automatically added
          // eslint-disable-next-line no-param-reassign
          mutation.timestamp = mutation.timestamp === undefined ? performance.now() : mutation.timestamp;
          var ignoreReason = '';
          if (_this2.ssr.state === state.waitingForFirstRender && mutation.timestamp > _this2.ssr.renderStart && mutation.target === _this2.ssr.reactRootElement) {
            _this2.ssr.state = state.ignoring;
            if (_this2.ssr.renderStop === -1) {
              // arbitrary 500ms DOM update window
              _this2.ssr.renderStop = mutation.timestamp + 500;
            }
            ignoreReason = 'ssr-hydration';
          }
          if (_this2.ssr.state === state.ignoring && mutation.timestamp > _this2.ssr.renderStart && mutation.target === _this2.ssr.reactRootElement) {
            if (mutation.timestamp <= _this2.ssr.renderStop) {
              ignoreReason = 'ssr-hydration';
            } else {
              _this2.ssr.state = state.normal;
            }
          }
          if (mutation.type === 'childList') {
            mutation.addedNodes.forEach(function (node) {
              if ((0, _vcUtils.isContainedWithinMediaWrapper)(node)) {
                ignoreReason = 'image';
              }
              if (node instanceof HTMLElement
              /* && !node instanceof HTMLStyleElement && !node instanceof HTMLScriptElement && !node instanceof HTMLLinkElement */) {
                if (_this2.ssrPlaceholderHandler.isPlaceholder(node) || _this2.ssrPlaceholderHandler.isPlaceholderIgnored(node)) {
                  _this2.ssrPlaceholderHandler.checkIfExistedAndSizeMatching(node).then(function (result) {
                    if (result === false) {
                      _this2.observeElement(node, mutation, 'html', ignoreReason);
                    }
                  });
                  return;
                }
                if (_this2.ssrPlaceholderHandler.isPlaceholderReplacement(node) || _this2.ssrPlaceholderHandler.isPlaceholderIgnored(node)) {
                  _this2.ssrPlaceholderHandler.validateReactComponentMatchToPlaceholder(node).then(function (result) {
                    if (result === false) {
                      _this2.observeElement(node, mutation, 'html', ignoreReason);
                    }
                  });
                  return;
                }
                _this2.observeElement(node, mutation, 'html', ignoreReason);
              }
              if (node instanceof Text && node.parentElement != null) {
                _this2.observeElement(node.parentElement, mutation, 'text', ignoreReason);
              }
            });
            mutation.removedNodes.forEach(function (node) {
              if (node instanceof Element) {
                var _this2$intersectionOb;
                _this2.elementsInView.delete(node);
                (_this2$intersectionOb = _this2.intersectionObserver) === null || _this2$intersectionOb === void 0 || _this2$intersectionOb.unobserve(node);
              }
            });
          } else if (mutation.type === 'attributes') {
            if (mutation.target instanceof HTMLElement) {
              var _mutation$oldValue;
              var attributeName = mutation.attributeName;
              /*
              	"MutationObserver was explicitly designed to work that way, but I can't now recall the reasoning.
              	I think it might have been something along the lines that for consistency every setAttribute call should create a record.
              	Conceptually there is after all a mutation: there is an old value replaced with a new one,
              	and whether or not they are the same doesn't really matter.
              	And Custom elements should work the same way as MutationObserver."
              	https://github.com/whatwg/dom/issues/520#issuecomment-336574796
              */
              var oldValue = (_mutation$oldValue = mutation.oldValue) !== null && _mutation$oldValue !== void 0 ? _mutation$oldValue : undefined;
              var newValue = attributeName ? mutation.target.getAttribute(attributeName) : undefined;
              if (oldValue !== newValue) {
                if ((0, _isNonVisualStyleMutation.default)(mutation)) {
                  ignoreReason = 'non-visual-style';
                }
                if ((0, _vcUtils.isContainedWithinMediaWrapper)(mutation.target)) {
                  ignoreReason = 'image';
                }
                _this2.observeElement(mutation.target, mutation, 'attr', ignoreReason, attributeName, oldValue, newValue);
              }
            }
          }
        });
      });
    }
  }, {
    key: "getElementName",
    value: function getElementName(element) {
      try {
        var tagName = element.localName;
        var dataVCAttr = element.getAttribute('data-vc');
        var dataVC = this.selectorConfig.dataVC && dataVCAttr ? "[data-vc=\"".concat(dataVCAttr, "\"]") : '';
        var id = this.selectorConfig.id && element.id ? "#".concat(element.id) : '';
        var testId = this.selectorConfig.testId ? element.getAttribute('data-testid') || element.getAttribute('data-test-id') : '';
        testId = testId ? "[testid=".concat(testId, "]") : '';
        var role = this.selectorConfig.role ? element.getAttribute('role') : '';
        role = role ? "[role=".concat(role, "]") : '';
        var classList = this.selectorConfig.className ? Array.from(element.classList).join('.') : '';
        classList = classList === '' ? '' : ".".concat(classList);
        var attrs = dataVC ? dataVC : [id, testId, role].join('');
        var idString = '';
        if (attrs === '' && classList === '') {
          var parent = element.parentElement ? this.getElementName(element.parentElement) : 'unknown';
          idString = "".concat(parent, " > ").concat(tagName);
        } else {
          idString = [tagName, attrs || classList].join('');
        }
        return idString;
      } catch (_unused) {
        return 'error';
      }
    }
  }, {
    key: "getIntersectionObserver",
    value: function getIntersectionObserver() {
      var _this3 = this;
      if (!this.isBrowserSupported()) {
        return null;
      }
      return new IntersectionObserver(function (entries) {
        _this3.measureStart();
        entries.forEach(function (_ref) {
          var isIntersecting = _ref.isIntersecting,
            ir = _ref.intersectionRect,
            target = _ref.target;
          var data = _this3.observedMutations.get(target);
          _this3.observedMutations.delete(target);
          if (isIntersecting && ir.width > 0 && ir.height > 0) {
            if (!(target instanceof HTMLElement)) {
              return;
            }
            if (!(data !== null && data !== void 0 && data.mutation)) {
              // ignore intersection report without recent mutation
              return;
            }
            if (!isElementVisible(target)) {
              data.ignoreReason = 'not-visible';
            }
            if (_rllPlaceholders.RLLPlaceholderHandlers.getInstance().isRLLPlaceholderHydration(ir)) {
              data.ignoreReason = 'rll-placeholder';
            }
            _this3.callbacks.forEach(function (callback) {
              var elementName;
              try {
                elementName = _this3.getElementName(target);
              } catch (_unused2) {
                elementName = 'error';
              }
              callback(data.mutation.timestamp || performance.now(), ir, elementName, target, data.type, data.ignoreReason, data.attributeName, data.oldValue, data.newValue);
            });
            _this3.elementsInView.add(target);
          } else {
            _this3.elementsInView.delete(target);
          }
        });
        _this3.measureStop();
      });
    }
  }, {
    key: "measureStart",
    value: function measureStart() {
      this._startMeasureTimestamp = performance.now();
    }
  }, {
    key: "measureStop",
    value: function measureStop() {
      if (this._startMeasureTimestamp === -1) {
        return;
      }
      this.totalTime += performance.now() - this._startMeasureTimestamp;
      this._startMeasureTimestamp = -1;
    }
  }]);
}();