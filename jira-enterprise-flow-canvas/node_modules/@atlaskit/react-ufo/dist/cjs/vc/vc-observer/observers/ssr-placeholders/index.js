"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SSRPlaceholderHandlers = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var ANCESTOR_LOOKUP_LIMIT = 10;
var PAGE_LAYOUT_ID = 'page-layout.root';
var SSRPlaceholderHandlers = exports.SSRPlaceholderHandlers = /*#__PURE__*/function () {
  function SSRPlaceholderHandlers(_ref) {
    var _this = this;
    var _ref$enablePageLayout = _ref.enablePageLayoutPlaceholder,
      enablePageLayoutPlaceholder = _ref$enablePageLayout === void 0 ? false : _ref$enablePageLayout;
    (0, _classCallCheck2.default)(this, SSRPlaceholderHandlers);
    (0, _defineProperty2.default)(this, "staticPlaceholders", new Map());
    (0, _defineProperty2.default)(this, "callbacks", new Map());
    (0, _defineProperty2.default)(this, "getSizeCallbacks", new Map());
    (0, _defineProperty2.default)(this, "reactValidateCallbacks", new Map());
    (0, _defineProperty2.default)(this, "EQUALITY_THRESHOLD", 1);
    (0, _defineProperty2.default)(this, "getPlaceholderId", function (el) {
      var _el$dataset;
      var ssrPlaceholderId = el === null || el === void 0 || (_el$dataset = el.dataset) === null || _el$dataset === void 0 ? void 0 : _el$dataset.ssrPlaceholder;
      if (!!ssrPlaceholderId) {
        return ssrPlaceholderId;
      }
      if (_this.enablePageLayoutPlaceholder && (el === null || el === void 0 ? void 0 : el.dataset.testid) === PAGE_LAYOUT_ID) {
        return PAGE_LAYOUT_ID;
      }
      return '';
    });
    (0, _defineProperty2.default)(this, "getPlaceholderReplacementId", function (el) {
      var _el$dataset2;
      var ssrPlaceholderReplaceId = el === null || el === void 0 || (_el$dataset2 = el.dataset) === null || _el$dataset2 === void 0 ? void 0 : _el$dataset2.ssrPlaceholderReplace;
      if (!!ssrPlaceholderReplaceId) {
        return ssrPlaceholderReplaceId;
      }
      if (_this.enablePageLayoutPlaceholder && (el === null || el === void 0 ? void 0 : el.dataset.testid) === PAGE_LAYOUT_ID) {
        return PAGE_LAYOUT_ID;
      }
      return '';
    });
    (0, _defineProperty2.default)(this, "intersectionObserverCallback", function (_ref2) {
      var _this$intersectionObs;
      var target = _ref2.target,
        boundingClientRect = _ref2.boundingClientRect;
      (_this$intersectionObs = _this.intersectionObserver) === null || _this$intersectionObs === void 0 || _this$intersectionObs.unobserve(target);
      if (!(target instanceof HTMLElement)) {
        // impossible case - keep typescript healthy
        return;
      }
      var staticKey = _this.getPlaceholderId(target);
      if (staticKey) {
        if (_this.staticPlaceholders.has(staticKey) && _this.callbacks.has(staticKey)) {
          // validation
          var _resolve = _this.callbacks.get(staticKey);
          if (!_resolve) {
            return;
          }
          var rect = _this.staticPlaceholders.get(staticKey);
          var hasSameSizePosition = _this.hasSameSizePosition(rect, boundingClientRect);
          if (hasSameSizePosition || _this.isDummyRect(rect)) {
            _resolve(hasSameSizePosition);
          } else {
            requestAnimationFrame(function () {
              var targetRect = _this.getEffectiveBoundingRect(target);
              var hasSameSizePosition = _this.hasSameSizePosition(rect, targetRect);
              _resolve(hasSameSizePosition);
            });
          }
          _this.callbacks.delete(staticKey);
        }
      } else {
        var key = _this.getPlaceholderReplacementId(target);
        var _resolve2 = _this.reactValidateCallbacks.get(key);
        if (!_resolve2) {
          return;
        }
        var _rect = _this.staticPlaceholders.get(key);
        var _hasSameSizePosition = _this.hasSameSizePosition(_rect, boundingClientRect);
        if (_hasSameSizePosition || _this.isDummyRect(_rect)) {
          _resolve2(_hasSameSizePosition);
        } else {
          requestAnimationFrame(function () {
            var targetRect = _this.getEffectiveBoundingRect(target);
            var hasSameSizePosition = _this.hasSameSizePosition(_rect, targetRect);
            _resolve2(hasSameSizePosition);
          });
        }
        _this.staticPlaceholders.delete(staticKey);
        _this.reactValidateCallbacks.delete(staticKey);
      }
    });
    if (typeof IntersectionObserver === 'function') {
      // Only instantiate the IntersectionObserver if it's supported
      this.intersectionObserver = new IntersectionObserver(function (entries) {
        return entries.filter(function (entry) {
          return entry.intersectionRatio > 0;
        }).forEach(_this.intersectionObserverCallback);
      });
    }
    this.enablePageLayoutPlaceholder = enablePageLayoutPlaceholder;
    if (window.document) {
      try {
        // Collect initial placeholders using SSR dimensions
        this.collectPlaceholdersInternal();
      } catch (_unused) {} finally {
        delete window.__SSR_PLACEHOLDERS_DIMENSIONS__;
      }
    }
  }
  return (0, _createClass2.default)(SSRPlaceholderHandlers, [{
    key: "clear",
    value: function clear() {
      this.staticPlaceholders = new Map();
      this.callbacks = new Map();
      this.getSizeCallbacks = new Map();
      this.reactValidateCallbacks = new Map();
    }
  }, {
    key: "collectPlaceholdersInternal",
    value: function collectPlaceholdersInternal() {
      var _this2 = this;
      var selector = this.enablePageLayoutPlaceholder ? '[data-ssr-placeholder],[data-testid="page-layout.root"]' : '[data-ssr-placeholder]';
      var existingElements = document.querySelectorAll(selector);
      existingElements.forEach(function (el) {
        var placeholderId = el instanceof HTMLElement && _this2.getPlaceholderId(el);
        if (placeholderId && !_this2.staticPlaceholders.has(placeholderId)) {
          var _window$__SSR_PLACEHO, _this2$intersectionOb;
          var width = -1;
          var height = -1;
          var x = -1;
          var y = -1;

          // Use SSR dimensions from window global if available
          var boundingClientRect = (_window$__SSR_PLACEHO = window.__SSR_PLACEHOLDERS_DIMENSIONS__) === null || _window$__SSR_PLACEHO === void 0 ? void 0 : _window$__SSR_PLACEHO[placeholderId];
          if (boundingClientRect) {
            width = boundingClientRect.width;
            height = boundingClientRect.height;
            x = boundingClientRect.x;
            y = boundingClientRect.y;
          } else {
            // Fallback to current bounding rect if SSR dimensions not available
            var rect = el.getBoundingClientRect();
            width = rect.width;
            height = rect.height;
            x = rect.x;
            y = rect.y;
          }
          _this2.staticPlaceholders.set(placeholderId, {
            width: width,
            height: height,
            x: x,
            y: y
          });
          (_this2$intersectionOb = _this2.intersectionObserver) === null || _this2$intersectionOb === void 0 || _this2$intersectionOb.observe(el);
        }
      });
    }

    /**
     * Added this method to be utilised for testing purposes.
     * In production it collection placeholder should only happens on constructor
     */
  }, {
    key: "collectExistingPlaceholders",
    value: function collectExistingPlaceholders() {
      if (!window.document) {
        return;
      }
      try {
        // Collect placeholders using SSR dimensions or fallback to live dimensions
        this.collectPlaceholdersInternal();
      } catch (_unused2) {
        // Silently fail if there are any issues
      } finally {
        delete window.__SSR_PLACEHOLDERS_DIMENSIONS__;
      }
    }
  }, {
    key: "isPlaceholder",
    value: function isPlaceholder(element) {
      return Boolean(this.getPlaceholderId(element));
    }
  }, {
    key: "isPlaceholderReplacement",
    value: function isPlaceholderReplacement(element) {
      return Boolean(this.getPlaceholderReplacementId(element));
    }
  }, {
    key: "isPlaceholderIgnored",
    value: function isPlaceholderIgnored(element) {
      // data-ssr-placeholder-ignored doesn't have a value.
      return 'ssrPlaceholderIgnored' in element.dataset;
    }
  }, {
    key: "isPlaceholderV4",
    value: function isPlaceholderV4(element) {
      var currentElement = element;
      var i = 0;
      while (currentElement && i < ANCESTOR_LOOKUP_LIMIT) {
        if (Boolean(this.getPlaceholderId(currentElement))) {
          return true;
        }
        currentElement = currentElement.parentElement;
        i++;
      }
      return false;
    }
  }, {
    key: "isPlaceholderReplacementV4",
    value: function isPlaceholderReplacementV4(element) {
      var currentElement = element;
      var i = 0;
      while (currentElement && i < ANCESTOR_LOOKUP_LIMIT) {
        if (Boolean(this.getPlaceholderReplacementId(currentElement))) {
          return true;
        }
        currentElement = currentElement.parentElement;
        i++;
      }
      return false;
    }
  }, {
    key: "findNearestPlaceholderContainerIfIgnored",
    value: function findNearestPlaceholderContainerIfIgnored(element) {
      if (!this.isPlaceholderIgnored(element)) {
        return element;
      }
      var ancestor = element.parentElement;
      var i = 0;
      while (ancestor && i < ANCESTOR_LOOKUP_LIMIT) {
        if (this.isPlaceholder(ancestor) || this.isPlaceholderReplacement(ancestor)) {
          return ancestor;
        }
        ancestor = ancestor.parentElement;
        i++;
      }
      return element;
    }
  }, {
    key: "findNearestPlaceholderOrContainer",
    value: function findNearestPlaceholderOrContainer(element) {
      var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ANCESTOR_LOOKUP_LIMIT;
      var ancestor = element;
      if (this.isPlaceholderIgnored(element) && element.parentElement) {
        ancestor = element.parentElement;
      }
      var i = 0;
      while (ancestor && i < limit) {
        if (this.isPlaceholder(ancestor) || this.isPlaceholderReplacement(ancestor)) {
          return ancestor;
        }
        if (ancestor.parentElement) {
          ancestor = ancestor.parentElement;
          i++;
        } else {
          break;
        }
      }
      return element;
    }

    // Validates placeholder match using asynchronous observation and resolves with the result
  }, {
    key: "checkIfExistedAndSizeMatching",
    value: function checkIfExistedAndSizeMatching(el) {
      var _this3 = this;
      el = this.findNearestPlaceholderContainerIfIgnored(el);
      var id = this.getPlaceholderId(el);
      return new Promise(function (resolve) {
        if (!_this3.staticPlaceholders.has(id)) {
          resolve(false);
          return;
        } else {
          var _this3$intersectionOb;
          _this3.callbacks.set(id, resolve);
          (_this3$intersectionOb = _this3.intersectionObserver) === null || _this3$intersectionOb === void 0 || _this3$intersectionOb.observe(el);
        }
      });
    }

    // Validates placeholder match synchronously using stored SSR dimensions and current bounds
  }, {
    key: "checkIfExistedAndSizeMatchingV3",
    value: function checkIfExistedAndSizeMatchingV3(el) {
      el = this.findNearestPlaceholderContainerIfIgnored(el);
      var id = this.getPlaceholderId(el);
      var placeholderRects = this.staticPlaceholders.get(id);
      if (!placeholderRects) {
        return false;
      }
      return this.hasSameSizePosition(placeholderRects, this.getEffectiveBoundingRect(el));
    }
  }, {
    key: "getSize",
    value: function getSize(el) {
      var _this4 = this;
      return new Promise(function (resolve) {
        var _this4$intersectionOb;
        _this4.getSizeCallbacks.set(_this4.getPlaceholderId(el), resolve);
        (_this4$intersectionOb = _this4.intersectionObserver) === null || _this4$intersectionOb === void 0 || _this4$intersectionOb.observe(el);
      });
    }
  }, {
    key: "validateReactComponentMatchToPlaceholder",
    value: function validateReactComponentMatchToPlaceholder(el) {
      var _this5 = this;
      el = this.findNearestPlaceholderContainerIfIgnored(el);
      var id = this.getPlaceholderReplacementId(el);
      return new Promise(function (resolve) {
        if (!_this5.staticPlaceholders.has(id)) {
          resolve(false);
          return;
        } else {
          var _this5$intersectionOb;
          _this5.reactValidateCallbacks.set(id, resolve);
          (_this5$intersectionOb = _this5.intersectionObserver) === null || _this5$intersectionOb === void 0 || _this5$intersectionOb.observe(el);
        }
      });
    }
  }, {
    key: "validateReactComponentMatchToPlaceholderV4",
    value: function validateReactComponentMatchToPlaceholderV4(el) {
      el = this.findNearestPlaceholderOrContainer(el, 2); // We are using 2 due to over-eagerness of the default, only check itself and 1 ancestor
      var id = this.getPlaceholderReplacementId(el);
      return this.staticPlaceholders.has(id);
    }
  }, {
    key: "hasSameSizePosition",
    value: function hasSameSizePosition(rect, boundingClientRect) {
      if (!rect) {
        return false;
      }
      var horizontalCheck = Math.abs(rect.x - boundingClientRect.x) < this.EQUALITY_THRESHOLD && Math.abs(rect.width - boundingClientRect.width) < this.EQUALITY_THRESHOLD;
      var verticalCheck = Math.abs(rect.y - boundingClientRect.y) < this.EQUALITY_THRESHOLD && Math.abs(rect.height - boundingClientRect.height) < this.EQUALITY_THRESHOLD;
      return horizontalCheck && verticalCheck || false;
    }

    /**
     * Gets the effective bounding rectangle for an element, handling display: contents elements
     * by collecting dimensions from their children instead
     */
  }, {
    key: "getEffectiveBoundingRect",
    value: function getEffectiveBoundingRect(el) {
      var computedStyle = window.getComputedStyle(el);

      // If element has display: contents, collect bounding rect from children
      if (computedStyle.display === 'contents') {
        var children = Array.from(el.children);
        if (children.length === 0) {
          // No children, return zero rect
          return new DOMRect(0, 0, 0, 0);
        }

        // Calculate union of all children's bounding rects
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        children.forEach(function (child) {
          var childRect = child.getBoundingClientRect();
          // Skip children with zero dimensions (likely also display: contents)
          if (childRect.width > 0 || childRect.height > 0) {
            minX = Math.min(minX, childRect.left);
            minY = Math.min(minY, childRect.top);
            maxX = Math.max(maxX, childRect.right);
            maxY = Math.max(maxY, childRect.bottom);
          }
        });

        // If no children with dimensions found, return zero rect
        if (minX === Infinity) {
          return new DOMRect(0, 0, 0, 0);
        }
        return new DOMRect(minX, minY, maxX - minX, maxY - minY);
      }

      // Normal element, return its bounding rect
      return el.getBoundingClientRect();
    }
  }, {
    key: "isDummyRect",
    value: function isDummyRect(rect) {
      return rect && rect.width < 0 && rect.height < 0 || false;
    }
  }]);
}();