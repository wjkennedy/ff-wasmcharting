"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__injectThrottleMeasurementForTesting = __injectThrottleMeasurementForTesting;
exports.getEarliestHiddenTiming = getEarliestHiddenTiming;
exports.getHasHiddenTimingBeforeSetup = getHasHiddenTimingBeforeSetup;
exports.getPageVisibilityState = getPageVisibilityState;
exports.getThrottleMeasurements = getThrottleMeasurements;
exports.isOpenedInBackground = isOpenedInBackground;
exports.isTabThrottled = isTabThrottled;
exports.setupHiddenTimingCapture = setupHiddenTimingCapture;
exports.setupThrottleDetection = setupThrottleDetection;
exports.stopThrottleDetection = stopThrottleDetection;
var _bindEventListener = require("bind-event-listener");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var timings = [];
var wasHiddenFlag;
var setupFlag = false;

// Threshold for determining if page was opened in background.
// If setup runs within this time and page is hidden, we assume it was opened in a background tab.
var OPENED_IN_BACKGROUND_THRESHOLD_MS = 100;
var openedInBackground = null;
function isPageHidden() {
  if ('visibilityState' in document) {
    return document.visibilityState === 'hidden';
  } else {
    // @ts-expect-error - Property 'hidden' does not exist on type 'never'.
    return document.hidden;
  }
}
var SIZE = 50;
var insertIndex = 0;
function getEarliestHiddenTiming(startTime, endTime) {
  var _timings$find;
  var earliestHiddenTiming = (_timings$find = timings.find(function (_ref) {
    var hidden = _ref.hidden,
      time = _ref.time;
    return hidden && time > 0 && time >= startTime && time <= endTime;
  })) === null || _timings$find === void 0 ? void 0 : _timings$find.time;
  if (typeof earliestHiddenTiming === 'number') {
    return Math.round(earliestHiddenTiming - startTime);
  }
}
function isOpenedInBackground(interactionType) {
  if (interactionType !== 'page_load') {
    return false;
  }

  // Check native visibility-state entries first (most reliable, Chromium only)
  try {
    var entries = performance.getEntriesByType('visibility-state');
    if (entries.length > 0) {
      return entries.some(function (entry) {
        return entry.name === 'hidden' && entry.startTime <= OPENED_IN_BACKGROUND_THRESHOLD_MS;
      });
    }
  } catch (_unused) {
    // visibility-state not supported (Firefox/Safari)
  }

  // Fallback to cached value from setup (determined using time threshold)
  return openedInBackground === true;
}
function pushHidden(isPageHiddenFlag, time) {
  timings[insertIndex] = {
    time: time !== null && time !== void 0 ? time : performance.now(),
    hidden: isPageHiddenFlag
  };
  insertIndex = (insertIndex + 1) % SIZE;
  wasHiddenFlag = isPageHiddenFlag;
}
function handleChange() {
  var isPageHiddenFlag = isPageHidden();
  if (isPageHiddenFlag) {
    if (!wasHiddenFlag) {
      pushHidden(isPageHiddenFlag);
    }
    wasHiddenFlag = true;
  } else {
    if (wasHiddenFlag) {
      pushHidden(isPageHiddenFlag);
    }
    wasHiddenFlag = false;
  }
}
var hasHiddenTimingBeforeSetup = false;
function getHasHiddenTimingBeforeSetup() {
  return hasHiddenTimingBeforeSetup;
}
function setup() {
  try {
    var results = performance.getEntriesByType('visibility-state');
    results === null || results === void 0 || results.forEach(function (result) {
      if ((0, _platformFeatureFlags.fg)('platform_ufo_use_native_page_visibility_api')) {
        pushHidden(result.name === 'hidden', result.startTime);
      }
      if (result.name === 'hidden') {
        hasHiddenTimingBeforeSetup = true;
      }
    });
  } catch (_unused2) {
    /* do nothing */
    /* note: visibility-state entry types are not available in Firefox/Safari: https://developer.mozilla.org/en-US/docs/Web/API/VisibilityStateEntry#browser_compatibility */
  }
  (0, _bindEventListener.bind)(window, {
    type: 'pageshow',
    listener: handleChange
  });
  (0, _bindEventListener.bind)(window, {
    type: 'pagehide',
    listener: handleChange
  });
  (0, _bindEventListener.bind)(document, {
    type: 'visibilitychange',
    listener: handleChange
  });
}
function setupHiddenTimingCapture() {
  if (!setupFlag) {
    var isPageHiddenFlag = isPageHidden();
    var setupTime = performance.now();

    // Determine if page was opened in background.
    // If we're early in page lifecycle (< threshold) and page is hidden,
    // it's likely the page was opened in a background tab.
    if (openedInBackground === null) {
      openedInBackground = isPageHiddenFlag && setupTime < OPENED_IN_BACKGROUND_THRESHOLD_MS;
    }
    pushHidden(isPageHiddenFlag, 0);
    setup();
    setupFlag = true;
  }
}
function getPageVisibilityState(start, end) {
  // Input validation - return default for invalid inputs
  if (!Number.isFinite(start) || !Number.isFinite(end)) {
    return 'visible';
  }

  // Desirable default value is visible
  if (timings.length === 0) {
    return 'visible';
  }
  var currentSize = timings.length;
  var hiddenState = 'mixed';
  var startIdx = insertIndex;
  var endIdx = insertIndex;

  // currentSize is capped at SIZE.
  for (var i = 0; i < currentSize; i++) {
    var tmpIdx = (insertIndex + i) % currentSize;
    // Add bounds checking before accessing array element
    if (timings[tmpIdx] && timings[tmpIdx].time <= end) {
      endIdx = tmpIdx;
      if (timings[tmpIdx].time <= start) {
        startIdx = tmpIdx;
      }
    }
  }

  // Add bounds checking before accessing timings array
  if (endIdx - startIdx === 0 && timings[startIdx]) {
    hiddenState = timings[startIdx].hidden ? 'hidden' : 'visible';
  }
  return hiddenState;
}

// Throttle detection configuration
// Expected interval for timer checks (in milliseconds)
var THROTTLE_CHECK_INTERVAL_MS = 1000;
// Threshold for considering a timer as throttled (50% drift tolerance)
var THROTTLE_DRIFT_THRESHOLD = 1.5;
// Maximum number of throttle measurements to store (circular buffer)
var THROTTLE_BUFFER_SIZE = 120;
// Circular buffer to store throttle measurements
var throttleMeasurements = [];
var throttleInsertIndex = 0;
var throttleIntervalId = null;
var lastThrottleCheckTime = null;
var throttleSetupDone = false;
function recordThrottleMeasurement(expectedElapsed, actualElapsed) {
  var isThrottled = actualElapsed > expectedElapsed * THROTTLE_DRIFT_THRESHOLD;
  throttleMeasurements[throttleInsertIndex] = {
    time: performance.now(),
    expectedElapsed: expectedElapsed,
    actualElapsed: actualElapsed,
    isThrottled: isThrottled
  };
  throttleInsertIndex = (throttleInsertIndex + 1) % THROTTLE_BUFFER_SIZE;
}
function throttleCheckCallback() {
  var currentTime = performance.now();
  if (lastThrottleCheckTime !== null) {
    var actualElapsed = currentTime - lastThrottleCheckTime;
    recordThrottleMeasurement(THROTTLE_CHECK_INTERVAL_MS, actualElapsed);
  }
  lastThrottleCheckTime = currentTime;
}

/**
 * Sets up the throttle detection mechanism.
 * This should be called early in the page lifecycle.
 * Uses a periodic timer to detect browser throttling by measuring timer drift.
 */
function setupThrottleDetection() {
  if (throttleSetupDone) {
    return;
  }
  throttleSetupDone = true;

  // Record the initial timestamp
  lastThrottleCheckTime = performance.now();

  // Start the periodic timer for throttle detection
  throttleIntervalId = setInterval(throttleCheckCallback, THROTTLE_CHECK_INTERVAL_MS);
}

/**
 * Stops the throttle detection mechanism.
 * Useful for cleanup in tests or when the feature is no longer needed.
 */
function stopThrottleDetection() {
  if (throttleIntervalId !== null) {
    clearInterval(throttleIntervalId);
    throttleIntervalId = null;
  }
  lastThrottleCheckTime = null;
  throttleSetupDone = false;
  throttleMeasurements.length = 0;
  throttleInsertIndex = 0;
}

/**
 * Checks if the tab was throttled at any point during the specified time window.
 * Returns true if any timer measurement showed significant drift (throttling).
 *
 * @param startTime - The start timestamp of the window to check (DOMHighResTimeStamp)
 * @param endTime - The end timestamp of the window to check (DOMHighResTimeStamp)
 * @returns boolean - true if throttling was detected during the time window, false otherwise
 */
function isTabThrottled(startTime, endTime) {
  // Input validation
  if (!Number.isFinite(startTime) || !Number.isFinite(endTime) || startTime >= endTime) {
    return false;
  }

  // No measurements available
  if (throttleMeasurements.length === 0) {
    return false;
  }

  // Check if any measurement within the time window indicates throttling
  for (var i = 0; i < throttleMeasurements.length; i++) {
    var measurement = throttleMeasurements[i];
    if (measurement && measurement.time >= startTime && measurement.time <= endTime && measurement.isThrottled) {
      return true;
    }
  }
  return false;
}

/**
 * Gets detailed throttle information for debugging purposes.
 * Returns all throttle measurements within the specified time window.
 *
 * @param startTime - The start timestamp of the window to check
 * @param endTime - The end timestamp of the window to check
 * @returns Array of throttle measurements within the time window
 */
function getThrottleMeasurements(startTime, endTime) {
  // Input validation
  if (!Number.isFinite(startTime) || !Number.isFinite(endTime) || startTime >= endTime) {
    return [];
  }
  return throttleMeasurements.filter(function (measurement) {
    return measurement && measurement.time >= startTime && measurement.time <= endTime;
  });
}

/**
 * Injects a fake throttle measurement for testing purposes.
 * This allows integration tests to simulate throttling scenarios.
 *
 * @param measurement - The throttle measurement to inject
 */
function __injectThrottleMeasurementForTesting(measurement) {
  throttleMeasurements[throttleInsertIndex] = measurement;
  throttleInsertIndex = (throttleInsertIndex + 1) % THROTTLE_BUFFER_SIZE;
}

// Expose testing API on window for integration tests
if (typeof window !== 'undefined') {
  window.__reactUfoHiddenTiming = {
    __injectThrottleMeasurementForTesting: __injectThrottleMeasurementForTesting
  };
}