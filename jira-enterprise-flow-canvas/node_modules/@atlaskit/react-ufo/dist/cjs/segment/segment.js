"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = UFOSegment;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _react = _interopRequireWildcard(require("react"));
var _scheduler = require("scheduler");
var _uuid = require("uuid");
var _platformFeatureFlags = require("@atlaskit/platform-feature-flags");
var _coinflip = _interopRequireDefault(require("../coinflip"));
var _config = require("../config");
var _experienceTraceIdContext = require("../experience-trace-id-context");
var _interactionContext = _interopRequireDefault(require("../interaction-context"));
var _interactionIdContext = _interopRequireDefault(require("../interaction-id-context"));
var _interactionMetrics = require("../interaction-metrics");
var _routeNameContext = _interopRequireDefault(require("../route-name-context"));
var _shortId = _interopRequireDefault(require("../short-id"));
var _scheduleOnPaint = _interopRequireDefault(require("./schedule-on-paint"));
var _ssrRenderProfiler = _interopRequireDefault(require("./ssr-render-profiler"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; } // eslint-disable-next-line @atlaskit/platform/prefer-crypto-random-uuid -- Use crypto.randomUUID instead
var tryCompleteHandle;
var hasMarkedFirstSegmentLoad = false;

/** A portion of the page we apply measurement to */
function UFOSegment(_ref) {
  var segmentName = _ref.name,
    children = _ref.children,
    _ref$mode = _ref.mode,
    mode = _ref$mode === void 0 ? 'single' : _ref$mode,
    _ref$type = _ref.type,
    type = _ref$type === void 0 ? 'first-party' : _ref$type;
  var parentContext = (0, _react.useContext)(_interactionContext.default);
  var segmentIdMap = (0, _react.useMemo)(function () {
    if (!(parentContext !== null && parentContext !== void 0 && parentContext.segmentIdMap)) {
      return new Map();
    }
    return parentContext.segmentIdMap;
  }, [parentContext]);
  var segmentId = (0, _react.useMemo)(function () {
    if (mode === 'single') {
      return (0, _shortId.default)();
    }
    if (segmentIdMap.has(segmentName)) {
      return segmentIdMap.get(segmentName);
    }
    var newSegmentId = (0, _shortId.default)();
    segmentIdMap.set(segmentName, newSegmentId);
    return newSegmentId;
  }, [mode, segmentName, segmentIdMap]);
  var labelStack = (0, _react.useMemo)(function () {
    return parentContext !== null && parentContext !== void 0 && parentContext.labelStack ? [].concat((0, _toConsumableArray2.default)(parentContext.labelStack), [_objectSpread({
      name: segmentName,
      segmentId: segmentId
    }, type !== 'first-party' ? {
      type: type
    } : {}) // Only pass non-default types (not 'first-party') in payload to reduce size
    ]) : [_objectSpread({
      name: segmentName,
      segmentId: segmentId
    }, type !== 'first-party' ? {
      type: type
    } : {})];
  }, [parentContext, segmentName, segmentId, type]);
  var interactionId = (0, _react.useContext)(_interactionIdContext.default);
  if (interactionId.current != null && !hasMarkedFirstSegmentLoad) {
    (0, _interactionMetrics.markFirstSegmentLoad)(interactionId.current, labelStack, performance.now());
    hasMarkedFirstSegmentLoad = true;
  }
  var interactionContext = (0, _react.useMemo)(function () {
    var lastCompleteEndTime = 0;
    function complete() {
      var endTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();
      if (interactionId.current) {
        if (parentContext) {
          parentContext.complete();
        } else {
          var capturedInteractionId = interactionId.current;
          if (endTime > lastCompleteEndTime) {
            lastCompleteEndTime = endTime;
          }
          if (tryCompleteHandle) {
            var _cancelAnimationFrame;
            (_cancelAnimationFrame = cancelAnimationFrame) === null || _cancelAnimationFrame === void 0 || _cancelAnimationFrame(tryCompleteHandle);
          }
          var onComplete = function onComplete() {
            if (capturedInteractionId === interactionId.current) {
              var _globalThis$document;
              var isPageVisible = (globalThis === null || globalThis === void 0 || (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.visibilityState) === 'visible';
              var canDoRAF = typeof requestAnimationFrame !== 'undefined';
              if (isPageVisible && canDoRAF) {
                tryCompleteHandle = requestAnimationFrame(function () {
                  tryCompleteHandle = requestAnimationFrame(function () {
                    if (capturedInteractionId === interactionId.current) {
                      (0, _interactionMetrics.tryComplete)(interactionId.current, lastCompleteEndTime);
                    }
                  });
                });
              } else {
                (0, _interactionMetrics.tryComplete)(interactionId.current, lastCompleteEndTime);
              }
            }
          };
          (0, _scheduler.unstable_scheduleCallback)(_scheduler.unstable_NormalPriority, onComplete);
        }
      }
    }
    function _internalHold(labelStack, name) {
      var experimental = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (interactionId.current != null) {
        if (parentContext) {
          return parentContext._internalHold(labelStack, name, experimental);
        } else {
          var capturedInteractionId = interactionId.current;
          var disposeHold = (0, _interactionMetrics.addHold)(interactionId.current, labelStack, name, experimental);
          return function () {
            if (capturedInteractionId === interactionId.current) {
              disposeHold();
            }
          };
        }
      }
    }
    function _internalHoldByID(labelStack, id, name, remove) {
      if (interactionId.current != null) {
        if (parentContext) {
          parentContext._internalHoldByID(labelStack, name, id, remove);
          return;
        }
        if (!remove) {
          (0, _interactionMetrics.addHoldByID)(interactionId.current, labelStack, name, id);
        } else {
          (0, _interactionMetrics.removeHoldByID)(interactionId.current, id);
        }
      }
    }
    if (parentContext) {
      return _objectSpread(_objectSpread({}, parentContext), {}, {
        labelStack: labelStack,
        complete: complete
      });
    }
    return {
      labelStack: labelStack,
      segmentIdMap: segmentIdMap,
      hold: function hold() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unknown';
        return this._internalHold(this.labelStack, name);
      },
      holdExperimental: function holdExperimental() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unknown';
        return this._internalHold(this.labelStack, name, true);
      },
      addHoldByID: function addHoldByID(labelStack, id) {
        var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'unknown';
        this._internalHoldByID(labelStack, id, name, false);
      },
      removeHoldByID: function removeHoldByID(labelStack, id) {
        var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'unknown';
        this._internalHoldByID(labelStack, id, name, true);
      },
      tracePress: function tracePress() {
        var _getDoNotAbortActiveP, _getMinorInteractions;
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unknown';
        var timestamp = arguments.length > 1 ? arguments[1] : undefined;
        var minorInteractions = [].concat((0, _toConsumableArray2.default)((_getDoNotAbortActiveP = (0, _config.getDoNotAbortActivePressInteraction)()) !== null && _getDoNotAbortActiveP !== void 0 ? _getDoNotAbortActiveP : []), (0, _toConsumableArray2.default)((_getMinorInteractions = (0, _config.getMinorInteractions)()) !== null && _getMinorInteractions !== void 0 ? _getMinorInteractions : []));
        if (minorInteractions.includes(name)) {
          var _activeInteraction$mi;
          var activeInteraction = (0, _interactionMetrics.getActiveInteraction)();
          activeInteraction === null || activeInteraction === void 0 || (_activeInteraction$mi = activeInteraction.minorInteractions) === null || _activeInteraction$mi === void 0 || _activeInteraction$mi.push({
            name: name,
            startTime: timestamp !== null && timestamp !== void 0 ? timestamp : performance.now()
          });
          return;
        } else if (interactionId.current != null) {
          (0, _interactionMetrics.abortByNewInteraction)(interactionId.current, name);
        }
        var rate = (0, _config.getInteractionRate)(name, 'press');
        if ((0, _coinflip.default)(rate)) {
          var startTimestamp = timestamp !== null && timestamp !== void 0 ? timestamp : performance.now();
          // eslint-disable-next-line @atlaskit/platform/prefer-crypto-random-uuid -- Use crypto.randomUUID instead
          var newId = (0, _uuid.v4)();
          interactionId.current = newId;
          // covered experiences with tracing instrumentation:
          // inline-result.global-issue.create-modal.submit
          // inline-result.global-issue.create-modal-subsequent
          (0, _experienceTraceIdContext.setInteractionActiveTrace)(newId, 'press');
          (0, _interactionMetrics.addNewInteraction)(newId, name, 'press', startTimestamp, rate, this.labelStack, _routeNameContext.default.current, (0, _experienceTraceIdContext.getActiveTrace)());
        }
      },
      retainQuery: function retainQuery(info) {
        if (interactionId.current != null) {
          (0, _interactionMetrics.addRequestInfo)(interactionId.current, this.labelStack, info);
        }
      },
      addPreload: function addPreload(moduleId, timestamp) {
        if (interactionId.current != null) {
          (0, _interactionMetrics.addMark)(interactionId.current, 'bundle_preload', moduleId, this.labelStack, timestamp);
        }
      },
      addLoad: function addLoad(identifier, start, end) {
        if (interactionId.current != null) {
          var _this$labelStack = this.labelStack,
            _labelStack = _this$labelStack === void 0 ? [] : _this$labelStack;
          (0, _interactionMetrics.addSpan)(interactionId.current, 'bundle_load', identifier, _labelStack, start, end);
        }
      },
      addMark: function addMark(name, timestamp
      // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
      ) {
        if (interactionId.current != null) {
          var time = timestamp !== null && timestamp !== void 0 ? timestamp : performance.now();
          (0, _interactionMetrics.addMark)(interactionId.current, 'custom', name, this.labelStack, time);
        }
      },
      addCustomData: function addCustomData(customData) {
        if (interactionId.current != null) {
          (0, _interactionMetrics.addCustomData)(interactionId.current, this.labelStack, customData);
        }
      },
      addCustomTimings: function addCustomTimings(customTimings) {
        if (interactionId.current != null) {
          (0, _interactionMetrics.addCustomTiming)(interactionId.current, this.labelStack, customTimings);
        }
      },
      addApdex: function addApdex(apdexInfo) {
        if (interactionId.current != null) {
          var key = apdexInfo.key,
            stopTime = apdexInfo.stopTime,
            startTime = apdexInfo.startTime;
          (0, _interactionMetrics.addApdex)(interactionId.current, {
            key: key,
            stopTime: stopTime,
            startTime: startTime,
            labelStack: this.labelStack
          });
        }
      },
      onRender: function onRender(phase, actualDuration, baseDuration, startTime, commitTime) {
        var _this = this;
        if (interactionId.current !== null) {
          (0, _interactionMetrics.addProfilerTimings)(interactionId.current, this.labelStack, phase, actualDuration, baseDuration, startTime, commitTime);
          (0, _scheduleOnPaint.default)(function () {
            var paintedTime = performance.now();
            _this.complete(paintedTime);
          });
        }
      },
      _internalHold: _internalHold,
      _internalHoldByID: _internalHoldByID,
      complete: complete
    };
  }, [parentContext, labelStack, segmentIdMap, interactionId]);
  var hasMounted = (0, _react.useRef)(false);
  var onRender = (0, _react.useCallback)(function (_id, phase, actualDuration, baseDuration, startTime, commitTime) {
    var _getConfig;
    // Manually keep track of mount-phase, and ensure that every segment is always mounted at least once
    if ((_getConfig = (0, _config.getConfig)()) !== null && _getConfig !== void 0 && _getConfig.manuallyTrackReactProfilerMounts && !hasMounted.current) {
      interactionContext.onRender('mount', actualDuration, baseDuration, startTime, commitTime);
      hasMounted.current = true;
    } else {
      interactionContext.onRender(phase, actualDuration, baseDuration, startTime, commitTime);
    }
  }, [interactionContext]);
  (0, _react.useEffect)(function () {
    (0, _interactionMetrics.addSegment)(labelStack);
    return function () {
      (0, _interactionMetrics.removeSegment)(labelStack);
    };
  }, [interactionId, parentContext, interactionContext, labelStack]);
  var reactProfilerId = (0, _react.useMemo)(function () {
    return labelStack.map(function (l) {
      return l.name;
    }).join('/');
  }, [labelStack]);
  var ufoSegment = /*#__PURE__*/_react.default.createElement(_interactionContext.default.Provider, {
    value: interactionContext
  }, /*#__PURE__*/_react.default.createElement(_react.Profiler, {
    id: reactProfilerId,
    onRender: onRender
  }, children));
  if ((0, _platformFeatureFlags.fg)('platform_ufo_ssr_render_profiler')) {
    return /*#__PURE__*/_react.default.createElement(_ssrRenderProfiler.default, {
      labelStack: labelStack,
      onRender: interactionContext.onRender
    }, ufoSegment);
  }
  return ufoSegment;
}
UFOSegment.displayName = 'UFOSegment';