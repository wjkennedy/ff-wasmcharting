type RGBColor = `rgb(${number}, ${number}, ${number})`;
type Viewport = {
    width: number;
    height: number;
};
/**
 * Class responsible for managing a scaled canvas and tracking pixel drawing operations.
 * It uses either an OffscreenCanvas (if available) or a regular HTML Canvas for better performance
 * and maintains a mapping between colors and timestamps for pixel counting purposes.
 */
export declare class ViewportCanvas {
    /** The underlying Canvas instance (either OffscreenCanvas or HTMLCanvasElement) */
    private readonly canvas;
    /** The 2D rendering context of the canvas */
    private readonly ctx;
    /** Scale factor applied to the canvas (affects final pixel counts) */
    private readonly scaleFactor;
    /** Maps unique colors to their corresponding timestamps */
    private readonly colorTimeMap;
    /** Counter used to generate unique colors */
    private colorCounter;
    private scaledWidth;
    private scaledHeight;
    private scaleX;
    private scaleY;
    /**
     * Creates a new ViewportCanvas instance.
     * @param viewport - The dimensions of the viewport
     * @param scaleFactor - Scale factor to apply to the canvas (default: 0.5)
     * @throws {Error} If canvas context cannot be obtained
     */
    constructor(viewport: Viewport, scaleFactor?: number);
    /**
     * Creates a canvas instance, falling back to HTMLCanvasElement if OffscreenCanvas is not available
     */
    private createCanvas;
    getScaledDimensions(): {
        width: number;
        height: number;
    };
    /**
     * Clears the entire canvas by removing all drawn content.
     * @private
     */
    private clear;
    /**
     * Generates a unique RGB color from an incrementing counter.
     * Uses a 24-bit color space (16,777,216 possible colors).
     *
     * @private
     * @returns A unique RGB color string
     *
     * @example
     * // Example bit operations for color 0x00FF8040:
     * // Red:   (0x00FF8040 >> 16) & 0xFF = 0xFF = 255
     * // Green: (0x00FF8040 >> 8) & 0xFF  = 0x80 = 128
     * // Blue:   0x00FF8040 & 0xFF        = 0x40 = 64
     */
    private generateColor;
    /**
     * Draws a rectangle on the canvas with a unique color and associates it with a timestamp.
     * Each drawn rectangle gets a unique color which is mapped to the provided timestamp.
     *
     * @param rect - The rectangle dimensions to draw
     * @param timestamp - The timestamp to associate with this drawing operation
     */
    drawRect(rect: DOMRect, timestamp: DOMHighResTimeStamp): void;
    /**
     * Calculates the number of pixels drawn for each timestamp.
     * This method:
     * 1. Reads the pixel data from the canvas
     * 2. Counts pixels of each unique color
     * 3. Maps colors back to their timestamps
     * 4. Adjusts counts based on the scale factor
     *
     * @returns A Map containing timestamp to pixel count mappings
     */
    getPixelCounts(): Promise<Map<DOMHighResTimeStamp, number>>;
}
/**
 * Converts a number into RGB components in such a way that they can be recombined
 * to form the original number using bitwise operations.
 * @param number - The input number to be split into RGB components.
 * @returns The RGB color string in the format "rgb(r, g, b)".
 */
export declare function getRGBComponents(n: number): RGBColor;
/**
 * Calculates the number of pixels drawn for each color in the image data.
 * @param imageData - The image data to analyze.
 * @param scaleFactor - The scale factor applied to the canvas.
 * @param arraySize - The amount of timestamps that were drawn in the viewport
 * @returns A Map containing color to pixel count mappings.
 */
export declare function calculateDrawnPixelsRaw(imageData: ImageData, _: number, arraySize: number): Promise<Uint32Array>;
export {};
