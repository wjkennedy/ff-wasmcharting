/**
 * This file was automatically generated by @atlaskit/adf-schema-generator
 * DO NOT MODIFY IT BY HAND. Instead, modify the source files in "packages/adf-schema/src/next-schema" ,
 * and run "yarn workspace @atlaskit/adf-schema build:schema:all" to regenerate this file.
 */
import { Node as PMNode } from '@atlaskit/editor-prosemirror/model';
import { InlineDefinition, BlockDefinition, BlockRootOnlyDefinition } from './nodeGroupTypes';
import { AlignmentMark, AnnotationMark, BackgroundColorMark, BorderMark, BreakoutMark, CodeMark, ConfluenceInlineCommentMark, DataConsumerMark, EmMark, FragmentMark, IndentationMark, LinkMark, StrikeMark, StrongMark, SubsupMark, TextColorMark, TypeAheadQueryMark, UnderlineMark, UnsupportedMarkMark, UnsupportedNodeAttributeMark } from './markTypes';
export interface BlockCardNodeAttributes0 {
    url?: string;
    datasource: Record<string, unknown>;
    width?: number;
    layout?: 'wide' | 'full-width' | 'center' | 'wrap-right' | 'wrap-left' | 'align-end' | 'align-start';
}
export interface BlockCardNodeAttributes1 {
    url: string;
}
export interface BlockCardNodeAttributes2 {
    data: Record<string, unknown>;
}
export interface BlockCardDefinition {
    type: 'blockCard';
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: BlockCardNodeAttributes0 | BlockCardNodeAttributes1 | BlockCardNodeAttributes2;
}
export type BlockCardNode = PMNode & BlockCardDefinition;
export declare const blockCard: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<BlockCardNode>) => import("prosemirror-model").NodeSpec;
export interface BlockquoteDefinition {
    type: 'blockquote';
    content: Array<BulletListDefinition | CodeBlockDefinition | ExtensionWithMarksDefinition | MediaGroupDefinition | MediaSingleCaptionDefinition | MediaSingleFullDefinition | OrderedListDefinition | ParagraphWithNoMarksDefinition | UnsupportedBlockDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}
export type BlockquoteNode = PMNode & BlockquoteDefinition;
export declare const blockquote: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<BlockquoteNode>) => import("prosemirror-model").NodeSpec;
export interface BlockquoteLegacyDefinition {
    type: 'blockquote';
    content: Array<ParagraphDefinition | UnsupportedBlockDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}
export type BlockquoteLegacyNode = PMNode & BlockquoteLegacyDefinition;
export declare const blockquoteLegacy: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<BlockquoteLegacyNode>) => import("prosemirror-model").NodeSpec;
export interface BlockquoteWithoutNestedCodeblockOrMediaDefinition {
    type: 'blockquote';
    content: Array<BulletListDefinition | OrderedListDefinition | ParagraphWithNoMarksDefinition | UnsupportedBlockDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}
export type BlockquoteWithoutNestedCodeblockOrMediaNode = PMNode & BlockquoteWithoutNestedCodeblockOrMediaDefinition;
export declare const blockquoteWithoutNestedCodeblockOrMedia: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<BlockquoteWithoutNestedCodeblockOrMediaNode>) => import("prosemirror-model").NodeSpec;
export interface BlockquoteWithoutNonBodiedMacrosDefinition {
    type: 'blockquote';
    content: Array<BulletListDefinition | CodeBlockDefinition | MediaGroupDefinition | MediaSingleCaptionDefinition | MediaSingleFullDefinition | OrderedListDefinition | ParagraphWithNoMarksDefinition | UnsupportedBlockDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}
export type BlockquoteWithoutNonBodiedMacrosNode = PMNode & BlockquoteWithoutNonBodiedMacrosDefinition;
export declare const blockquoteWithoutNonBodiedMacros: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<BlockquoteWithoutNonBodiedMacrosNode>) => import("prosemirror-model").NodeSpec;
export interface BodiedExtensionDefinition {
    type: 'bodiedExtension';
    content: Array<BlockCardDefinition | BlockquoteDefinition | BulletListDefinition | CodeBlockDefinition | DecisionListDefinition | EmbedCardDefinition | ExtensionWithMarksDefinition | HeadingWithNoMarksDefinition | MediaGroupDefinition | MediaSingleCaptionDefinition | MediaSingleFullDefinition | OrderedListDefinition | PanelDefinition | ParagraphWithNoMarksDefinition | RuleDefinition | TableDefinition | TableWithNestedTableDefinition | TaskListDefinition | UnsupportedBlockDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        extensionKey: string;
        extensionType: string;
        parameters?: Record<string, unknown>;
        text?: string;
        layout?: 'wide' | 'full-width' | 'default';
        localId?: string;
    };
}
export type BodiedExtensionNode = PMNode & BodiedExtensionDefinition;
export declare const bodiedExtension: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<BodiedExtensionNode>) => import("prosemirror-model").NodeSpec;
export interface BodiedExtensionWithMarksDefinition {
    type: 'bodiedExtension';
    marks: Array<DataConsumerMark | FragmentMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        extensionKey: string;
        extensionType: string;
        parameters?: Record<string, unknown>;
        text?: string;
        layout?: 'wide' | 'full-width' | 'default';
        localId?: string;
    };
}
export type BodiedExtensionWithMarksNode = PMNode & BodiedExtensionWithMarksDefinition;
export declare const bodiedExtensionWithMarks: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<BodiedExtensionWithMarksNode>) => import("prosemirror-model").NodeSpec;
export interface BulletListDefinition {
    type: 'bulletList';
    content: Array<ListItemDefinition | ListItemWithNestedDecisionStage0Definition | ListItemWithoutNonBodiedMacrosDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}
export type BulletListNode = PMNode & BulletListDefinition;
export declare const bulletList: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<BulletListNode>) => import("prosemirror-model").NodeSpec;
export interface CaptionDefinition {
    type: 'caption';
    content: Array<DateDefinition | DateStage0Definition | EmojiDefinition | EmojiStage0Definition | HardBreakDefinition | InlineCardDefinition | InlineCardStage0Definition | MentionDefinition | MentionStage0Definition | PlaceholderDefinition | StatusDefinition | StatusStage0Definition | TextCodeInlineDefinition | TextFormattedDefinition | UnsupportedInlineDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}
export type CaptionNode = PMNode & CaptionDefinition;
export declare const caption: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<CaptionNode>) => import("prosemirror-model").NodeSpec;
export interface CodeBlockDefinition {
    type: 'codeBlock';
    content: Array<TextWithNoMarksDefinition | UnsupportedInlineDefinition>;
    attrs: {
        language?: string;
        uniqueId?: string;
    };
}
export type CodeBlockNode = PMNode & CodeBlockDefinition;
export declare const codeBlock: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<CodeBlockNode>) => import("prosemirror-model").NodeSpec;
export interface CodeBlockRootOnlyDefinition {
    type: 'codeBlock';
    content: Array<TextWithNoMarksDefinition | UnsupportedInlineDefinition>;
    marks: Array<BreakoutMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        language?: string;
        uniqueId?: string;
    };
}
export type CodeBlockRootOnlyNode = PMNode & CodeBlockRootOnlyDefinition;
export declare const codeBlockRootOnly: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<CodeBlockRootOnlyNode>) => import("prosemirror-model").NodeSpec;
export interface ConfluenceJiraIssueDefinition {
    type: 'confluenceJiraIssue';
    attrs: {
        issueKey: string;
        macroId?: string;
        schemaVersion?: string;
        server?: string;
        serverId?: string;
    };
}
export type ConfluenceJiraIssueNode = PMNode & ConfluenceJiraIssueDefinition;
export declare const confluenceJiraIssue: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<ConfluenceJiraIssueNode>) => import("prosemirror-model").NodeSpec;
export interface ConfluenceUnsupportedBlockDefinition {
    type: 'confluenceUnsupportedBlock';
    attrs: {
        cxhtml: string;
    };
}
export type ConfluenceUnsupportedBlockNode = PMNode & ConfluenceUnsupportedBlockDefinition;
export declare const confluenceUnsupportedBlock: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<ConfluenceUnsupportedBlockNode>) => import("prosemirror-model").NodeSpec;
export interface ConfluenceUnsupportedInlineDefinition {
    type: 'confluenceUnsupportedInline';
    attrs: {
        cxhtml: string;
    };
}
export type ConfluenceUnsupportedInlineNode = PMNode & ConfluenceUnsupportedInlineDefinition;
export declare const confluenceUnsupportedInline: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<ConfluenceUnsupportedInlineNode>) => import("prosemirror-model").NodeSpec;
export interface DateDefinition {
    type: 'date';
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        timestamp: string;
    };
}
export type DateNode = PMNode & DateDefinition;
export declare const date: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<DateNode>) => import("prosemirror-model").NodeSpec;
export interface DateStage0Definition {
    type: 'date';
    marks: Array<AnnotationMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        timestamp: string;
    };
}
export type DateStage0Node = PMNode & DateStage0Definition;
export declare const dateStage0: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<DateStage0Node>) => import("prosemirror-model").NodeSpec;
export interface DecisionItemDefinition {
    type: 'decisionItem';
    content: Array<InlineDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        localId: string;
        state: string;
    };
}
export type DecisionItemNode = PMNode & DecisionItemDefinition;
export declare const decisionItem: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<DecisionItemNode>) => import("prosemirror-model").NodeSpec;
export interface DecisionListDefinition {
    type: 'decisionList';
    content: Array<DecisionItemDefinition | UnsupportedBlockDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        localId: string;
    };
}
export type DecisionListNode = PMNode & DecisionListDefinition;
export declare const decisionList: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<DecisionListNode>) => import("prosemirror-model").NodeSpec;
export interface DocDefinition {
    type: 'doc';
    content: Array<BlockDefinition | BlockRootOnlyDefinition | CodeBlockRootOnlyDefinition | ExpandRootOnlyDefinition | LayoutSectionDefinition | LayoutSectionFullDefinition | LayoutSectionWithSingleColumnStage0Definition>;
}
export type DocNode = PMNode & DocDefinition;
export declare const doc: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<DocNode>) => import("prosemirror-model").NodeSpec;
export interface EmbedCardDefinition {
    type: 'embedCard';
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        url: string;
        layout: 'wide' | 'full-width' | 'center' | 'wrap-right' | 'wrap-left' | 'align-end' | 'align-start';
        width?: number;
        originalHeight?: number;
        originalWidth?: number;
    };
}
export type EmbedCardNode = PMNode & EmbedCardDefinition;
export declare const embedCard: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<EmbedCardNode>) => import("prosemirror-model").NodeSpec;
export interface EmojiDefinition {
    type: 'emoji';
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        shortName: string;
        id?: string;
        text?: string;
    };
}
export type EmojiNode = PMNode & EmojiDefinition;
export declare const emoji: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<EmojiNode>) => import("prosemirror-model").NodeSpec;
export interface EmojiStage0Definition {
    type: 'emoji';
    marks: Array<AnnotationMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        shortName: string;
        id?: string;
        text?: string;
    };
}
export type EmojiStage0Node = PMNode & EmojiStage0Definition;
export declare const emojiStage0: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<EmojiStage0Node>) => import("prosemirror-model").NodeSpec;
export interface ExpandDefinition {
    type: 'expand';
    content: Array<BlockCardDefinition | BlockquoteDefinition | BulletListDefinition | CodeBlockDefinition | DecisionListDefinition | EmbedCardDefinition | ExtensionWithMarksDefinition | HeadingWithNoMarksDefinition | MediaGroupDefinition | MediaSingleCaptionDefinition | MediaSingleFullDefinition | NestedExpandWithNoMarksDefinition | NestedExpandWithoutNonBodiedMacrosDefinition | OrderedListDefinition | PanelDefinition | ParagraphWithNoMarksDefinition | RuleDefinition | TableDefinition | TableWithNestedTableDefinition | TaskListDefinition | UnsupportedBlockDefinition>;
    attrs: {
        title?: string;
        __expanded?: boolean;
    };
}
export type ExpandNode = PMNode & ExpandDefinition;
export declare const expand: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<ExpandNode>) => import("prosemirror-model").NodeSpec;
export interface ExpandRootOnlyDefinition {
    type: 'expand';
    content: Array<BlockCardDefinition | BlockquoteDefinition | BulletListDefinition | CodeBlockDefinition | DecisionListDefinition | EmbedCardDefinition | ExtensionWithMarksDefinition | HeadingWithNoMarksDefinition | MediaGroupDefinition | MediaSingleCaptionDefinition | MediaSingleFullDefinition | NestedExpandWithNoMarksDefinition | NestedExpandWithoutNonBodiedMacrosDefinition | OrderedListDefinition | PanelDefinition | ParagraphWithNoMarksDefinition | RuleDefinition | TableDefinition | TableWithNestedTableDefinition | TaskListDefinition | UnsupportedBlockDefinition>;
    marks: Array<BreakoutMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        title?: string;
        __expanded?: boolean;
    };
}
export type ExpandRootOnlyNode = PMNode & ExpandRootOnlyDefinition;
export declare const expandRootOnly: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<ExpandRootOnlyNode>) => import("prosemirror-model").NodeSpec;
export interface ExtensionDefinition {
    type: 'extension';
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        extensionKey: string;
        extensionType: string;
        parameters?: Record<string, unknown>;
        text?: string;
        layout?: 'wide' | 'full-width' | 'default';
        localId?: string;
    };
}
export type ExtensionNode = PMNode & ExtensionDefinition;
export declare const extension: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<ExtensionNode>) => import("prosemirror-model").NodeSpec;
export interface ExtensionWithMarksDefinition {
    type: 'extension';
    marks: Array<DataConsumerMark | FragmentMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        extensionKey: string;
        extensionType: string;
        parameters?: Record<string, unknown>;
        text?: string;
        layout?: 'wide' | 'full-width' | 'default';
        localId?: string;
    };
}
export type ExtensionWithMarksNode = PMNode & ExtensionWithMarksDefinition;
export declare const extensionWithMarks: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<ExtensionWithMarksNode>) => import("prosemirror-model").NodeSpec;
export interface ExtensionFrameStage0Definition {
    type: 'extensionFrame';
    content: Array<BlockCardDefinition | BlockquoteDefinition | BodiedExtensionWithMarksDefinition | BulletListDefinition | CodeBlockDefinition | DecisionListDefinition | EmbedCardDefinition | ExtensionWithMarksDefinition | HeadingWithNoMarksDefinition | MediaGroupDefinition | MediaSingleCaptionDefinition | MediaSingleFullDefinition | OrderedListDefinition | PanelDefinition | ParagraphWithNoMarksDefinition | RuleDefinition | TableDefinition | TableWithNestedTableDefinition | TaskListDefinition | UnsupportedBlockDefinition>;
    marks: Array<DataConsumerMark | FragmentMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}
export type ExtensionFrameStage0Node = PMNode & ExtensionFrameStage0Definition;
export declare const extensionFrameStage0: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<ExtensionFrameStage0Node>) => import("prosemirror-model").NodeSpec;
export interface HardBreakDefinition {
    type: 'hardBreak';
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        text?: '\n';
    };
}
export type HardBreakNode = PMNode & HardBreakDefinition;
export declare const hardBreak: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<HardBreakNode>) => import("prosemirror-model").NodeSpec;
export interface HeadingDefinition {
    type: 'heading';
    content: Array<InlineDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        level: number;
        localId?: string;
    };
}
export type HeadingNode = PMNode & HeadingDefinition;
export declare const heading: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<HeadingNode>) => import("prosemirror-model").NodeSpec;
export interface HeadingWithAlignmentDefinition {
    type: 'heading';
    marks: Array<AlignmentMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        level: number;
        localId?: string;
    };
}
export type HeadingWithAlignmentNode = PMNode & HeadingWithAlignmentDefinition;
export declare const headingWithAlignment: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<HeadingWithAlignmentNode>) => import("prosemirror-model").NodeSpec;
export interface HeadingWithIndentationDefinition {
    type: 'heading';
    marks: Array<IndentationMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        level: number;
        localId?: string;
    };
}
export type HeadingWithIndentationNode = PMNode & HeadingWithIndentationDefinition;
export declare const headingWithIndentation: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<HeadingWithIndentationNode>) => import("prosemirror-model").NodeSpec;
export interface HeadingWithNoMarksDefinition {
    type: 'heading';
    attrs: {
        level: number;
        localId?: string;
    };
}
export type HeadingWithNoMarksNode = PMNode & HeadingWithNoMarksDefinition;
export declare const headingWithNoMarks: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<HeadingWithNoMarksNode>) => import("prosemirror-model").NodeSpec;
export interface ImageDefinition {
    type: 'image';
    attrs: {
        src: string;
        alt?: string;
        title?: string;
    };
}
export type ImageNode = PMNode & ImageDefinition;
export declare const image: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<ImageNode>) => import("prosemirror-model").NodeSpec;
export interface InlineCardNodeAttributes0 {
    url: string;
}
export interface InlineCardNodeAttributes1 {
    data: Record<string, unknown>;
}
export interface InlineCardDefinition {
    type: 'inlineCard';
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: InlineCardNodeAttributes0 | InlineCardNodeAttributes1;
}
export type InlineCardNode = PMNode & InlineCardDefinition;
export declare const inlineCard: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<InlineCardNode>) => import("prosemirror-model").NodeSpec;
export interface InlineCardStage0NodeAttributes0 {
    url: string;
}
export interface InlineCardStage0NodeAttributes1 {
    data: Record<string, unknown>;
}
export interface InlineCardStage0Definition {
    type: 'inlineCard';
    marks: Array<AnnotationMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: InlineCardStage0NodeAttributes0 | InlineCardStage0NodeAttributes1;
}
export type InlineCardStage0Node = PMNode & InlineCardStage0Definition;
export declare const inlineCardStage0: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<InlineCardStage0Node>) => import("prosemirror-model").NodeSpec;
export interface InlineExtensionDefinition {
    type: 'inlineExtension';
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        extensionKey: string;
        extensionType: string;
        parameters?: Record<string, unknown>;
        text?: string;
        localId?: string;
    };
}
export type InlineExtensionNode = PMNode & InlineExtensionDefinition;
export declare const inlineExtension: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<InlineExtensionNode>) => import("prosemirror-model").NodeSpec;
export interface InlineExtensionWithMarksDefinition {
    type: 'inlineExtension';
    marks: Array<DataConsumerMark | FragmentMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        extensionKey: string;
        extensionType: string;
        parameters?: Record<string, unknown>;
        text?: string;
        localId?: string;
    };
}
export type InlineExtensionWithMarksNode = PMNode & InlineExtensionWithMarksDefinition;
export declare const inlineExtensionWithMarks: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<InlineExtensionWithMarksNode>) => import("prosemirror-model").NodeSpec;
export interface LayoutColumnDefinition {
    type: 'layoutColumn';
    content: Array<BlockDefinition | UnsupportedBlockDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        width: number;
    };
}
export type LayoutColumnNode = PMNode & LayoutColumnDefinition;
export declare const layoutColumn: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<LayoutColumnNode>) => import("prosemirror-model").NodeSpec;
export interface LayoutSectionDefinition {
    type: 'layoutSection';
    content: Array<LayoutColumnDefinition | UnsupportedBlockDefinition | UnsupportedBlockDefinition>;
    marks: Array<BreakoutMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}
export type LayoutSectionNode = PMNode & LayoutSectionDefinition;
export declare const layoutSection: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<LayoutSectionNode>) => import("prosemirror-model").NodeSpec;
export interface LayoutSectionFullDefinition {
    type: 'layoutSection';
    content: Array<LayoutColumnDefinition | UnsupportedBlockDefinition>;
    marks: Array<BreakoutMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}
export type LayoutSectionFullNode = PMNode & LayoutSectionFullDefinition;
export declare const layoutSectionFull: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<LayoutSectionFullNode>) => import("prosemirror-model").NodeSpec;
export interface LayoutSectionWithSingleColumnStage0Definition {
    type: 'layoutSection';
    content: Array<LayoutColumnDefinition | UnsupportedBlockDefinition | UnsupportedBlockDefinition>;
    marks: Array<BreakoutMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        columnRuleStyle?: 'solid';
    };
}
export type LayoutSectionWithSingleColumnStage0Node = PMNode & LayoutSectionWithSingleColumnStage0Definition;
export declare const layoutSectionWithSingleColumnStage0: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<LayoutSectionWithSingleColumnStage0Node>) => import("prosemirror-model").NodeSpec;
export interface ListItemDefinition {
    type: 'listItem';
    content: Array<BulletListDefinition | CodeBlockDefinition | CodeBlockDefinition | ExtensionWithMarksDefinition | ExtensionWithMarksDefinition | MediaSingleCaptionDefinition | MediaSingleCaptionDefinition | MediaSingleFullDefinition | MediaSingleFullDefinition | OrderedListDefinition | ParagraphWithNoMarksDefinition | ParagraphWithNoMarksDefinition | TaskListDefinition | UnsupportedBlockDefinition | UnsupportedBlockDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}
export type ListItemNode = PMNode & ListItemDefinition;
export declare const listItem: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<ListItemNode>) => import("prosemirror-model").NodeSpec;
export interface ListItemWithNestedDecisionStage0Definition {
    type: 'listItem';
    content: Array<BulletListDefinition | CodeBlockDefinition | CodeBlockDefinition | DecisionListDefinition | DecisionListDefinition | ExtensionWithMarksDefinition | ExtensionWithMarksDefinition | MediaSingleCaptionDefinition | MediaSingleCaptionDefinition | MediaSingleFullDefinition | MediaSingleFullDefinition | OrderedListDefinition | ParagraphWithNoMarksDefinition | ParagraphWithNoMarksDefinition | TaskListDefinition | UnsupportedBlockDefinition | UnsupportedBlockDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}
export type ListItemWithNestedDecisionStage0Node = PMNode & ListItemWithNestedDecisionStage0Definition;
export declare const listItemWithNestedDecisionStage0: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<ListItemWithNestedDecisionStage0Node>) => import("prosemirror-model").NodeSpec;
export interface ListItemWithoutNonBodiedMacrosDefinition {
    type: 'listItem';
    content: Array<BulletListDefinition | CodeBlockDefinition | CodeBlockDefinition | MediaSingleCaptionDefinition | MediaSingleCaptionDefinition | MediaSingleFullDefinition | MediaSingleFullDefinition | OrderedListDefinition | ParagraphWithNoMarksDefinition | ParagraphWithNoMarksDefinition | TaskListDefinition | UnsupportedBlockDefinition | UnsupportedBlockDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}
export type ListItemWithoutNonBodiedMacrosNode = PMNode & ListItemWithoutNonBodiedMacrosDefinition;
export declare const listItemWithoutNonBodiedMacros: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<ListItemWithoutNonBodiedMacrosNode>) => import("prosemirror-model").NodeSpec;
export interface MediaNodeAttributes0 {
    type: 'link' | 'file';
    id: string;
    alt?: string;
    collection: string;
    height?: number;
    occurrenceKey?: string;
    width?: number;
    __contextId?: string;
    __displayType?: 'file' | 'thumbnail';
    __external?: boolean;
    __fileMimeType?: string;
    __fileName?: number;
    __fileSize?: string;
    __mediaTraceId?: string;
}
export interface MediaNodeAttributes1 {
    type: 'external';
    alt?: string;
    height?: number;
    width?: number;
    url: string;
    __external?: boolean;
}
export interface MediaDefinition {
    type: 'media';
    marks: Array<AnnotationMark | BorderMark | LinkMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: MediaNodeAttributes0 | MediaNodeAttributes1;
}
export type MediaNode = PMNode & MediaDefinition;
export declare const media: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<MediaNode>) => import("prosemirror-model").NodeSpec;
export interface MediaGroupDefinition {
    type: 'mediaGroup';
    content: Array<MediaDefinition | UnsupportedBlockDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}
export type MediaGroupNode = PMNode & MediaGroupDefinition;
export declare const mediaGroup: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<MediaGroupNode>) => import("prosemirror-model").NodeSpec;
export interface MediaInlineDefinition {
    type: 'mediaInline';
    marks: Array<AnnotationMark | BorderMark | LinkMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        type?: 'link' | 'file' | 'image';
        url?: string;
        id: string;
        alt?: string;
        collection: string;
        occurrenceKey?: string;
        width?: number;
        height?: number;
        __fileName?: string;
        __fileSize?: number;
        __fileMimeType?: string;
        __displayType?: 'file' | 'thumbnail';
        __contextId?: string;
        __mediaTraceId?: string;
        __external?: boolean;
        data?: Record<string, unknown>;
    };
}
export type MediaInlineNode = PMNode & MediaInlineDefinition;
export declare const mediaInline: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<MediaInlineNode>) => import("prosemirror-model").NodeSpec;
export interface MediaSingleNodeAttributes0 {
    width?: number;
    layout: 'wide' | 'full-width' | 'center' | 'wrap-right' | 'wrap-left' | 'align-end' | 'align-start';
    widthType?: 'percentage';
}
export interface MediaSingleNodeAttributes1 {
    width: number;
    widthType: 'pixel';
    layout: 'wide' | 'full-width' | 'center' | 'wrap-right' | 'wrap-left' | 'align-end' | 'align-start';
}
export interface MediaSingleDefinition {
    type: 'mediaSingle';
    marks: Array<LinkMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: MediaSingleNodeAttributes0 | MediaSingleNodeAttributes1;
}
export type MediaSingleNode = PMNode & MediaSingleDefinition;
export declare const mediaSingle: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<MediaSingleNode>) => import("prosemirror-model").NodeSpec;
export interface MediaSingleCaptionNodeAttributes0 {
    width?: number;
    layout: 'wide' | 'full-width' | 'center' | 'wrap-right' | 'wrap-left' | 'align-end' | 'align-start';
    widthType?: 'percentage';
}
export interface MediaSingleCaptionNodeAttributes1 {
    width: number;
    widthType: 'pixel';
    layout: 'wide' | 'full-width' | 'center' | 'wrap-right' | 'wrap-left' | 'align-end' | 'align-start';
}
export interface MediaSingleCaptionDefinition {
    type: 'mediaSingle';
    content: Array<CaptionDefinition | MediaDefinition | UnsupportedBlockDefinition | UnsupportedBlockDefinition>;
    attrs: MediaSingleCaptionNodeAttributes0 | MediaSingleCaptionNodeAttributes1;
}
export type MediaSingleCaptionNode = PMNode & MediaSingleCaptionDefinition;
export declare const mediaSingleCaption: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<MediaSingleCaptionNode>) => import("prosemirror-model").NodeSpec;
export interface MediaSingleFullNodeAttributes0 {
    width?: number;
    layout: 'wide' | 'full-width' | 'center' | 'wrap-right' | 'wrap-left' | 'align-end' | 'align-start';
    widthType?: 'percentage';
}
export interface MediaSingleFullNodeAttributes1 {
    width: number;
    widthType: 'pixel';
    layout: 'wide' | 'full-width' | 'center' | 'wrap-right' | 'wrap-left' | 'align-end' | 'align-start';
}
export interface MediaSingleFullDefinition {
    type: 'mediaSingle';
    content: Array<MediaDefinition | UnsupportedBlockDefinition>;
    attrs: MediaSingleFullNodeAttributes0 | MediaSingleFullNodeAttributes1;
}
export type MediaSingleFullNode = PMNode & MediaSingleFullDefinition;
export declare const mediaSingleFull: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<MediaSingleFullNode>) => import("prosemirror-model").NodeSpec;
export interface MediaSingleWidthTypeNodeAttributes0 {
    width?: number;
    layout: 'wide' | 'full-width' | 'center' | 'wrap-right' | 'wrap-left' | 'align-end' | 'align-start';
    widthType?: 'percentage';
}
export interface MediaSingleWidthTypeNodeAttributes1 {
    width: number;
    widthType: 'pixel';
    layout: 'wide' | 'full-width' | 'center' | 'wrap-right' | 'wrap-left' | 'align-end' | 'align-start';
}
export interface MediaSingleWidthTypeDefinition {
    type: 'mediaSingle';
    content: Array<MediaDefinition | UnsupportedBlockDefinition>;
    attrs: MediaSingleWidthTypeNodeAttributes0 | MediaSingleWidthTypeNodeAttributes1;
}
export type MediaSingleWidthTypeNode = PMNode & MediaSingleWidthTypeDefinition;
export declare const mediaSingleWidthType: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<MediaSingleWidthTypeNode>) => import("prosemirror-model").NodeSpec;
export interface MentionDefinition {
    type: 'mention';
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        id: string;
        localId?: string;
        text?: string;
        accessLevel?: string;
        userType?: 'DEFAULT' | 'SPECIAL' | 'APP';
    };
}
export type MentionNode = PMNode & MentionDefinition;
export declare const mention: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<MentionNode>) => import("prosemirror-model").NodeSpec;
export interface MentionStage0Definition {
    type: 'mention';
    marks: Array<AnnotationMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        id: string;
        localId?: string;
        text?: string;
        accessLevel?: string;
        userType?: 'DEFAULT' | 'SPECIAL' | 'APP';
    };
}
export type MentionStage0Node = PMNode & MentionStage0Definition;
export declare const mentionStage0: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<MentionStage0Node>) => import("prosemirror-model").NodeSpec;
export interface MultiBodiedExtensionStage0Definition {
    type: 'multiBodiedExtension';
    content: Array<ExtensionFrameStage0Definition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        extensionKey: string;
        extensionType: string;
        parameters?: Record<string, unknown>;
        text?: string;
        layout?: 'default' | 'wide' | 'full-width';
        localId?: string;
    };
}
export type MultiBodiedExtensionStage0Node = PMNode & MultiBodiedExtensionStage0Definition;
export declare const multiBodiedExtensionStage0: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<MultiBodiedExtensionStage0Node>) => import("prosemirror-model").NodeSpec;
export interface NestedExpandDefinition {
    type: 'nestedExpand';
    content: Array<BlockquoteDefinition | BulletListDefinition | CodeBlockDefinition | DecisionListDefinition | ExtensionWithMarksDefinition | HeadingWithNoMarksDefinition | MediaGroupDefinition | MediaSingleCaptionDefinition | MediaSingleFullDefinition | OrderedListDefinition | PanelDefinition | ParagraphWithNoMarksDefinition | RuleDefinition | TaskListDefinition | UnsupportedBlockDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        title?: string;
        __expanded?: boolean;
    };
}
export type NestedExpandNode = PMNode & NestedExpandDefinition;
export declare const nestedExpand: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<NestedExpandNode>) => import("prosemirror-model").NodeSpec;
export interface NestedExpandWithNoMarksDefinition {
    type: 'nestedExpand';
    attrs: {
        title?: string;
        __expanded?: boolean;
    };
}
export type NestedExpandWithNoMarksNode = PMNode & NestedExpandWithNoMarksDefinition;
export declare const nestedExpandWithNoMarks: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<NestedExpandWithNoMarksNode>) => import("prosemirror-model").NodeSpec;
export interface NestedExpandWithoutNonBodiedMacrosDefinition {
    type: 'nestedExpand';
    content: Array<BlockquoteDefinition | BulletListDefinition | CodeBlockDefinition | DecisionListDefinition | HeadingWithNoMarksDefinition | MediaGroupDefinition | MediaSingleCaptionDefinition | MediaSingleFullDefinition | OrderedListDefinition | PanelDefinition | ParagraphWithNoMarksDefinition | RuleDefinition | TaskListDefinition | UnsupportedBlockDefinition>;
    attrs: {
        title?: string;
        __expanded?: boolean;
    };
}
export type NestedExpandWithoutNonBodiedMacrosNode = PMNode & NestedExpandWithoutNonBodiedMacrosDefinition;
export declare const nestedExpandWithoutNonBodiedMacros: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<NestedExpandWithoutNonBodiedMacrosNode>) => import("prosemirror-model").NodeSpec;
export interface OrderedListDefinition {
    type: 'orderedList';
    content: Array<ListItemDefinition | ListItemWithNestedDecisionStage0Definition | ListItemWithoutNonBodiedMacrosDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        order?: number;
    };
}
export type OrderedListNode = PMNode & OrderedListDefinition;
export declare const orderedList: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<OrderedListNode>) => import("prosemirror-model").NodeSpec;
export interface PanelDefinition {
    type: 'panel';
    content: Array<BlockCardDefinition | BulletListDefinition | CodeBlockDefinition | DecisionListDefinition | ExtensionWithMarksDefinition | HeadingWithNoMarksDefinition | MediaGroupDefinition | MediaSingleCaptionDefinition | MediaSingleFullDefinition | OrderedListDefinition | ParagraphWithNoMarksDefinition | RuleDefinition | TaskListDefinition | UnsupportedBlockDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        panelType: 'info' | 'note' | 'tip' | 'warning' | 'error' | 'success' | 'custom';
        panelIcon?: string;
        panelIconId?: string;
        panelIconText?: string;
        panelColor?: string;
    };
}
export type PanelNode = PMNode & PanelDefinition;
export declare const panel: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<PanelNode>) => import("prosemirror-model").NodeSpec;
export interface PanelWithoutNestedNonBodiedMacrosDefinition {
    type: 'panel';
    content: Array<BlockCardDefinition | BulletListDefinition | CodeBlockDefinition | DecisionListDefinition | HeadingWithNoMarksDefinition | MediaGroupDefinition | MediaSingleCaptionDefinition | MediaSingleFullDefinition | OrderedListDefinition | ParagraphWithNoMarksDefinition | RuleDefinition | TaskListDefinition | UnsupportedBlockDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        panelType: 'info' | 'note' | 'tip' | 'warning' | 'error' | 'success' | 'custom';
        panelIcon?: string;
        panelIconId?: string;
        panelIconText?: string;
        panelColor?: string;
    };
}
export type PanelWithoutNestedNonBodiedMacrosNode = PMNode & PanelWithoutNestedNonBodiedMacrosDefinition;
export declare const panelWithoutNestedNonBodiedMacros: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<PanelWithoutNestedNonBodiedMacrosNode>) => import("prosemirror-model").NodeSpec;
export interface ParagraphDefinition {
    type: 'paragraph';
    content: Array<InlineDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        localId?: string;
    };
}
export type ParagraphNode = PMNode & ParagraphDefinition;
export declare const paragraph: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<ParagraphNode>) => import("prosemirror-model").NodeSpec;
export interface ParagraphWithAlignmentDefinition {
    type: 'paragraph';
    marks: Array<AlignmentMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        localId?: string;
    };
}
export type ParagraphWithAlignmentNode = PMNode & ParagraphWithAlignmentDefinition;
export declare const paragraphWithAlignment: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<ParagraphWithAlignmentNode>) => import("prosemirror-model").NodeSpec;
export interface ParagraphWithIndentationDefinition {
    type: 'paragraph';
    marks: Array<IndentationMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        localId?: string;
    };
}
export type ParagraphWithIndentationNode = PMNode & ParagraphWithIndentationDefinition;
export declare const paragraphWithIndentation: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<ParagraphWithIndentationNode>) => import("prosemirror-model").NodeSpec;
export interface ParagraphWithNoMarksDefinition {
    type: 'paragraph';
    attrs: {
        localId?: string;
    };
}
export type ParagraphWithNoMarksNode = PMNode & ParagraphWithNoMarksDefinition;
export declare const paragraphWithNoMarks: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<ParagraphWithNoMarksNode>) => import("prosemirror-model").NodeSpec;
export interface PlaceholderDefinition {
    type: 'placeholder';
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        text: string;
    };
}
export type PlaceholderNode = PMNode & PlaceholderDefinition;
export declare const placeholder: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<PlaceholderNode>) => import("prosemirror-model").NodeSpec;
export interface RuleDefinition {
    type: 'rule';
}
export type RuleNode = PMNode & RuleDefinition;
export declare const rule: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<RuleNode>) => import("prosemirror-model").NodeSpec;
export interface StatusDefinition {
    type: 'status';
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        text: string;
        color: 'neutral' | 'purple' | 'blue' | 'red' | 'yellow' | 'green';
        localId?: string;
        style?: string;
    };
}
export type StatusNode = PMNode & StatusDefinition;
export declare const status: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<StatusNode>) => import("prosemirror-model").NodeSpec;
export interface StatusStage0Definition {
    type: 'status';
    marks: Array<AnnotationMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        text: string;
        color: 'neutral' | 'purple' | 'blue' | 'red' | 'yellow' | 'green';
        localId?: string;
        style?: string;
    };
}
export type StatusStage0Node = PMNode & StatusStage0Definition;
export declare const statusStage0: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<StatusStage0Node>) => import("prosemirror-model").NodeSpec;
export interface TableDefinition {
    type: 'table';
    content: Array<TableRowDefinition>;
    marks: Array<FragmentMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        displayMode?: 'default' | 'fixed';
        isNumberColumnEnabled?: boolean;
        layout?: 'wide' | 'full-width' | 'center' | 'align-end' | 'align-start' | 'default';
        localId?: string;
        width?: number;
        __autoSize?: boolean;
    };
}
export type TableNode = PMNode & TableDefinition;
export declare const table: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<TableNode>) => import("prosemirror-model").NodeSpec;
export interface TableWithNestedTableDefinition {
    type: 'table';
    content: Array<TableRowWithNestedTableDefinition>;
    marks: Array<FragmentMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        displayMode?: 'default' | 'fixed';
        isNumberColumnEnabled?: boolean;
        layout?: 'wide' | 'full-width' | 'center' | 'align-end' | 'align-start' | 'default';
        localId?: string;
        width?: number;
        __autoSize?: boolean;
    };
}
export type TableWithNestedTableNode = PMNode & TableWithNestedTableDefinition;
export declare const tableWithNestedTable: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<TableWithNestedTableNode>) => import("prosemirror-model").NodeSpec;
export interface TableCellDefinition {
    type: 'tableCell';
    content: Array<BlockCardDefinition | BlockquoteDefinition | BulletListDefinition | CodeBlockDefinition | DecisionListDefinition | EmbedCardDefinition | ExtensionWithMarksDefinition | HeadingWithAlignmentDefinition | HeadingWithIndentationDefinition | HeadingWithNoMarksDefinition | MediaGroupDefinition | MediaSingleCaptionDefinition | MediaSingleFullDefinition | NestedExpandWithNoMarksDefinition | NestedExpandWithoutNonBodiedMacrosDefinition | OrderedListDefinition | PanelDefinition | ParagraphWithAlignmentDefinition | ParagraphWithNoMarksDefinition | RuleDefinition | TaskListDefinition | UnsupportedBlockDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        colspan?: number;
        rowspan?: number;
        colwidth?: Array<number>;
        background?: string;
    };
}
export type TableCellNode = PMNode & TableCellDefinition;
export declare const tableCell: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<TableCellNode>) => import("prosemirror-model").NodeSpec;
export interface TableCellWithNestedTableDefinition {
    type: 'tableCell';
    content: Array<BlockCardDefinition | BlockquoteDefinition | BulletListDefinition | CodeBlockDefinition | DecisionListDefinition | EmbedCardDefinition | ExtensionWithMarksDefinition | HeadingWithAlignmentDefinition | HeadingWithIndentationDefinition | HeadingWithNoMarksDefinition | MediaGroupDefinition | MediaSingleCaptionDefinition | MediaSingleFullDefinition | NestedExpandWithNoMarksDefinition | NestedExpandWithoutNonBodiedMacrosDefinition | OrderedListDefinition | PanelDefinition | ParagraphWithAlignmentDefinition | ParagraphWithNoMarksDefinition | RuleDefinition | TableDefinition | TaskListDefinition | UnsupportedBlockDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        colspan?: number;
        rowspan?: number;
        colwidth?: Array<number>;
        background?: string;
    };
}
export type TableCellWithNestedTableNode = PMNode & TableCellWithNestedTableDefinition;
export declare const tableCellWithNestedTable: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<TableCellWithNestedTableNode>) => import("prosemirror-model").NodeSpec;
export interface TableHeaderDefinition {
    type: 'tableHeader';
    content: Array<BlockCardDefinition | BlockquoteDefinition | BulletListDefinition | CodeBlockDefinition | DecisionListDefinition | EmbedCardDefinition | ExtensionWithMarksDefinition | HeadingWithAlignmentDefinition | HeadingWithIndentationDefinition | HeadingWithNoMarksDefinition | MediaGroupDefinition | MediaSingleCaptionDefinition | MediaSingleFullDefinition | NestedExpandDefinition | NestedExpandWithNoMarksDefinition | NestedExpandWithoutNonBodiedMacrosDefinition | OrderedListDefinition | PanelDefinition | ParagraphWithAlignmentDefinition | ParagraphWithNoMarksDefinition | RuleDefinition | TaskListDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        colspan?: number;
        rowspan?: number;
        colwidth?: Array<number>;
        background?: string;
    };
}
export type TableHeaderNode = PMNode & TableHeaderDefinition;
export declare const tableHeader: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<TableHeaderNode>) => import("prosemirror-model").NodeSpec;
export interface TableHeaderWithNestedTableDefinition {
    type: 'tableHeader';
    content: Array<BlockCardDefinition | BlockquoteDefinition | BulletListDefinition | CodeBlockDefinition | DecisionListDefinition | EmbedCardDefinition | ExtensionWithMarksDefinition | HeadingWithAlignmentDefinition | HeadingWithIndentationDefinition | HeadingWithNoMarksDefinition | MediaGroupDefinition | MediaSingleCaptionDefinition | MediaSingleFullDefinition | NestedExpandDefinition | NestedExpandWithNoMarksDefinition | NestedExpandWithoutNonBodiedMacrosDefinition | OrderedListDefinition | PanelDefinition | ParagraphWithAlignmentDefinition | ParagraphWithNoMarksDefinition | RuleDefinition | TableDefinition | TaskListDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        colspan?: number;
        rowspan?: number;
        colwidth?: Array<number>;
        background?: string;
    };
}
export type TableHeaderWithNestedTableNode = PMNode & TableHeaderWithNestedTableDefinition;
export declare const tableHeaderWithNestedTable: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<TableHeaderWithNestedTableNode>) => import("prosemirror-model").NodeSpec;
export interface TableRowDefinition {
    type: 'tableRow';
    content: Array<TableCellDefinition | TableHeaderDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}
export type TableRowNode = PMNode & TableRowDefinition;
export declare const tableRow: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<TableRowNode>) => import("prosemirror-model").NodeSpec;
export interface TableRowWithNestedTableDefinition {
    type: 'tableRow';
    content: Array<TableCellWithNestedTableDefinition | TableHeaderWithNestedTableDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}
export type TableRowWithNestedTableNode = PMNode & TableRowWithNestedTableDefinition;
export declare const tableRowWithNestedTable: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<TableRowWithNestedTableNode>) => import("prosemirror-model").NodeSpec;
export interface TaskItemDefinition {
    type: 'taskItem';
    content: Array<InlineDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        localId: string;
        state: 'TODO' | 'DONE';
    };
}
export type TaskItemNode = PMNode & TaskItemDefinition;
export declare const taskItem: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<TaskItemNode>) => import("prosemirror-model").NodeSpec;
export interface TaskListDefinition {
    type: 'taskList';
    content: Array<TaskItemDefinition | TaskItemDefinition | TaskListDefinition | UnsupportedBlockDefinition | UnsupportedBlockDefinition>;
    marks: Array<UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
    attrs: {
        localId: string;
    };
}
export type TaskListNode = PMNode & TaskListDefinition;
export declare const taskList: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<TaskListNode>) => import("prosemirror-model").NodeSpec;
export interface TextDefinition {
    type: 'text';
}
export type TextNode = PMNode & TextDefinition;
export declare const text: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<TextNode>) => import("prosemirror-model").NodeSpec;
export interface TextCodeInlineDefinition {
    type: 'text';
    marks: Array<AnnotationMark | CodeMark | LinkMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}
export type TextCodeInlineNode = PMNode & TextCodeInlineDefinition;
export declare const textCodeInline: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<TextCodeInlineNode>) => import("prosemirror-model").NodeSpec;
export interface TextFormattedDefinition {
    type: 'text';
    marks: Array<AnnotationMark | BackgroundColorMark | ConfluenceInlineCommentMark | EmMark | LinkMark | StrikeMark | StrongMark | SubsupMark | TextColorMark | TypeAheadQueryMark | UnderlineMark | UnsupportedMarkMark | UnsupportedNodeAttributeMark>;
}
export type TextFormattedNode = PMNode & TextFormattedDefinition;
export declare const textFormatted: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<TextFormattedNode>) => import("prosemirror-model").NodeSpec;
export interface TextWithNoMarksDefinition {
    type: 'text';
}
export type TextWithNoMarksNode = PMNode & TextWithNoMarksDefinition;
export declare const textWithNoMarks: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<TextWithNoMarksNode>) => import("prosemirror-model").NodeSpec;
export interface UnsupportedBlockDefinition {
    type: 'unsupportedBlock';
    attrs: {
        originalValue: Record<string, unknown>;
    };
}
export type UnsupportedBlockNode = PMNode & UnsupportedBlockDefinition;
export declare const unsupportedBlock: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<UnsupportedBlockNode>) => import("prosemirror-model").NodeSpec;
export interface UnsupportedInlineDefinition {
    type: 'unsupportedInline';
    attrs: {
        originalValue: Record<string, unknown>;
    };
}
export type UnsupportedInlineNode = PMNode & UnsupportedInlineDefinition;
export declare const unsupportedInline: ({ parseDOM, toDOM, toDebugString }: import("../../schema/createPMSpecFactory").NodeSpecOptions<UnsupportedInlineNode>) => import("prosemirror-model").NodeSpec;
