"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OpenLayerObserver = OpenLayerObserver;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _tinyInvariant = _interopRequireDefault(require("tiny-invariant"));
var _openLayerObserverContext = require("./open-layer-observer-context");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
/**
 * Layers that are registered without a namespace are grouped under this fallback namespace.
 */
var noNamespaceSymbol = Symbol('no-namespace');

/**
 * A registered layer with its close listener and optional layer type.
 */

/**
 * Returns the number of open layers across all namespaces.
 * It calculates the sum of the set sizes in the map, which corresponds to the number of open layers.
 */
function getTotalOpenLayerCount(registry) {
  return Array.from(registry.values()).reduce(function (acc, listeners) {
    return acc + listeners.size;
  }, 0);
}

/**
 * Returns the number of layers in the set that match the type filter.
 */
function getLayerCountWithFilter(_ref) {
  var layers = _ref.layers,
    type = _ref.type;
  return Array.from(layers.values()).filter(function (layer) {
    return layer.type === type;
  }).length;
}

/**
 * Returns the layer count change listeners set for the namespace.
 * If there are no listeners registered for the namespace yet, it creates a new set
 * and adds it to the registry, then returns the new set.
 */
function getListeners(_ref2) {
  var registry = _ref2.registry,
    namespace = _ref2.namespace;
  // 1. If there are existing listeners for this namespace, return the existing set.
  var existingListeners = registry.get(namespace);
  if (existingListeners) {
    return existingListeners;
  }

  // 2. If there are no existing listeners for this namespace, create a new set for this namespace
  // and add it to the registry, then return the new set.
  var newSet = new Set();
  registry.set(namespace, newSet);
  return newSet;
}

/**
 * Returns an instance of the open layer observer API. It internally keeps track of the number of open layers and
 * exposes methods to get the current count, increment/decrement the count, and subscribe to changes.
 */
function createInternalAPI() {
  /**
   * The layer count change listeners for each namespace.
   */
  var namespaceToChangeListenerRegistry = new Map();

  /**
   * The registered layers for each namespace.
   * Each layer registers with an `onClose` callback, and optionally with a layer type (`type`).
   * **When the layer is open**, its `onClose`
   * callback is registered in this set along with its type.
   *
   * This data structure is also used determine the number of open layers.
   */
  var namespaceToLayerRegistry = new Map();

  /**
   * Calls the appropriate layer count change listeners after the number of open layers has changed.
   */
  function callChangeListeners(_ref3) {
    var namespace = _ref3.namespace,
      newCount = _ref3.newCount;
    // 1. Call listeners registered to the specific namespace
    if (namespace) {
      var listenersForNamespace = namespaceToChangeListenerRegistry.get(namespace);

      // Using `Array.from` to ensure we iterate over a stable list - e.g. in case a listener adds to the registry while we are
      // iterating over it.
      Array.from(listenersForNamespace !== null && listenersForNamespace !== void 0 ? listenersForNamespace : []).forEach(function (listener) {
        return listener({
          count: newCount
        });
      });
    }

    // 2. Call listeners registered without a specific namespace
    var noNamespaceListeners = namespaceToChangeListenerRegistry.get(noNamespaceSymbol);

    // Return early if no listeners
    if (!noNamespaceListeners) {
      return;
    }

    // For the listeners without a specific namespace, we need to provide the sum of all namespace counts
    // as the callback `count` arg.
    var totalCount = getTotalOpenLayerCount(namespaceToLayerRegistry);
    Array.from(noNamespaceListeners).forEach(function (listener) {
      return listener({
        count: totalCount
      });
    });
  }

  /**
   * Returns the current count of open layers.
   *
   * - If a namespace is provided, the count for that namespace is returned.
   * - If a type is provided, only layers of that type are counted.
   * - If both are provided, only layers matching both criteria are counted.
   * - Otherwise, the sum of all namespace counts is returned.
   */
  function getCount() {
    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      namespace = _ref4.namespace,
      type = _ref4.type;
    if (namespace) {
      // 1. A namespace was requested, so we count only layers in that namespace
      var layersForNamespace = namespaceToLayerRegistry.get(namespace);
      if (!layersForNamespace) {
        return 0;
      }
      if (type) {
        // Count layers in the namespace that match the type filter
        return getLayerCountWithFilter({
          layers: layersForNamespace,
          type: type
        });
      }

      // No type filter - just return the size of the set
      return layersForNamespace.size;
    }

    // 2. A specific namespace was not requested, so we count across all namespaces

    if (type) {
      // Count layers in each namespace that match the type filter
      return Array.from(namespaceToLayerRegistry.values()).reduce(function (acc, layers) {
        return acc + getLayerCountWithFilter({
          layers: layers,
          type: type
        });
      }, 0);
    }

    // No type filter - count all layers across all namespaces
    return getTotalOpenLayerCount(namespaceToLayerRegistry);
  }

  /**
   * Adds a listener that will be called when the number of open layers changes.
   *
   * @returns a cleanup function to unsubscribe, which should be called when the component unmounts.
   */
  function onChange(listener) {
    var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      providedNamespace = _ref5.namespace;
    /**
     * We are wrapping the passed listener in a function to ensure that each call to `onChange` creates a unique
     * function reference. This is to handle scenarios where the same function is provided to several different `onChange`
     * calls - we want to ensure that each call to `unsubscribe` only removes the specific listener registration that was added.
     */
    function wrapped() {
      listener.apply(void 0, arguments);
    }
    var namespace = providedNamespace !== null && providedNamespace !== void 0 ? providedNamespace : noNamespaceSymbol;
    var listenersForNamespace = getListeners({
      namespace: namespace,
      registry: namespaceToChangeListenerRegistry
    });
    listenersForNamespace.add(wrapped);
    return function unsubscribe() {
      listenersForNamespace.delete(wrapped);

      // If there are no listeners for this namespace, remove the registry entry.
      if (listenersForNamespace.size === 0) {
        namespaceToChangeListenerRegistry.delete(namespace);
      }
    };
  }

  /**
   * Adds a listener to the registry that tells the observer how to close the layer component.
   * The listener should only be added if the layer is open. This is handled by `useNotifyOpenLayerObserver`.
   *
   * All close listeners will be called by the observer when `closeLayers` is called.
   *
   * @returns a cleanup function to unsubscribe, which should be called when the component unmounts.
   */
  function onClose(listener, _ref6) {
    var providedNamespace = _ref6.namespace,
      type = _ref6.type;
    var wrapped = {
      listener: listener,
      type: type
    };
    var namespace = providedNamespace !== null && providedNamespace !== void 0 ? providedNamespace : noNamespaceSymbol;
    var listenersForNamespace = getListeners({
      namespace: namespace,
      registry: namespaceToLayerRegistry
    });
    listenersForNamespace.add(wrapped);
    callChangeListeners({
      namespace: providedNamespace,
      newCount: listenersForNamespace.size
    });
    return function unsubscribe() {
      listenersForNamespace.delete(wrapped);
      callChangeListeners({
        namespace: providedNamespace,
        newCount: listenersForNamespace.size
      });

      // If there are no listeners for this namespace, remove the registry entry.
      if (listenersForNamespace.size === 0) {
        namespaceToLayerRegistry.delete(namespace);
      }
    };
  }

  /**
   * Closes all open layers registered across all namespaces.
   */
  function closeLayers() {
    // Using `Array.from` to ensure we iterate over a stable list - e.g. in case a listener adds to the registry while we are
    // iterating over it.
    Array.from(namespaceToLayerRegistry.values()).forEach(function (listeners) {
      Array.from(listeners).forEach(function (_ref7) {
        var listener = _ref7.listener;
        return listener();
      });
    });
  }
  var internalAPI = {
    getCount: getCount,
    onChange: onChange,
    onClose: onClose,
    closeLayers: closeLayers
  };
  return internalAPI;
}

/**
 * Context provider for observing the number of __open__ layering components (e.g. popups, dropdown menus) under the observer.
 * It uses a stable object to keep track of the number of open layered components - which means the observer will not re-render
 * when the number of layers changes.
 *
 * There should only be one `OpenLayerObserver` in the application. If there are more, the component will throw an error.
 * To track the number of layers in a section of the application, use the `OpenLayerObserverNamespaceProvider` to create a new
 * namespace to group layers.
 *
 * It is intended for use with the `useOpenLayerObserver` hook.
 */
function OpenLayerObserver(_ref8) {
  var children = _ref8.children;
  // Using state to ensure a stable reference to a single instance.
  var _useState = (0, _react.useState)(function () {
      return createInternalAPI();
    }),
    _useState2 = (0, _slicedToArray2.default)(_useState, 1),
    internalAPI = _useState2[0];
  var parentContext = (0, _react.useContext)(_openLayerObserverContext.OpenLayerObserverContext);

  // We don't expect a parent context. If there is one, that means this component is nested within another `OpenLayerObserver`
  // - which we don't support.
  (0, _tinyInvariant.default)(parentContext === null, '`OpenLayerObserver` cannot be nested within another `OpenLayerObserver`.');
  return /*#__PURE__*/_react.default.createElement(_openLayerObserverContext.OpenLayerObserverContext.Provider, {
    value: internalAPI
  }, children);
}