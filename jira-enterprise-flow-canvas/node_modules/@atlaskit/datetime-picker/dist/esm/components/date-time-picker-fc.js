/* date-time-picker-fc.tsx generated by @compiled/babel-plugin v0.38.1 */
import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["selectProps"],
  _excluded2 = ["selectProps"];
import "./date-time-picker-fc.compiled.css";
import { ax, ix } from "@compiled/react/runtime";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/// <reference types="node" />
// for typing `process`

import React, { forwardRef, useCallback, useEffect, useState } from 'react';
import { format, isValid, parseISO } from 'date-fns';
import { usePlatformLeafEventHandler } from '@atlaskit/analytics-next';
import { IconButton } from '@atlaskit/button/new';
import SelectClearIcon from '@atlaskit/icon/core/cross-circle';
import { Box, Inline } from '@atlaskit/primitives/compiled';
import { mergeStyles } from '@atlaskit/select';
import { formatDateTimeZoneIntoIso } from '../internal';
import { DateTimePickerContainer } from '../internal/date-time-picker-container';
import { convertTokens } from '../internal/parse-tokens';
import DatePicker from './date-picker';
import TimePicker from './time-picker';
var packageName = "@atlaskit/datetime-picker";
var packageVersion = "0.0.0-development";
var analyticsAttributes = {
  componentName: 'dateTimePicker',
  packageName: packageName,
  packageVersion: packageVersion
};
var compiledStyles = {
  datePickerContainerStyles: "_i0dl1ssb _16jlkb7n _1o9zidpf",
  timePickerContainerStyles: "_i0dl1ssb _16jlkb7n",
  iconContainerStyles: "_1e0c1txw _4cvr1h6o _i0dl1kw7"
};

// react-select overrides (via @atlaskit/select).
var styles = {
  control: function control(style) {
    return _objectSpread(_objectSpread({}, style), {}, {
      backgroundColor: 'transparent',
      border: 2,
      borderRadius: 0,
      paddingLeft: 0,
      ':hover': {
        backgroundColor: 'transparent',
        cursor: 'inherit'
      }
    });
  }
};
export var datePickerDefaultAriaLabel = 'Date';
export var timePickerDefaultAriaLabel = 'Time';

/**
 * __Date time picker__
 *
 * A date time picker allows the user to select an associated date and time.
 *
 * - [Examples](https://atlassian.design/components/datetime-picker/examples)
 * - [Code](https://atlassian.design/components/datetime-picker/code)
 * - [Usage](https://atlassian.design/components/datetime-picker/usage)
 */
var DateTimePicker = /*#__PURE__*/forwardRef(function (_ref2, _ref) {
  var ariaDescribedBy = _ref2['aria-describedby'],
    _ref2$appearance = _ref2.appearance,
    appearance = _ref2$appearance === void 0 ? 'default' : _ref2$appearance,
    _ref2$autoFocus = _ref2.autoFocus,
    autoFocus = _ref2$autoFocus === void 0 ? false : _ref2$autoFocus,
    _ref2$clearControlLab = _ref2.clearControlLabel,
    clearControlLabel = _ref2$clearControlLab === void 0 ? 'clear' : _ref2$clearControlLab,
    _ref2$datePickerProps = _ref2.datePickerProps,
    datePickerPropsWithSelectProps = _ref2$datePickerProps === void 0 ? {} : _ref2$datePickerProps,
    _ref2$defaultValue = _ref2.defaultValue,
    defaultValue = _ref2$defaultValue === void 0 ? '' : _ref2$defaultValue,
    _ref2$id = _ref2.id,
    id = _ref2$id === void 0 ? '' : _ref2$id,
    _ref2$innerProps = _ref2.innerProps,
    innerProps = _ref2$innerProps === void 0 ? {} : _ref2$innerProps,
    _ref2$isDisabled = _ref2.isDisabled,
    isDisabled = _ref2$isDisabled === void 0 ? false : _ref2$isDisabled,
    _ref2$isInvalid = _ref2.isInvalid,
    isInvalid = _ref2$isInvalid === void 0 ? false : _ref2$isInvalid,
    _ref2$isRequired = _ref2.isRequired,
    isRequired = _ref2$isRequired === void 0 ? false : _ref2$isRequired,
    _ref2$name = _ref2.name,
    name = _ref2$name === void 0 ? '' : _ref2$name,
    _ref2$onBlur = _ref2.onBlur,
    onBlur = _ref2$onBlur === void 0 ? function (_event) {} : _ref2$onBlur,
    _ref2$onChange = _ref2.onChange,
    onChangeProp = _ref2$onChange === void 0 ? function (_value) {} : _ref2$onChange,
    _ref2$onFocus = _ref2.onFocus,
    onFocus = _ref2$onFocus === void 0 ? function (_event) {} : _ref2$onFocus,
    providedParseValue = _ref2.parseValue,
    _ref2$spacing = _ref2.spacing,
    spacing = _ref2$spacing === void 0 ? 'default' : _ref2$spacing,
    _ref2$locale = _ref2.locale,
    locale = _ref2$locale === void 0 ? 'en-US' : _ref2$locale,
    testId = _ref2.testId,
    _ref2$timePickerProps = _ref2.timePickerProps,
    timePickerPropsWithSelectProps = _ref2$timePickerProps === void 0 ? {} : _ref2$timePickerProps,
    providedValue = _ref2.value;
  var _useState = useState((datePickerPropsWithSelectProps === null || datePickerPropsWithSelectProps === void 0 ? void 0 : datePickerPropsWithSelectProps.defaultValue) || ''),
    _useState2 = _slicedToArray(_useState, 2),
    dateValue = _useState2[0],
    setDateValue = _useState2[1];
  var _useState3 = useState(false),
    _useState4 = _slicedToArray(_useState3, 2),
    isFocused = _useState4[0],
    setIsFocused = _useState4[1];
  var _useState5 = useState((timePickerPropsWithSelectProps === null || timePickerPropsWithSelectProps === void 0 ? void 0 : timePickerPropsWithSelectProps.defaultValue) || ''),
    _useState6 = _slicedToArray(_useState5, 2),
    timeValue = _useState6[0],
    setTimeValue = _useState6[1];
  var _useState7 = useState(defaultValue || ''),
    _useState8 = _slicedToArray(_useState7, 2),
    value = _useState8[0],
    setValue = _useState8[1];
  var _useState9 = useState(''),
    _useState0 = _slicedToArray(_useState9, 2),
    zoneValue = _useState0[0],
    setZoneValue = _useState0[1];
  useEffect(function () {
    if (providedValue) {
      setValue(providedValue);
    }
  }, [providedValue]);
  var parseValue = useCallback(function (value, providedDateValue, providedTimeValue, providedZoneValue) {
    if (providedParseValue) {
      var parsedFromFn = providedParseValue(value, providedDateValue, providedTimeValue, providedZoneValue);
      // This handles cases found in Jira where the parse function actually does
      // nothing and returns undefined. The previous `getSafeState` function
      // just spread the values over the state, but if it returned `undefined`,
      // it would just rely on the previous state values. Considering this is
      // what is input to this function anyway, this is a safe way to handle
      // this, colocate the behavior, and not rely on `getSafeState`.
      return parsedFromFn || {
        dateValue: providedDateValue,
        timeValue: providedTimeValue,
        zoneValue: providedZoneValue
      };
    }
    var parsed = parseISO(value);
    return isValid(parsed) ? {
      dateValue: format(parsed, convertTokens('YYYY-MM-DD')),
      timeValue: format(parsed, convertTokens('HH:mm')),
      zoneValue: format(parsed, convertTokens('ZZ'))
    } : {
      dateValue: dateValue,
      timeValue: timeValue,
      zoneValue: zoneValue
    };
  }, [providedParseValue, dateValue, timeValue, zoneValue]);
  useEffect(function () {
    var parsedValues = parseValue(value, dateValue, timeValue, zoneValue);
    setDateValue(parsedValues.dateValue);
    setTimeValue(parsedValues.timeValue);
    setZoneValue(parsedValues.zoneValue);
  }, [value, dateValue, timeValue, zoneValue, parseValue]);
  var onDateBlur = function onDateBlur(event) {
    setIsFocused(false);
    onBlur(event);
    if (datePickerPropsWithSelectProps !== null && datePickerPropsWithSelectProps !== void 0 && datePickerPropsWithSelectProps.onBlur) {
      datePickerPropsWithSelectProps.onBlur(event);
    }
  };
  var onTimeBlur = function onTimeBlur(event) {
    setIsFocused(false);
    onBlur(event);
    if (timePickerPropsWithSelectProps !== null && timePickerPropsWithSelectProps !== void 0 && timePickerPropsWithSelectProps.onBlur) {
      timePickerPropsWithSelectProps.onBlur(event);
    }
  };
  var onDateFocus = function onDateFocus(event) {
    setIsFocused(false);
    onFocus(event);
    if (datePickerPropsWithSelectProps !== null && datePickerPropsWithSelectProps !== void 0 && datePickerPropsWithSelectProps.onFocus) {
      datePickerPropsWithSelectProps.onFocus(event);
    }
  };
  var onTimeFocus = function onTimeFocus(event) {
    setIsFocused(false);
    onFocus(event);
    if (timePickerPropsWithSelectProps !== null && timePickerPropsWithSelectProps !== void 0 && timePickerPropsWithSelectProps.onFocus) {
      timePickerPropsWithSelectProps.onFocus(event);
    }
  };
  var onDateChange = function onDateChange(dateValue) {
    var parsedValues = parseValue(value, dateValue, timeValue, zoneValue);
    onValueChange({
      providedDateValue: dateValue,
      providedTimeValue: parsedValues.timeValue,
      providedZoneValue: parsedValues.zoneValue
    });
    if (datePickerPropsWithSelectProps !== null && datePickerPropsWithSelectProps !== void 0 && datePickerPropsWithSelectProps.onChange) {
      datePickerPropsWithSelectProps.onChange(dateValue);
    }
  };
  var onTimeChange = function onTimeChange(timeValue) {
    var parsedValues = parseValue(value, dateValue, timeValue, zoneValue);
    onValueChange({
      providedDateValue: parsedValues.dateValue,
      providedTimeValue: timeValue,
      providedZoneValue: parsedValues.zoneValue
    });
    if (timePickerPropsWithSelectProps !== null && timePickerPropsWithSelectProps !== void 0 && timePickerPropsWithSelectProps.onChange) {
      timePickerPropsWithSelectProps.onChange(timeValue);
    }
  };
  var onClear = function onClear() {
    var parsedValues = parseValue(value, dateValue, timeValue, zoneValue);
    onValueChange({
      providedDateValue: '',
      providedTimeValue: '',
      providedZoneValue: parsedValues.zoneValue
    });
    if (datePickerPropsWithSelectProps !== null && datePickerPropsWithSelectProps !== void 0 && datePickerPropsWithSelectProps.onChange) {
      datePickerPropsWithSelectProps.onChange('');
    }
    if (timePickerPropsWithSelectProps !== null && timePickerPropsWithSelectProps !== void 0 && timePickerPropsWithSelectProps.onChange) {
      timePickerPropsWithSelectProps.onChange('');
    }
  };
  var onChangePropWithAnalytics = usePlatformLeafEventHandler(_objectSpread({
    fn: onChangeProp,
    action: 'selectedDate',
    actionSubject: 'datePicker'
  }, analyticsAttributes));
  var onValueChange = function onValueChange(_ref3) {
    var providedDateValue = _ref3.providedDateValue,
      providedTimeValue = _ref3.providedTimeValue,
      providedZoneValue = _ref3.providedZoneValue;
    setDateValue(providedDateValue);
    setTimeValue(providedTimeValue);
    setZoneValue(providedZoneValue);
    if (providedDateValue && providedTimeValue) {
      var _value2 = formatDateTimeZoneIntoIso(providedDateValue, providedTimeValue, providedZoneValue);
      var _parseValue = parseValue(_value2, providedDateValue, providedTimeValue, providedZoneValue),
        parsedZone = _parseValue.zoneValue;
      var valueWithValidZone = formatDateTimeZoneIntoIso(providedDateValue, providedTimeValue, parsedZone);
      setValue(valueWithValidZone);
      onChangePropWithAnalytics(valueWithValidZone);
      // If the date or time value was cleared when there is an existing datetime value, then clear the value.
    } else if (value) {
      setValue('');
      onChangePropWithAnalytics('');
    }
  };
  var datePickerSelectProps = datePickerPropsWithSelectProps.selectProps,
    datePickerProps = _objectWithoutProperties(datePickerPropsWithSelectProps, _excluded);
  var datePickerAriaDescribedBy = datePickerProps['aria-describedby'] || ariaDescribedBy;
  var datePickerLabel = datePickerProps.label || datePickerDefaultAriaLabel;
  var mergedDatePickerSelectProps = _objectSpread(_objectSpread({}, datePickerSelectProps), {}, {
    styles: mergeStyles(styles, datePickerSelectProps === null || datePickerSelectProps === void 0 ? void 0 : datePickerSelectProps.styles)
  });
  var timePickerSelectProps = timePickerPropsWithSelectProps.selectProps,
    timePickerProps = _objectWithoutProperties(timePickerPropsWithSelectProps, _excluded2);
  var timePickerAriaDescribedBy = timePickerProps['aria-describedby'] || ariaDescribedBy;
  var timePickerLabel = timePickerProps.label || timePickerDefaultAriaLabel;
  var mergedTimePickerSelectProps = _objectSpread(_objectSpread({}, timePickerSelectProps), {}, {
    styles: mergeStyles(styles, timePickerSelectProps === null || timePickerSelectProps === void 0 ? void 0 : timePickerSelectProps.styles)
  });

  // Render DateTimePicker's IconContainer when a value has been filled
  // Don't use Date or TimePicker's because they can't be customised
  var isClearable = Boolean(dateValue || timeValue);
  return /*#__PURE__*/React.createElement(DateTimePickerContainer, {
    appearance: appearance,
    isDisabled: isDisabled,
    isFocused: isFocused,
    isInvalid: isInvalid,
    testId: testId,
    innerProps: innerProps
  }, /*#__PURE__*/React.createElement("input", {
    name: name,
    type: "hidden",
    value: value,
    "data-testid": testId && "".concat(testId, "--input")
  }), /*#__PURE__*/React.createElement(Box, {
    xcss: compiledStyles.datePickerContainerStyles
  }, /*#__PURE__*/React.createElement(DatePicker, {
    appearance: appearance,
    "aria-describedby": datePickerAriaDescribedBy,
    autoFocus: datePickerProps.autoFocus || autoFocus,
    dateFormat: datePickerProps.dateFormat,
    defaultIsOpen: datePickerProps.defaultIsOpen,
    defaultValue: datePickerProps.defaultValue,
    disabled: datePickerProps.disabled,
    disabledDateFilter: datePickerProps.disabledDateFilter,
    formatDisplayLabel: datePickerProps.formatDisplayLabel,
    hideIcon: datePickerProps.hideIcon || true,
    icon: datePickerProps.icon,
    id: datePickerProps.id || id,
    innerProps: datePickerProps.innerProps,
    inputLabel: datePickerProps.inputLabel,
    inputLabelId: datePickerProps.inputLabelId,
    isDisabled: datePickerProps.isDisabled || isDisabled,
    isInvalid: datePickerProps.isInvalid || isInvalid,
    isOpen: datePickerProps.isOpen,
    isRequired: datePickerProps.isRequired || isRequired,
    label: datePickerLabel,
    locale: datePickerProps.locale || locale,
    maxDate: datePickerProps.maxDate,
    minDate: datePickerProps.minDate,
    name: datePickerProps.name,
    nextMonthLabel: datePickerProps.nextMonthLabel,
    onBlur: onDateBlur,
    onChange: onDateChange,
    onFocus: onDateFocus,
    openCalendarLabel: datePickerProps.openCalendarLabel,
    parseInputValue: datePickerProps.parseInputValue,
    placeholder: datePickerProps.placeholder,
    previousMonthLabel: datePickerProps.previousMonthLabel,
    selectProps: mergedDatePickerSelectProps,
    shouldShowCalendarButton: datePickerProps.shouldShowCalendarButton,
    spacing: datePickerProps.spacing || spacing,
    testId: testId && "".concat(testId, "--datepicker") || datePickerProps.testId,
    value: dateValue,
    weekStartDay: datePickerProps.weekStartDay
  })), /*#__PURE__*/React.createElement(Box, {
    xcss: compiledStyles.timePickerContainerStyles
  }, /*#__PURE__*/React.createElement(TimePicker, {
    appearance: timePickerProps.appearance || appearance,
    "aria-describedby": timePickerAriaDescribedBy,
    autoFocus: timePickerProps.autoFocus,
    defaultIsOpen: timePickerProps.defaultIsOpen,
    defaultValue: timePickerProps.defaultValue,
    formatDisplayLabel: timePickerProps.formatDisplayLabel,
    hideIcon: timePickerProps.hideIcon || true,
    id: timePickerProps.id,
    innerProps: timePickerProps.innerProps,
    isDisabled: timePickerProps.isDisabled || isDisabled,
    isInvalid: timePickerProps.isInvalid || isInvalid,
    isOpen: timePickerProps.isOpen,
    isRequired: timePickerProps.isRequired || isRequired,
    label: timePickerLabel,
    locale: timePickerProps.locale || locale,
    name: timePickerProps.name,
    onBlur: onTimeBlur,
    onChange: onTimeChange,
    onFocus: onTimeFocus,
    parseInputValue: timePickerProps.parseInputValue,
    placeholder: timePickerProps.placeholder,
    selectProps: mergedTimePickerSelectProps,
    spacing: timePickerProps.spacing || spacing,
    testId: timePickerProps.testId || testId && "".concat(testId, "--timepicker"),
    timeFormat: timePickerProps.timeFormat,
    timeIsEditable: timePickerProps.timeIsEditable,
    times: timePickerProps.times,
    value: timeValue
  })), isClearable && !isDisabled ? /*#__PURE__*/React.createElement(Inline, {
    xcss: compiledStyles.iconContainerStyles
  }, /*#__PURE__*/React.createElement(IconButton, {
    appearance: "subtle",
    label: clearControlLabel,
    icon: function icon(iconProps) {
      return /*#__PURE__*/React.createElement(SelectClearIcon, _extends({}, iconProps, {
        color: "var(--ds-text-subtlest, #6B6E76)",
        size: "small"
      }));
    },
    onClick: onClear,
    testId: testId && "".concat(testId, "--icon--container"),
    tabIndex: -1
  })) : null);
});
export default DateTimePicker;