// ==============================
// NO OP
// ==============================

export const noop = () => {};

// ==============================
// Class Name Prefixer
// ==============================

/**
 * String representation of component state for styling with class names.
 *
 * Expects an array of strings OR a string/object pair:
 * - className(['comp', 'comp-arg', 'comp-arg-2'])
 * @returns 'react-select__comp react-select__comp-arg react-select__comp-arg-2'
 * - className('comp', { some: true, state: false })
 * @returns 'react-select__comp react-select__comp--some'
 */
function applyPrefixToName(prefix, name) {
  if (!name) {
    return prefix;
  } else if (name[0] === '-') {
    return prefix + name;
  } else {
    return prefix + '__' + name;
  }
}
export function classNames(prefix, state, ...classNameList) {
  const arr = [...classNameList];
  if (state && prefix) {
    for (let key in state) {
      if (state.hasOwnProperty(key) && state[key]) {
        arr.push(`${applyPrefixToName(prefix, key)}`);
      }
    }
  }
  return arr.filter(i => i).map(i => String(i).trim()).join(' ');
}
// ==============================
// Clean Value
// ==============================

export const cleanValue = value => {
  if (isArray(value)) {
    return value.filter(Boolean);
  }
  if (typeof value === 'object' && value !== null) {
    return [value];
  }
  return [];
};

// ==============================
// Clean Common Props
// ==============================

export const cleanCommonProps = props => {
  //className
  const {
    className,
    // not listed in commonProps documentation, needs to be removed to allow Emotion to generate classNames
    clearValue,
    cx,
    xcss,
    getStyles,
    getClassNames,
    getValue,
    hasValue,
    isMulti,
    isRtl,
    options,
    // not listed in commonProps documentation
    selectOption,
    selectProps,
    setValue,
    ...innerProps
  } = props;
  return {
    ...innerProps
  };
};

// ==============================
// Get Style Props
// ==============================

export const getStyleProps = (props, name, classNamesState) => {
  const {
    cx,
    getStyles,
    getClassNames,
    className
  } = props;
  return {
    css: getStyles(name, props),
    className: cx(classNamesState !== null && classNamesState !== void 0 ? classNamesState : {}, getClassNames(name, props), className)
  };
};

// ==============================
// Handle Input Change
// ==============================

export function handleInputChange(inputValue, actionMeta, onInputChange) {
  if (onInputChange) {
    const newValue = onInputChange(inputValue, actionMeta);
    if (typeof newValue === 'string') {
      return newValue;
    }
  }
  return inputValue;
}

// ==============================
// Scroll Helpers
// ==============================

export function isDocumentElement(el) {
  return [document.documentElement, document.body, window].indexOf(el) > -1;
}

// Normalized Scroll Top
// ------------------------------

export function normalizedHeight(el) {
  if (isDocumentElement(el)) {
    return window.innerHeight;
  }
  return el.clientHeight;
}

// Normalized scrollTo & scrollTop
// ------------------------------

export function getScrollTop(el) {
  if (isDocumentElement(el)) {
    return window.pageYOffset;
  }
  return el.scrollTop;
}
export function scrollTo(el, top) {
  // with a scroll distance, we perform scroll on the element
  if (isDocumentElement(el)) {
    window.scrollTo(0, top);
    return;
  }
  el.scrollTop = top;
}

// Get Scroll Parent
// ------------------------------

export function getScrollParent(element) {
  let style = getComputedStyle(element);
  const excludeStaticParent = style.position === 'absolute';
  const overflowRx = /(auto|scroll)/;
  if (style.position === 'fixed') {
    return document.documentElement;
  }
  for (let parent = element; parent = parent.parentElement;) {
    style = getComputedStyle(parent);
    if (excludeStaticParent && style.position === 'static') {
      continue;
    }
    if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
      return parent;
    }
  }
  return document.documentElement;
}

// Animated Scroll To
// ------------------------------

/**
 * @param t: time (elapsed)
 * @param b: initial value
 * @param c: amount of change
 * @param d: duration
 */
function easeOutCubic(t, b, c, d) {
  return c * ((t = t / d - 1) * t * t + 1) + b;
}
export function animatedScrollTo(element, to, duration = 200, callback = noop) {
  const start = getScrollTop(element);
  const change = to - start;
  const increment = 10;
  let currentTime = 0;
  function animateScroll() {
    currentTime += increment;
    const val = easeOutCubic(currentTime, start, change, duration);
    scrollTo(element, val);
    if (currentTime < duration) {
      window.requestAnimationFrame(animateScroll);
    } else {
      callback(element);
    }
  }
  animateScroll();
}

// Scroll Into View
// ------------------------------

export function scrollIntoView(menuEl, focusedEl) {
  const menuRect = menuEl.getBoundingClientRect();
  const focusedRect = focusedEl.getBoundingClientRect();
  const overScroll = focusedEl.offsetHeight / 3;
  if (focusedRect.bottom + overScroll > menuRect.bottom) {
    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
  } else if (focusedRect.top - overScroll < menuRect.top) {
    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
  }
}

// ==============================
// Get bounding client object
// ==============================

// cannot get keys using array notation with DOMRect
export function getBoundingClientObj(element) {
  const rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
}

// ==============================
// Touch Capability Detector
// ==============================

export function isTouchCapable() {
  try {
    document.createEvent('TouchEvent');
    return true;
  } catch {
    return false;
  }
}

// ==============================
// Mobile Device Detector
// ==============================

export function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch {
    return false;
  }
}

// ==============================
// Passive Event Detector
// ==============================

// https://github.com/rafgraph/detect-it/blob/main/src/index.ts#L19-L36
let passiveOptionAccessed = false;
const options = {
  get passive() {
    return passiveOptionAccessed = true;
  }
};
// check for SSR
const w = typeof window !== 'undefined' ? window : {};
if (w.addEventListener && w.removeEventListener) {
  // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
  w.addEventListener('p', noop, options);
  // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
  w.removeEventListener('p', noop, false);
}
export const supportsPassiveEvents = passiveOptionAccessed;
export function notNullish(item) {
  return item != null;
}
function isArray(arg) {
  return Array.isArray(arg);
}
export function valueTernary(isMulti, multiValue, singleValue) {
  return isMulti ? multiValue : singleValue;
}
export function singleValueAsValue(singleValue) {
  return singleValue;
}
export function multiValueAsValue(multiValue) {
  return multiValue;
}
export const removeProps = (propsObj, ...properties) => {
  let propsMap = Object.entries(propsObj).filter(([key]) => !properties.includes(key));
  return propsMap.reduce((newProps, [key, val]) => {
    newProps[key] = val;
    return newProps;
  }, {});
};

/**
 * Filters out unsupported selectors (e.g., pseudo-classes, complex selectors) from a styles object.
 * @param styles - The styles object to filter.
 * @returns A new object containing only supported styles.
 */
export const filterUnsupportedSelectors = styles => {
  const unsupportedSelectors = [':',
  // pseudo-classes/elements
  '[',
  // attribute selectors
  '>',
  // child combinator
  '+',
  // adjacent sibling combinator
  '~',
  // general sibling combinator
  ' ',
  // descendant combinator
  '*',
  // universal selector
  '#',
  // ID selector
  '.',
  // class selector
  '@',
  // at-rules
  '&',
  // parent selector
  '|',
  // namespace separator
  '^',
  // starts with
  '$',
  // ends with
  '=' // equals
  ];
  return Object.keys(styles).reduce((filteredStyles, key) => {
    if (!unsupportedSelectors.some(selector => key.includes(selector))) {
      filteredStyles[key] = styles[key];
    }
    return filteredStyles;
  }, {});
};