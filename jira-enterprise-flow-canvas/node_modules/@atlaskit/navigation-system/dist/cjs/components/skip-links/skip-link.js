/* skip-link.tsx generated by @compiled/babel-plugin v0.38.1 */
"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SkipLink = void 0;
require("./skip-link.compiled.css");
var _runtime = require("@compiled/react/runtime");
var _react = _interopRequireWildcard(require("react"));
var _bindEventListener = require("bind-event-listener");
var _primitives = require("@atlaskit/primitives");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
// eslint-disable-next-line @atlaskit/design-system/no-emotion-primitives -- to be migrated to @atlaskit/primitives/compiled â€“ go/akcss
var styles = {
  skipLinkListItem: "_1pfhze3t"
};

/**
 * Used for moving focus to the corresponding slot or custom target after clicking on a skip link.
 */
function focusElement(element) {
  /**
   * Elements without an explicit `tabindex` attribute are not guaranteed to be focusable:
   * https://html.spec.whatwg.org/multipage/interaction.html#attr-tabindex
   *
   * Our slots are not interactive, so this is required.
   *
   * In the future we may want to check if there is an existing `tabindex` attribute,
   * as custom skip linked elements might already have one.
   */
  element.setAttribute('tabindex', '-1');

  /**
   * Cleanup the `tabindex` attribute we set when the slot or custom target loses focus.
   *
   * This is preferable to always having `tabindex="-1"` because always applying the tab index can:
   *
   * - mess with click events
   * - potentially cause a focus ring to be always visible
   */
  (0, _bindEventListener.bind)(element, {
    type: 'blur',
    listener: function listener() {
      element.removeAttribute('tabindex');
    },
    options: {
      // Using a one-time listener so it cleans itself up
      once: true
    }
  });

  /**
   * Move focus to the slot or custom target.
   *
   * Calling `.focus()` will also scroll the element into view:
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus
   */
  element.focus({
    // Forces the focus ring to appear after moving focus to the slot
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus#focusvisible
    // @ts-expect-error - new and not in types yet
    focusVisible: true
  });
}

/**
 * A link that moves current tab position to a different element
 *
 * This component is rendered internally and is not exported publicly.
 */
var SkipLink = exports.SkipLink = function SkipLink(_ref) {
  var id = _ref.id,
    children = _ref.children,
    onBeforeNavigate = _ref.onBeforeNavigate;
  var href = "#".concat(id);
  var onClick = (0, _react.useCallback)(function (event) {
    event.preventDefault();

    // Intentionally not using `document.querySelector` because many valid IDs are not valid selectors.
    var target = document.getElementById(id);
    if (!target) {
      return;
    }

    /**
     * Internal slots can attach an `onBeforeNavigate` callback.
     *
     * Side nav uses this to ensure it is expanded.
     */
    onBeforeNavigate === null || onBeforeNavigate === void 0 || onBeforeNavigate();
    focusElement(target);

    /**
     * We should look into removing this, or only calling it in specific cases.
     *
     * It means if the skip link element is in the window scroll container
     * then it might not get scrolled into view properly.
     *
     * This is not an issue for the default slots on desktop, but could break custom skip links or
     * even `Aside` on mobile.
     *
     * Keeping existing behavior for now because resetting the window scroll is actually good for some cases.
     * E.g. jumping to main / aside it makes sense to look at the start of the content.
     */
    window.scrollTo(0, 0);
  }, [id, onBeforeNavigate]);
  return /*#__PURE__*/_react.default.createElement("li", {
    className: (0, _runtime.ax)([styles.skipLinkListItem])
  }, /*#__PURE__*/_react.default.createElement(_primitives.Anchor
  /**
   * It looks like Safari handles link clicks during `pointerdown` unless it has an explicit `tabIndex={0}` :/
   *
   * Adding this explicitly makes the behavior consistent between browsers and lets us `event.preventDefault()`
   * in the `onClick` handler.
   */, {
    tabIndex: 0,
    href: href,
    onClick: onClick
  }, children));
};