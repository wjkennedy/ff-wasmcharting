"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.invokeService = exports.invokeRemote = void 0;
const errors_1 = require("./errors");
const fetch_1 = require("./fetch");
var InvokeType;
(function (InvokeType) {
    InvokeType["REMOTE"] = "Remote";
    InvokeType["CONTAINER"] = "Service";
})(InvokeType || (InvokeType = {}));
async function invokeRemote(remoteKey, options) {
    return invokeEndpoint(remoteKey, options, InvokeType.REMOTE);
}
exports.invokeRemote = invokeRemote;
async function invokeService(serviceKey, options) {
    return invokeEndpoint(serviceKey, options, InvokeType.CONTAINER);
}
exports.invokeService = invokeService;
async function invokeEndpoint(key, options, type) {
    const { path, ...fetchOptions } = options;
    if (!key) {
        throw new Error(`Missing ${type.toLowerCase()} key provided to invoke${type}`);
    }
    if (!path) {
        throw new Error(`Missing or empty path provided to invoke${type}`);
    }
    const response = await global.__forge_fetch__(constructInvokePayload(key, type), path, fetchOptions);
    handleResponseErrors(response, key);
    return response;
}
function constructInvokePayload(key, type) {
    switch (type) {
        case InvokeType.REMOTE:
            return {
                type: 'frc',
                remote: key
            };
        case InvokeType.CONTAINER:
            return {
                type: 'fcc',
                service: key
            };
    }
}
function handleResponseErrors(response, key) {
    const forgeProxyError = (0, fetch_1.getForgeProxyError)(response);
    if (forgeProxyError === 'INVALID_SERVICE_KEY') {
        throw new errors_1.InvalidContainerServiceError(`Invalid service key provided: "${key}"`, key);
    }
    else if (forgeProxyError === 'INVALID_REMOTE') {
        throw new errors_1.InvalidRemoteError(`Invalid remote key provided: "${key}"`, key);
    }
    (0, fetch_1.handleProxyResponseErrors)(response);
}
