"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bindInvocationContext = exports.wrapInMetrics = exports.getAppContext = exports.__getRuntime = exports.MissingPermissions = exports.PermissionRequirements = exports.RuntimePermissions = exports.Permissions = void 0;
const errors_1 = require("./errors");
const ari_1 = require("./ari");
const extractUrlString = (item) => {
    if (typeof item === 'string') {
        return item;
    }
    else if ('address' in item) {
        return item.address;
    }
    else {
        return item.remote;
    }
};
const formatScopesSection = (scopes) => {
    if (scopes && Array.isArray(scopes) && scopes.length > 0) {
        return `Scopes: ${scopes.join(', ')}`;
    }
    return null;
};
const formatExternalSection = (external) => {
    if (!external) {
        return null;
    }
    const externalParts = [];
    Object.keys(external).forEach((type) => {
        if (type === 'fetch') {
            const fetchParts = getFetchPermissions(external.fetch);
            externalParts.push(...fetchParts);
        }
        else {
            const externalUrls = external[type];
            if (externalUrls && Array.isArray(externalUrls) && externalUrls.length > 0) {
                const capitalizedType = type.charAt(0).toUpperCase() + type.slice(1);
                const urlList = externalUrls.map(extractUrlString).join(', ');
                externalParts.push(`${capitalizedType}: ${urlList}`);
            }
        }
    });
    return externalParts.length > 0 ? `External: ${externalParts.join('; ')}` : null;
};
const getFetchPermissions = (fetch) => {
    if (!fetch) {
        return [];
    }
    const fetchParts = [];
    Object.keys(fetch).forEach((fetchType) => {
        const urls = fetch[fetchType];
        if (urls && urls.length > 0) {
            const urlList = urls.map(extractUrlString).join(', ');
            const capitalizedType = fetchType.charAt(0).toUpperCase() + fetchType.slice(1);
            fetchParts.push(`Fetch ${capitalizedType}: ${urlList}`);
        }
    });
    return fetchParts;
};
class Permissions {
    format() {
        const parts = [];
        const scopesSection = formatScopesSection(this.scopes);
        if (scopesSection) {
            parts.push(scopesSection);
        }
        const externalSection = formatExternalSection(this.external);
        if (externalSection) {
            parts.push(externalSection);
        }
        return parts.length > 0 ? parts.join('; ') : 'No permissions specified';
    }
}
exports.Permissions = Permissions;
class RuntimePermissions extends Permissions {
    scopes;
    external;
    constructor(scopes, external) {
        super();
        this.scopes = scopes;
        this.external = external;
    }
}
exports.RuntimePermissions = RuntimePermissions;
class PermissionRequirements extends Permissions {
    scopes;
    external;
    constructor(scopes, external) {
        super();
        this.scopes = scopes;
        this.external = external;
    }
}
exports.PermissionRequirements = PermissionRequirements;
class MissingPermissions extends Permissions {
    scopes;
    external;
    constructor(scopes, external) {
        super();
        this.scopes = scopes;
        this.external = external;
    }
}
exports.MissingPermissions = MissingPermissions;
function __getRuntime() {
    const runtime = global.__forge_runtime__;
    if (!runtime) {
        throw new Error('Forge runtime not found.');
    }
    return runtime;
}
exports.__getRuntime = __getRuntime;
function getAppContext() {
    const runtime = __getRuntime();
    const { appId, appVersion, environmentId, environmentType, invocationId, installationId, moduleKey, license, installation, permissions } = runtime.appContext;
    const invocationRemainingTimeInMillis = runtime.lambdaContext.getRemainingTimeInMillis ??
        (() => {
            throw new Error('Lambda remaining time is not available. If tunnelling, update Forge CLI to the latest version.');
        });
    return {
        appAri: (0, ari_1.getAppAri)(appId),
        appVersion,
        environmentAri: (0, ari_1.getEnvironmentAri)(appId, environmentId),
        environmentType,
        installationAri: (0, ari_1.getInstallationAri)(installationId),
        invocationId,
        invocationRemainingTimeInMillis,
        moduleKey,
        license,
        installation,
        permissions: new RuntimePermissions(permissions?.scopes || [], permissions?.external || {})
    };
}
exports.getAppContext = getAppContext;
function wrapInMetrics(name, fn) {
    return async (...args) => {
        const { metrics } = __getRuntime();
        metrics.counter(name).incr();
        const timer = metrics.timing(name).measure();
        let success = true;
        try {
            return await fn(...args);
        }
        catch (e) {
            const undiciError = global.__forge_undici_error__;
            if (e instanceof errors_1.ProxyRequestError ||
                (undiciError && typeof undiciError === 'function' && e instanceof undiciError)) {
                success = false;
            }
            throw e;
        }
        finally {
            timer.stop({ success: success.toString() });
        }
    };
}
exports.wrapInMetrics = wrapInMetrics;
function bindInvocationContext(fn) {
    const AsyncLocalStorage = require('async_hooks').AsyncLocalStorage;
    return AsyncLocalStorage.bind(fn);
}
exports.bindInvocationContext = bindInvocationContext;
