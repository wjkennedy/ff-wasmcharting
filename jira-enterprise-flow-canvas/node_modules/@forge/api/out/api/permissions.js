"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.permissions = exports.canLoadResource = exports.canFetchFrom = exports.hasScope = exports.hasPermission = exports.extractUrlString = void 0;
const runtime_1 = require("./runtime");
const errors_1 = require("./errors");
const egress_1 = require("@forge/egress");
function extractUrlString(url) {
    if (typeof url === 'string') {
        return url;
    }
    if ('address' in url) {
        return url.address;
    }
    return url.remote;
}
exports.extractUrlString = extractUrlString;
function wrapInSyncMetrics(options, cb) {
    const metrics = (0, runtime_1.__getRuntime)().metrics;
    metrics.counter(options.name, options.tags).incr();
    return cb();
}
const getMissingScopes = (requiredScopes, currentlyGrantedScopes) => {
    if (!requiredScopes) {
        return undefined;
    }
    if (Array.isArray(requiredScopes) && requiredScopes.length > 0) {
        const currentGrantedScopes = Array.isArray(currentlyGrantedScopes) ? currentlyGrantedScopes : [];
        const missingScopes = requiredScopes.filter((scope) => !currentGrantedScopes.includes(scope));
        if (missingScopes.length > 0) {
            return missingScopes;
        }
    }
    return undefined;
};
const getMissingUrls = (requiredUrls, currentlyGrantedUrls, useCSP) => {
    const allowList = currentlyGrantedUrls.map((url) => extractUrlString(url));
    const egressFilter = new egress_1.EgressFilteringService(allowList);
    const missingUrls = requiredUrls.filter((requiredUrl) => {
        const urlString = extractUrlString(requiredUrl);
        if (useCSP) {
            return !egressFilter.isValidUrlCSP(urlString);
        }
        return !egressFilter.isValidUrl(urlString);
    });
    return missingUrls;
};
const VALID_REQUIREMENT_KEYS = ['scopes', 'external'];
const VALID_EXTERNAL_TYPES = [
    'fetch',
    'fonts',
    'frames',
    'images',
    'media',
    'scripts',
    'styles',
    'configurable'
];
const VALID_FETCH_TYPES = ['backend', 'client'];
const validateKeys = (obj, validKeys) => {
    const validKeysSet = new Set(validKeys);
    const providedKeys = Object.keys(obj);
    const invalidKeys = providedKeys.filter((key) => !validKeysSet.has(key));
    if (invalidKeys.length > 0) {
        throw new Error(`Invalid permission key(s): ${invalidKeys.join(', ')}. ` +
            `Visit https://go.atlassian.com/forge-permissions for more information.`);
    }
};
const validatePermissionRequirements = (requirements) => {
    validateKeys(requirements, VALID_REQUIREMENT_KEYS);
    if (requirements.external) {
        validateKeys(requirements.external, VALID_EXTERNAL_TYPES);
        if (requirements.external.fetch) {
            validateKeys(requirements.external.fetch, VALID_FETCH_TYPES);
        }
    }
};
const getMissingFetchPermissions = (requiredFetch, currentlyGrantedFetch) => {
    if (!requiredFetch) {
        return undefined;
    }
    const missingFetch = {};
    Object.keys(requiredFetch).forEach((fetchType) => {
        const requiredUrls = requiredFetch[fetchType];
        if (!requiredUrls || !Array.isArray(requiredUrls) || requiredUrls.length === 0)
            return;
        const missingUrls = getMissingUrls(requiredUrls, currentlyGrantedFetch?.[fetchType] ?? [], fetchType === 'client');
        if (missingUrls.length) {
            missingFetch[fetchType] = missingUrls.map(extractUrlString);
        }
    });
    return Object.keys(missingFetch).length ? missingFetch : undefined;
};
const getMissingExternalPermissions = (requiredExternal, currentGrantedExternal) => {
    let missingExternal = undefined;
    Object.keys(requiredExternal).forEach((type) => {
        if (type === 'fetch') {
            const missingFetchPerms = getMissingFetchPermissions(requiredExternal.fetch, currentGrantedExternal.fetch);
            if (missingFetchPerms) {
                if (!missingExternal) {
                    missingExternal = {};
                }
                missingExternal.fetch = missingFetchPerms;
            }
            return;
        }
        if (type === 'configurable') {
            return;
        }
        const externalUrls = requiredExternal[type];
        if (!externalUrls || !Array.isArray(externalUrls) || externalUrls.length === 0) {
            return;
        }
        const missingUrls = getMissingUrls(externalUrls, currentGrantedExternal[type] || [], true);
        if (missingUrls.length > 0) {
            if (!missingExternal) {
                missingExternal = {};
            }
            missingExternal[type] = missingUrls.map(extractUrlString);
        }
    });
    return missingExternal;
};
const hasPermission = (requirements) => {
    return wrapInSyncMetrics({ name: 'api.permissions.hasPermission' }, () => hasPermissionWithoutMetrics(requirements));
};
exports.hasPermission = hasPermission;
const hasPermissionWithoutMetrics = (requirements) => {
    const appContext = (0, runtime_1.getAppContext)();
    const currentlyGrantedPermissions = appContext.permissions;
    const arePermissionsAvailable = !!(currentlyGrantedPermissions && typeof currentlyGrantedPermissions === 'object');
    if (!arePermissionsAvailable) {
        throw new errors_1.ApiNotReadyError('This feature is not available yet');
    }
    validatePermissionRequirements(requirements);
    const missingPermissions = {};
    let hasMissingPermissions = false;
    const missingScopes = getMissingScopes(requirements.scopes, currentlyGrantedPermissions.scopes);
    if (missingScopes) {
        missingPermissions.scopes = missingScopes;
        hasMissingPermissions = true;
    }
    if (requirements.external) {
        const { external: requiredExternal } = requirements;
        const currentlyGrantedExternal = currentlyGrantedPermissions.external || {};
        const missingExternalPerms = getMissingExternalPermissions(requiredExternal, currentlyGrantedExternal);
        if (missingExternalPerms) {
            missingPermissions.external = {
                ...missingPermissions.external,
                ...missingExternalPerms
            };
            hasMissingPermissions = true;
        }
    }
    return {
        granted: !hasMissingPermissions,
        ...(hasMissingPermissions && {
            missing: new runtime_1.MissingPermissions(missingPermissions.scopes, missingPermissions.external)
        })
    };
};
const hasScope = (scope) => {
    return wrapInSyncMetrics({ name: 'api.permissions.hasScope' }, () => hasPermissionWithoutMetrics({ scopes: [scope] }).granted);
};
exports.hasScope = hasScope;
const canFetchFrom = (type, url) => {
    return wrapInSyncMetrics({ name: 'api.permissions.canFetchFrom' }, () => hasPermissionWithoutMetrics({ external: { fetch: { [type]: [url] } } }).granted);
};
exports.canFetchFrom = canFetchFrom;
const canLoadResource = (type, url) => {
    return wrapInSyncMetrics({ name: 'api.permissions.canLoadResource' }, () => hasPermissionWithoutMetrics({ external: { [type]: [url] } }).granted);
};
exports.canLoadResource = canLoadResource;
exports.permissions = {
    hasPermission: exports.hasPermission,
    hasScope: exports.hasScope,
    canFetchFrom: exports.canFetchFrom,
    canLoadResource: exports.canLoadResource
};
