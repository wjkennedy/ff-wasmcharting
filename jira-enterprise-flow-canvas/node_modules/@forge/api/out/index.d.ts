import { EntityStorageApi, QueryApi } from '@forge/storage';
import { invokeRemote, invokeService } from './api/endpoint';
import { __fetchProduct, __requestAtlassianAsApp, __requestAtlassianAsUser } from './api/fetch';
import { authorize } from './authorization';
import { Route } from './safeUrl';
import { webTrigger, WebTriggerContext, WebTriggerMethod, WebTriggerRequest, WebTriggerResponse } from './webTrigger';
export interface RequestInit {
    body?: ArrayBuffer | string | URLSearchParams;
    headers?: Record<string, string>;
    method?: string;
    redirect?: RequestRedirect;
    signal?: AbortSignal;
}
export interface Headers {
    append: (name: string, value: string) => void;
    delete: (name: string) => void;
    get: (name: string) => string | null;
    has: (name: string) => boolean;
    set: (name: string, value: string) => void;
    forEach: (callbackfn: (value: string, key: string) => void) => void;
}
export interface Response {
    json: () => Promise<any>;
    text: () => Promise<string>;
    arrayBuffer: () => Promise<ArrayBuffer>;
    ok: boolean;
    status: number;
    statusText: string;
    headers: Headers;
}
export declare type APIResponse = Response;
export declare type FetchMethod = (url: string, init?: RequestInit) => Promise<APIResponse>;
export declare type FetchMethodAllowingRoute = (url: string | Route, init?: RequestInit) => Promise<APIResponse>;
export declare type RequestProductMethod = (url: Route, init?: RequestInit) => Promise<APIResponse>;
export declare type FetchOptions = RequestInit;
export interface RequestProductMethods {
    requestJira: RequestProductMethod;
    requestConfluence: RequestProductMethod;
    requestBitbucket: RequestProductMethod;
}
export interface GraphQLFetchMethods {
    requestGraph: (query: string, variables?: any, headers?: Record<string, any>) => Promise<APIResponse>;
}
export interface TeamworkGraphFetchMethods {
    requestTeamworkGraph: (query: string, variables?: any, operationName?: string, extensions?: any, headers?: Record<string, any>) => Promise<APIResponse>;
}
export interface ConnectedDataFetchMethods {
    requestConnectedData: RequestProductMethod;
}
export interface RequestAtlassianMethods {
    requestAtlassian: RequestProductMethod;
}
export interface ExternalAuthAccount {
    id: string;
    displayName: string;
    avatarUrl?: string;
    scopes: string[];
}
export interface ExternalAuthAccountMethods {
    hasCredentials: (scopes?: string[]) => Promise<boolean>;
    requestCredentials: (scopes?: string[]) => Promise<boolean>;
    fetch: FetchMethodAllowingRoute;
    getAccount: () => Promise<ExternalAuthAccount | undefined>;
}
export interface ExternalAuthFetchMethods extends ExternalAuthAccountMethods {
    listCredentials: () => Promise<string[]>;
    listAccounts: () => Promise<ExternalAuthAccount[]>;
    asAccount: (externalAccountId: string) => ExternalAuthAccountMethods;
}
export interface ExternalAuthFetchMethodsProvider {
    withProvider: (provider: string, remoteName?: string, tokenId?: string) => ExternalAuthFetchMethods;
}
export interface StorageMethods {
    get: (key: string) => Promise<any>;
    set: (key: string, value: string | number | boolean | Record<string, any> | any[]) => Promise<void>;
    delete: (key: string) => Promise<void>;
}
export interface StorageAPI extends StorageMethods, QueryApi, EntityStorageApi {
}
export interface ForgeStorageAPI extends StorageAPI {
    getSecret: (key: string) => Promise<any>;
    setSecret: (key: string, value: any) => Promise<void>;
    deleteSecret: (key: string) => Promise<void>;
}
declare type AsUserFetchMethods = RequestProductMethods & GraphQLFetchMethods & ConnectedDataFetchMethods & ExternalAuthFetchMethodsProvider & RequestAtlassianMethods & TeamworkGraphFetchMethods;
declare type AsAppFetchMethods = RequestProductMethods & GraphQLFetchMethods & ConnectedDataFetchMethods & RequestAtlassianMethods;
export interface FetchAPI extends RequestProductMethods {
    asUser(userId?: string): AsUserFetchMethods;
    asApp(): AsAppFetchMethods;
    fetch: FetchMethodAllowingRoute;
}
export interface ForgeAPI extends FetchAPI {
    invokeRemote: typeof invokeRemote;
    invokeService: typeof invokeService;
}
declare const asUser: (userId?: string) => AsUserFetchMethods;
declare const asApp: () => AsAppFetchMethods;
declare const fetch: FetchMethodAllowingRoute;
declare const requestJira: RequestProductMethod;
declare const requestConfluence: RequestProductMethod;
declare const requestBitbucket: RequestProductMethod;
declare const storage: ForgeStorageAPI;
declare const API: ForgeAPI;
export declare const privacy: {
    reportPersonalData: (accounts: import("./privacy").Account[]) => Promise<import("./privacy").AccountUpdate[]>;
};
export default API;
export { __fetchProduct, __requestAtlassianAsApp, __requestAtlassianAsUser, asApp, asUser, authorize, fetch, invokeRemote, invokeService, requestBitbucket, requestConfluence, requestJira, storage, webTrigger, WebTriggerContext, WebTriggerMethod, WebTriggerRequest, WebTriggerResponse };
export declare const createRequestStargateAsApp: () => FetchMethod;
export { Condition, EntityStorageApi, FilterConditions, FilterPredicate, ListResult, Predicate, QueryApi, QueryBuilder, Result, SortOrder, startsWith, Value, WhereConditions, WherePredicate } from '@forge/storage';
export { ExternalEndpointNotAllowedError, FetchError, FUNCTION_ERR, HttpError, InvalidWorkspaceRequestedError, isExpectedError, isForgePlatformError, isHostedCodeError, NeedsAuthenticationError, NeedsAuthenticationErrorOptions, NotAllowedError, ProductEndpointNotAllowedError, ProxyRequestError, RequestProductNotAllowedError } from './api/errors';
export { __getRuntime, AppContext, bindInvocationContext, ForgeRuntime, getAppContext } from './api/runtime';
export { assumeTrustedRoute, route, Route, routeFromAbsolute } from './safeUrl';
export { i18n, type TranslationFunction } from './api/i18n';
export { permissions } from './api/permissions';
//# sourceMappingURL=index.d.ts.map