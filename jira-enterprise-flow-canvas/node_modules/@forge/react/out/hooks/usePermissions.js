"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.usePermissions = void 0;
const react_1 = require("react");
const bridge_1 = require("@forge/bridge");
/**
 * Hook for checking permissions in Forge apps
 *
 * @param requiredPermissions - The permissions required for the component
 * @returns Object containing permission state, loading status, and error information
 * @returns hasPermission - Whether all required permissions are granted
 * @returns isLoading - Whether the permission check is still in progress
 * @returns missingPermissions - Details about which permissions are missing (null if all granted)
 * @returns error - Any error that occurred during permission checking (null if no error)
 *
 * @example
 * ```tsx
 * const MyComponent: React.FC = () => {
 *   const { hasPermission, isLoading, missingPermissions, error } = usePermissions({
 *     scopes: ['write:confluence-content'],
 *     external: {
 *       fetch: {
 *         backend: ['https://api.example.com']
 *       }
 *     }
 *   });
 *
 *   if (isLoading) return <LoadingSpinner />;
 *
 *   if (error) {
 *     return <ErrorMessage error={error} />;
 *   }
 *
 *   if (!hasPermission) {
 *     return <PermissionDenied missingPermissions={missingPermissions} />;
 *   }
 *
 *   return <ProtectedFeature />;
 * };
 * ```
 */
const usePermissions = (requiredPermissions) => {
    const [context, setContext] = (0, react_1.useState)();
    const [isLoading, setIsLoading] = (0, react_1.useState)(true);
    const [error, setError] = (0, react_1.useState)(null);
    const [permissionResult, setPermissionResult] = (0, react_1.useState)({
        granted: false,
        missing: null
    });
    // Load context on mount
    (0, react_1.useEffect)(() => {
        const loadContext = async () => {
            try {
                setIsLoading(true);
                setError(null);
                const contextData = await bridge_1.view.getContext();
                setContext(contextData);
            }
            catch (err) {
                setError(err instanceof Error ? err : new Error('Failed to load context'));
            }
            finally {
                setIsLoading(false);
            }
        };
        void loadContext();
    }, []);
    // Check permissions using shared utility
    (0, react_1.useEffect)(() => {
        // Skip if still loading context
        if (isLoading) {
            return;
        }
        const checkPerms = async () => {
            if (!requiredPermissions) {
                setPermissionResult({ granted: false, missing: null });
                return;
            }
            if (!context?.permissions) {
                // If context loaded but has no permissions, set error
                if (context !== undefined) {
                    setError(new Error('This feature is not available yet'));
                    setPermissionResult({ granted: false, missing: null });
                }
                return;
            }
            try {
                setError(null); // Clear any previous errors
                const result = await (0, bridge_1.checkPermissions)(requiredPermissions, context.permissions);
                setPermissionResult(result);
            }
            catch (err) {
                setError(err instanceof Error ? err : new Error('Failed to check permissions'));
                setPermissionResult({ granted: false, missing: null });
            }
        };
        void checkPerms();
    }, [context, requiredPermissions, isLoading]);
    return {
        hasPermission: permissionResult.granted,
        isLoading,
        missingPermissions: permissionResult.missing,
        error
    };
};
exports.usePermissions = usePermissions;
