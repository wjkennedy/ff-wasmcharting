"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useForm = void 0;
const tslib_1 = require("tslib");
const react_1 = require("react");
const react_hook_form_1 = require("react-hook-form");
const get_1 = tslib_1.__importDefault(require("lodash/get"));
function useForm(props = {}) {
    // Generate an id to prevent clashes with other forms on the page
    const id = (0, react_1.useId)();
    const getFieldId = (fieldName) => {
        return `form-${id}-${fieldName}`;
    };
    const { register, formState, 
    // watch, disabling for the time being as can be expensive for performance
    handleSubmit, setValue, getValues, trigger, clearErrors
    // Only allow for defaultValues in props for the timebeing
     } = (0, react_hook_form_1.useForm)({
        defaultValues: props.defaultValues,
        mode: 'onBlur',
        reValidateMode: 'onChange'
    });
    const defaultValues = props?.defaultValues;
    const forgeFormRegister = (fieldName, options) => {
        /**
         * Removed:
         * - ref cannot be serialised and passed through the run time
         * - removed required to stop the default browser validation pop up
         * - UI Kit 2 components take `isDisabled` instead of `disabled`
         * - `onChange` is modified to handle our controlled components as refs cannot be used
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { onChange, ref, required, disabled, onBlur, ...rest } = register(fieldName, {
            // Only permitting the below as they've been tested and confirmed working
            required: options?.required,
            disabled: options?.disabled,
            maxLength: options?.maxLength,
            minLength: options?.minLength,
            max: options?.max,
            min: options?.min,
            pattern: options?.pattern,
            validate: options?.validate
        });
        const additionalProps = {};
        if (defaultValues) {
            // only checkbox and toggle have boolean vals.
            // Typically this is handled by the ref obj but we need to manage the default values ourselves here
            if (typeof (0, get_1.default)(defaultValues, fieldName) === 'boolean') {
                additionalProps.defaultChecked = (0, get_1.default)(defaultValues, fieldName);
            }
            else {
                additionalProps.defaultValue = (0, get_1.default)(defaultValues, fieldName);
            }
        }
        const isError = !!(0, get_1.default)(formState, `errors["${fieldName}"]`);
        const getOnChangeOptions = () => ({
            shouldDirty: true,
            shouldTouch: true,
            // revalidate on change if the field has been touched(blurred) or if the form has been submitted previously
            shouldValidate: formState.submitCount > 0 || !!(0, get_1.default)(formState, `touchedFields["${fieldName}"]`)
        });
        return {
            ...rest,
            onChange: (event) => {
                // onChange is modified here to handle our controlled components as refs cannot be used
                // handles Checkbox and Toggle
                if (event?.target?.type === 'checkbox') {
                    return Promise.resolve(setValue(fieldName, event.target.checked, getOnChangeOptions()));
                }
                if (['number', 'text', 'textarea', 'radio', 'password'].includes(event?.target?.type)) {
                    return Promise.resolve(setValue(fieldName, event.target.value, getOnChangeOptions()));
                }
                else {
                    // handles onChange arguments where the value is passed instead of an event object
                    return Promise.resolve(setValue(fieldName, event, getOnChangeOptions()));
                }
            },
            // The onBlur event from `register` is unintentionally setting the value to `undefined` when the field is blurred.
            // Replacing the onBlur event here to prevent this behaviour.
            onBlur: () => {
                return Promise.resolve(trigger(fieldName));
            },
            isInvalid: isError,
            'aria-invalid': isError,
            id: getFieldId(fieldName),
            isDisabled: disabled,
            ...additionalProps
        };
    };
    return {
        getFieldId,
        register: forgeFormRegister,
        formState: {
            errors: formState.errors,
            isSubmitted: formState.isSubmitted,
            isSubmitSuccessful: formState.isSubmitSuccessful,
            isSubmitting: formState.isSubmitting,
            submitCount: formState.submitCount,
            isValid: formState.isValid,
            dirtyFields: formState.dirtyFields,
            touchedFields: formState.touchedFields
        },
        handleSubmit,
        getValues,
        trigger,
        clearErrors
    };
}
exports.useForm = useForm;
