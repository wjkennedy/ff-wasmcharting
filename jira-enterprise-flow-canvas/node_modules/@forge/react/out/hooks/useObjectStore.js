"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useObjectStore = void 0;
const react_1 = require("react");
const bridge_1 = require("@forge/bridge");
// Helper function to update an object by key
const updateObjectByKey = (objects, key, updates) => objects.map((obj) => (obj.key === key ? { ...obj, ...updates } : obj));
function objectStoreReducer(state, action) {
    switch (action.type) {
        case 'ADD_OBJECTS':
            return { objects: [...state.objects, ...action.payload] };
        case 'UPDATE_OBJECT':
            return { objects: updateObjectByKey(state.objects, action.payload.key, action.payload.updates) };
        case 'UPLOAD_OBJECT_START':
            // Add temp object with isUploading state
            return {
                objects: [...state.objects, { key: action.payload.tempKey, isUploading: true }]
            };
        case 'UPLOAD_OBJECT_SUCCESS':
            // Replace temp object with real object
            return {
                objects: state.objects.map((obj) => (obj.key === action.payload.tempKey ? action.payload.object : obj))
            };
        case 'UPLOAD_OBJECT_ERROR':
            // Replace temp object with error state
            return {
                objects: state.objects.map((obj) => obj.key === action.payload.tempKey
                    ? { ...obj, isUploading: false, error: action.payload.error, success: false }
                    : obj)
            };
        case 'DELETE_START':
            return {
                objects: state.objects.map((obj) => action.payload.includes(obj.key) ? { ...obj, isDeleting: true, error: undefined } : obj)
            };
        case 'DELETE_SUCCESS':
            return { objects: state.objects.filter((obj) => !action.payload.includes(obj.key)) };
        case 'DELETE_ERROR':
            return {
                objects: state.objects.map((obj) => action.payload.keys.includes(obj.key) ? { ...obj, isDeleting: false, error: action.payload.error } : obj)
            };
        case 'DOWNLOAD_START':
            return {
                objects: state.objects.map((obj) => action.payload.includes(obj.key) ? { ...obj, isDownloading: true, error: undefined } : obj)
            };
        case 'DOWNLOAD_COMPLETE':
            return {
                objects: state.objects.map((obj) => {
                    if (action.payload.successfulKeys.includes(obj.key)) {
                        return { ...obj, isDownloading: false };
                    }
                    if (action.payload.failedKeys.includes(obj.key)) {
                        return { ...obj, isDownloading: false, error: 'Download failed' };
                    }
                    return obj;
                })
            };
        default:
            return state;
    }
}
function useObjectStore(props = {}) {
    const [state, dispatch] = (0, react_1.useReducer)(objectStoreReducer, {
        objects: props.defaultValues || []
    });
    /**
     * Get a specific object from objectState by key
     */
    const getObjectMetadata = (key) => {
        const object = state.objects.find((obj) => obj.key === key);
        if (!object) {
            // eslint-disable-next-line no-console
            console.warn(`No metadata found for object with key: ${key}`);
            return null;
        }
        return object;
    };
    /**
     * Upload objects and update objectState with results
     */
    const uploadObjects = (0, react_1.useCallback)(async (params) => {
        const timestamp = Date.now();
        try {
            const uploadPromises = await (0, bridge_1.createUploadPromises)(params);
            const trackedUploadPromises = uploadPromises.map(async ({ promise, index, objectType, objectSize }) => {
                const tempKey = `temp-upload-${timestamp}-${index}`;
                dispatch({ type: 'UPLOAD_OBJECT_START', payload: { tempKey } });
                try {
                    const result = await promise;
                    const objectState = {
                        key: result.key,
                        success: result.success,
                        status: result.status,
                        error: result.error,
                        objectType,
                        objectSize
                    };
                    dispatch({ type: 'UPLOAD_OBJECT_SUCCESS', payload: { tempKey, object: objectState } });
                    return result;
                }
                catch (error) {
                    dispatch({
                        type: 'UPLOAD_OBJECT_ERROR',
                        payload: { tempKey, error: error instanceof Error ? error.message : 'Upload failed' }
                    });
                    throw error;
                }
            });
            await Promise.all(trackedUploadPromises);
        }
        catch (error) {
            throw error;
        }
    }, []);
    /**
     * Delete objects by keys from state and backend
     */
    const deleteObjects = (0, react_1.useCallback)(async (params) => {
        dispatch({ type: 'DELETE_START', payload: params.keys });
        try {
            await bridge_1.objectStore.delete(params);
            dispatch({ type: 'DELETE_SUCCESS', payload: params.keys });
        }
        catch (error) {
            dispatch({
                type: 'DELETE_ERROR',
                payload: { keys: params.keys, error: error instanceof Error ? error.message : 'Delete failed' }
            });
            throw error;
        }
    }, []);
    /**
     * Download objects by keys
     */
    const downloadObjects = (0, react_1.useCallback)(async (params) => {
        dispatch({ type: 'DOWNLOAD_START', payload: params.keys });
        try {
            const results = await bridge_1.objectStore.download(params);
            const successfulKeys = results.filter((r) => r.success).map((r) => r.key);
            const failedKeys = results.filter((r) => !r.success).map((r) => r.key);
            dispatch({
                type: 'DOWNLOAD_COMPLETE',
                payload: { successfulKeys, failedKeys }
            });
            return results;
        }
        catch (error) {
            dispatch({
                type: 'DOWNLOAD_COMPLETE',
                payload: { successfulKeys: [], failedKeys: params.keys }
            });
            throw error;
        }
    }, []);
    return {
        objectStates: state.objects,
        getObjectMetadata,
        uploadObjects,
        deleteObjects,
        downloadObjects
    };
}
exports.useObjectStore = useObjectStore;
