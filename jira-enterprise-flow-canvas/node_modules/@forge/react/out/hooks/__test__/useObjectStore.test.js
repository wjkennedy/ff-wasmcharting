"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
// Mock data - define before imports
const MOCK_FUNCTION_KEY = 'test-function-key';
const MOCK_OBJECT_KEY_1 = 'object-key-1';
const MOCK_OBJECT_KEY_2 = 'object-key-2';
const MOCK_BLOB = new Blob(['test content'], { type: 'text/plain' });
const MOCK_BASE64_OBJECT = { data: 'dGVzdCBjb250ZW50', mimeType: 'text/plain', fileSize: 12 };
// Mock functions - define before imports
const mockUpload = jest.fn();
const mockCreateUploadPromises = jest.fn();
const mockDelete = jest.fn();
const mockDownload = jest.fn();
const mockGetMetadata = jest.fn();
const reconcilerTestRenderer_1 = tslib_1.__importDefault(require("../../__test__/reconcilerTestRenderer"));
const testUtils_1 = require("../../__test__/testUtils");
const useObjectStore_1 = require("../useObjectStore");
const utils_1 = require("./utils");
// Mock @forge/bridge
jest.mock('@forge/bridge', () => ({
    objectStore: {
        upload: mockUpload,
        delete: mockDelete,
        download: mockDownload,
        getMetadata: mockGetMetadata
    },
    createUploadPromises: mockCreateUploadPromises
}));
describe('useObjectStore', () => {
    beforeEach(() => {
        // Clear all mocks before each test
        jest.clearAllMocks();
        (0, testUtils_1.setupBridge)(); // Set up global bridge for tests
    });
    describe('Initialization', () => {
        it('should initialize with empty objectStates when no defaultValues provided', async () => {
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)();
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            expect(hookResult.objectStates).toEqual([]);
        });
        it('should initialize with defaultValues when provided', async () => {
            const defaultValues = [
                { key: MOCK_OBJECT_KEY_1, success: true, objectSize: 100 },
                { key: MOCK_OBJECT_KEY_2, success: true, objectSize: 200 }
            ];
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)({ defaultValues });
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            expect(hookResult.objectStates).toEqual(defaultValues);
        });
    });
    describe('uploadObjects', () => {
        it('should upload Blob objects successfully', async () => {
            const mockResults = [{ key: MOCK_OBJECT_KEY_1, success: true, status: 200 }];
            mockCreateUploadPromises.mockResolvedValueOnce([
                { promise: Promise.resolve(mockResults[0]), index: 0, objectType: 'text/plain', objectSize: 12 }
            ]);
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)();
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            // Before upload
            expect(hookResult.objectStates).toEqual([]);
            // Trigger upload
            await hookResult.uploadObjects({
                functionKey: MOCK_FUNCTION_KEY,
                objects: [MOCK_BLOB]
            });
            // Should call bridge startUploads
            expect(mockCreateUploadPromises).toHaveBeenCalledWith({
                functionKey: MOCK_FUNCTION_KEY,
                objects: [MOCK_BLOB]
            });
            // Should update state with results
            expect(hookResult.objectStates).toHaveLength(1);
            expect(hookResult.objectStates[0]).toMatchObject({
                key: MOCK_OBJECT_KEY_1,
                success: true,
                status: 200,
                objectType: 'text/plain',
                objectSize: MOCK_BLOB.size
            });
        });
        it('should upload Base64Object successfully with fileSize', async () => {
            const mockResults = [{ key: MOCK_OBJECT_KEY_1, success: true, status: 200 }];
            mockCreateUploadPromises.mockResolvedValueOnce([
                { promise: Promise.resolve(mockResults[0]), index: 0, objectType: 'text/plain', objectSize: 12 }
            ]);
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)();
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            await hookResult.uploadObjects({
                functionKey: MOCK_FUNCTION_KEY,
                objects: [MOCK_BASE64_OBJECT]
            });
            expect(hookResult.objectStates[0]).toMatchObject({
                key: MOCK_OBJECT_KEY_1,
                success: true,
                objectType: 'text/plain',
                objectSize: 12 // Uses provided fileSize
            });
        });
        it('should calculate objectSize from base64 data when fileSize not provided', async () => {
            const base64WithoutSize = { data: 'dGVzdA==', mimeType: 'text/plain' };
            const mockResults = [{ key: MOCK_OBJECT_KEY_1, success: true, status: 200 }];
            mockCreateUploadPromises.mockResolvedValueOnce([
                { promise: Promise.resolve(mockResults[0]), index: 0, objectType: 'text/plain', objectSize: 4 }
            ]);
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)();
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            await hookResult.uploadObjects({
                functionKey: MOCK_FUNCTION_KEY,
                objects: [base64WithoutSize]
            });
            // Should calculate size from base64: (8 * 3 / 4) - 2 = 4
            expect(hookResult.objectStates[0].objectSize).toBe(4);
        });
        it('should show isUploading state during upload', async () => {
            let resolveUpload;
            const uploadPromise = new Promise((resolve) => {
                resolveUpload = resolve;
            });
            mockCreateUploadPromises.mockResolvedValueOnce([
                { promise: uploadPromise, index: 0, objectType: 'text/plain', objectSize: 12 }
            ]);
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)();
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            // Start upload (don't await)
            const uploadPromiseResult = hookResult.uploadObjects({
                functionKey: MOCK_FUNCTION_KEY,
                objects: [MOCK_BLOB]
            });
            // Give a tick for state to update
            await (0, utils_1.sleep)();
            // Should have temp object with isUploading: true
            expect(hookResult.objectStates).toHaveLength(1);
            expect(hookResult.objectStates[0].isUploading).toBe(true);
            expect(hookResult.objectStates[0].key).toMatch(/^temp-upload-/);
            // Resolve upload
            resolveUpload({ key: MOCK_OBJECT_KEY_1, success: true, status: 200 });
            await uploadPromiseResult;
            // Temp object should be replaced with real object (no isUploading)
            expect(hookResult.objectStates).toHaveLength(1);
            expect(hookResult.objectStates[0].key).toBe(MOCK_OBJECT_KEY_1);
            expect(hookResult.objectStates[0].isUploading).toBeUndefined();
        });
        it('should handle upload errors and remove temp objects', async () => {
            const uploadError = new Error('Upload failed');
            mockCreateUploadPromises.mockRejectedValueOnce(uploadError);
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)();
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            await expect(hookResult.uploadObjects({
                functionKey: MOCK_FUNCTION_KEY,
                objects: [MOCK_BLOB]
            })).rejects.toThrow('Upload failed');
            // Temp objects should be removed
            expect(hookResult.objectStates).toEqual([]);
        });
        it('should upload multiple objects', async () => {
            const mockResults = [
                { key: MOCK_OBJECT_KEY_1, success: true, status: 200 },
                { key: MOCK_OBJECT_KEY_2, success: true, status: 200 }
            ];
            mockCreateUploadPromises.mockResolvedValueOnce([
                { promise: Promise.resolve(mockResults[0]), index: 0, objectType: 'text/plain', objectSize: 12 },
                { promise: Promise.resolve(mockResults[1]), index: 1, objectType: 'text/plain', objectSize: 12 }
            ]);
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)();
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            const blob1 = new Blob(['test1'], { type: 'text/plain' });
            const blob2 = new Blob(['test2'], { type: 'text/plain' });
            await hookResult.uploadObjects({
                functionKey: MOCK_FUNCTION_KEY,
                objects: [blob1, blob2]
            });
            expect(hookResult.objectStates).toHaveLength(2);
            expect(hookResult.objectStates[0].key).toBe(MOCK_OBJECT_KEY_1);
            expect(hookResult.objectStates[1].key).toBe(MOCK_OBJECT_KEY_2);
        });
    });
    describe('deleteObject', () => {
        it('should delete object successfully', async () => {
            mockDelete.mockResolvedValueOnce(undefined);
            const defaultValues = [{ key: MOCK_OBJECT_KEY_1, success: true, objectSize: 100 }];
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)({ defaultValues });
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            // Before delete
            expect(hookResult.objectStates).toHaveLength(1);
            // Delete object
            await hookResult.deleteObjects({ functionKey: MOCK_FUNCTION_KEY, keys: [MOCK_OBJECT_KEY_1] });
            // Should call bridge delete
            expect(mockDelete).toHaveBeenCalledWith({
                functionKey: MOCK_FUNCTION_KEY,
                keys: [MOCK_OBJECT_KEY_1]
            });
            // Object should be removed from state
            expect(hookResult.objectStates).toEqual([]);
        });
        it('should show isDeleting state during delete', async () => {
            let resolveDelete;
            const deletePromise = new Promise((resolve) => {
                resolveDelete = resolve;
            });
            mockDelete.mockReturnValueOnce(deletePromise);
            const defaultValues = [{ key: MOCK_OBJECT_KEY_1, success: true, objectSize: 100 }];
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)({ defaultValues });
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            // Start delete (don't await)
            const deletePromiseResult = hookResult.deleteObjects({
                functionKey: MOCK_FUNCTION_KEY,
                keys: [MOCK_OBJECT_KEY_1]
            });
            // Give a tick for state to update
            await (0, utils_1.sleep)();
            // Should have isDeleting: true
            expect(hookResult.objectStates[0].isDeleting).toBe(true);
            // Resolve delete
            resolveDelete(undefined);
            await deletePromiseResult;
            // Object should be removed
            expect(hookResult.objectStates).toEqual([]);
        });
        it('should handle delete errors and set error state', async () => {
            const deleteError = new Error('Delete failed');
            mockDelete.mockRejectedValueOnce(deleteError);
            const defaultValues = [{ key: MOCK_OBJECT_KEY_1, success: true, objectSize: 100 }];
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)({ defaultValues });
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            await expect(hookResult.deleteObjects({ functionKey: MOCK_FUNCTION_KEY, keys: [MOCK_OBJECT_KEY_1] })).rejects.toThrow('Delete failed');
            // Object should still exist with error state
            expect(hookResult.objectStates).toHaveLength(1);
            expect(hookResult.objectStates[0].isDeleting).toBe(false);
            expect(hookResult.objectStates[0].error).toBe('Delete failed');
        });
        it('should delete multiple objects successfully', async () => {
            mockDelete.mockResolvedValueOnce(undefined);
            const defaultValues = [
                { key: MOCK_OBJECT_KEY_1, success: true, objectSize: 100 },
                { key: MOCK_OBJECT_KEY_2, success: true, objectSize: 200 }
            ];
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)({ defaultValues });
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            // Before delete
            expect(hookResult.objectStates).toHaveLength(2);
            // Delete both objects
            await hookResult.deleteObjects({
                functionKey: MOCK_FUNCTION_KEY,
                keys: [MOCK_OBJECT_KEY_1, MOCK_OBJECT_KEY_2]
            });
            // Should call bridge delete with both keys
            expect(mockDelete).toHaveBeenCalledWith({
                functionKey: MOCK_FUNCTION_KEY,
                keys: [MOCK_OBJECT_KEY_1, MOCK_OBJECT_KEY_2]
            });
            // Both objects should be removed from state
            expect(hookResult.objectStates).toEqual([]);
        });
        it('should show isDeleting state for multiple objects during delete', async () => {
            let resolveDelete;
            const deletePromise = new Promise((resolve) => {
                resolveDelete = resolve;
            });
            mockDelete.mockReturnValueOnce(deletePromise);
            const defaultValues = [
                { key: MOCK_OBJECT_KEY_1, success: true, objectSize: 100 },
                { key: MOCK_OBJECT_KEY_2, success: true, objectSize: 200 }
            ];
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)({ defaultValues });
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            // Start delete (don't await)
            const deletePromiseResult = hookResult.deleteObjects({
                functionKey: MOCK_FUNCTION_KEY,
                keys: [MOCK_OBJECT_KEY_1, MOCK_OBJECT_KEY_2]
            });
            // Give a tick for state to update
            await (0, utils_1.sleep)();
            // Both should have isDeleting: true
            expect(hookResult.objectStates[0].isDeleting).toBe(true);
            expect(hookResult.objectStates[1].isDeleting).toBe(true);
            // Resolve delete
            resolveDelete(undefined);
            await deletePromiseResult;
            // Both objects should be removed
            expect(hookResult.objectStates).toEqual([]);
        });
    });
    describe('downloadObjects', () => {
        it('should download object successfully', async () => {
            const mockBlob = new Blob(['downloaded content']);
            const mockResults = [{ success: true, key: MOCK_OBJECT_KEY_1, blob: mockBlob }];
            mockDownload.mockResolvedValueOnce(mockResults);
            const defaultValues = [{ key: MOCK_OBJECT_KEY_1, success: true, objectSize: 100 }];
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)({ defaultValues });
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            const result = await hookResult.downloadObjects({ functionKey: MOCK_FUNCTION_KEY, keys: [MOCK_OBJECT_KEY_1] });
            // Should call bridge download
            expect(mockDownload).toHaveBeenCalledWith({
                functionKey: MOCK_FUNCTION_KEY,
                keys: [MOCK_OBJECT_KEY_1]
            });
            // Should return results with blob
            expect(result[0].blob).toBe(mockBlob);
        });
        it('should show isDownloading state during download', async () => {
            let resolveDownload;
            const downloadPromise = new Promise((resolve) => {
                resolveDownload = resolve;
            });
            mockDownload.mockReturnValueOnce(downloadPromise);
            const defaultValues = [{ key: MOCK_OBJECT_KEY_1, success: true, objectSize: 100 }];
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)({ defaultValues });
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            // Start download (don't await)
            const downloadPromiseResult = hookResult.downloadObjects({
                functionKey: MOCK_FUNCTION_KEY,
                keys: [MOCK_OBJECT_KEY_1]
            });
            // Give a tick for state to update
            await (0, utils_1.sleep)();
            // Should have isDownloading: true
            expect(hookResult.objectStates[0].isDownloading).toBe(true);
            // Resolve download
            const mockBlob = new Blob(['content']);
            resolveDownload([{ success: true, key: MOCK_OBJECT_KEY_1, blob: mockBlob }]);
            await downloadPromiseResult;
            // isDownloading should be false
            expect(hookResult.objectStates[0].isDownloading).toBe(false);
        });
        it('should handle download errors and set error state', async () => {
            const downloadError = new Error('Download failed');
            mockDownload.mockRejectedValueOnce(downloadError);
            const defaultValues = [{ key: MOCK_OBJECT_KEY_1, success: true, objectSize: 100 }];
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)({ defaultValues });
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            await expect(hookResult.downloadObjects({ functionKey: MOCK_FUNCTION_KEY, keys: [MOCK_OBJECT_KEY_1] })).rejects.toThrow('Download failed');
            // Object should have error state
            expect(hookResult.objectStates[0].isDownloading).toBe(false);
            expect(hookResult.objectStates[0].error).toBe('Download failed');
        });
        it('should return null when download result has no blob', async () => {
            const mockResults = [{ success: false, key: MOCK_OBJECT_KEY_1, error: 'Not found' }];
            mockDownload.mockResolvedValueOnce(mockResults);
            const defaultValues = [{ key: MOCK_OBJECT_KEY_1, success: true, objectSize: 100 }];
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)({ defaultValues });
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            const result = await hookResult.downloadObjects({
                functionKey: MOCK_FUNCTION_KEY,
                keys: [MOCK_OBJECT_KEY_1]
            });
            expect(result[0].success).toBe(false);
            expect(result[0].blob).toBeUndefined();
            expect(hookResult.objectStates[0].error).toBe('Download failed');
        });
    });
    describe('getObjectMetadata', () => {
        it('should return object from state when it exists', async () => {
            const defaultValues = [{ key: MOCK_OBJECT_KEY_1, success: true, objectSize: 100 }];
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)({ defaultValues });
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            const result = hookResult.getObjectMetadata(MOCK_OBJECT_KEY_1);
            expect(result).toEqual(defaultValues[0]);
        });
        it('should return null when object not in state', async () => {
            let hookResult;
            const TestComponent = () => {
                hookResult = (0, useObjectStore_1.useObjectStore)();
                return null;
            };
            await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, {}));
            expect(hookResult).toBeDefined();
            if (!hookResult)
                return;
            const result = hookResult.getObjectMetadata(MOCK_OBJECT_KEY_1);
            expect(result).toBeNull();
        });
    });
    describe('Function memoization', () => {
        it('should preserve uploadObjects function reference between renders', async () => {
            let uploadFunction1;
            let uploadFunction2;
            const TestComponent = ({ renderKey }) => {
                const { uploadObjects } = (0, useObjectStore_1.useObjectStore)();
                if (renderKey === 1)
                    uploadFunction1 = uploadObjects;
                if (renderKey === 2)
                    uploadFunction2 = uploadObjects;
                return null;
            };
            const renderer = await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, { renderKey: 1 }));
            await renderer.update((0, jsx_runtime_1.jsx)(TestComponent, { renderKey: 2 }));
            // Verify both functions exist and are callable
            expect(uploadFunction1).toBeDefined();
            expect(uploadFunction2).toBeDefined();
            expect(typeof uploadFunction1).toBe('function');
            expect(typeof uploadFunction2).toBe('function');
            // Note: Function reference stability depends on test renderer behavior
        });
        it('should preserve deleteObjects function reference between renders', async () => {
            let deleteFunction1;
            let deleteFunction2;
            const TestComponent = ({ renderKey }) => {
                const { deleteObjects } = (0, useObjectStore_1.useObjectStore)();
                if (renderKey === 1)
                    deleteFunction1 = deleteObjects;
                if (renderKey === 2)
                    deleteFunction2 = deleteObjects;
                return null;
            };
            const renderer = await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(TestComponent, { renderKey: 1 }));
            await renderer.update((0, jsx_runtime_1.jsx)(TestComponent, { renderKey: 2 }));
            // Verify both functions exist and are callable
            expect(deleteFunction1).toBeDefined();
            expect(deleteFunction2).toBeDefined();
            expect(typeof deleteFunction1).toBe('function');
            expect(typeof deleteFunction2).toBe('function');
            // Note: Function reference stability depends on test renderer behavior
        });
    });
});
