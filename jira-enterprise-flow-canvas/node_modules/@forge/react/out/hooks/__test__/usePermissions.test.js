"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_hooks_1 = require("@testing-library/react-hooks");
const usePermissions_1 = require("../usePermissions");
const testUtils_1 = require("../../__test__/testUtils");
// Mock @forge/bridge
jest.mock('@forge/bridge', () => {
    // Set up window before requiring actual bridge to avoid initialization issues
    if (typeof window === 'undefined') {
        // @ts-ignore
        global.window = global;
        // @ts-ignore
        global.window.__bridge = {
            callBridge: jest.fn()
        };
    }
    const actualBridge = jest.requireActual('@forge/bridge');
    return {
        ...actualBridge,
        view: {
            ...actualBridge.view,
            getContext: jest.fn()
        }
    };
});
const mockGetContext = jest.fn();
describe('usePermissions', () => {
    beforeEach(() => {
        jest.clearAllMocks();
        (0, testUtils_1.setupBridge)();
        // Set up the mock to use our mockGetContext function
        const { view } = require('@forge/bridge');
        view.getContext.mockImplementation(mockGetContext);
    });
    describe('Interface inheritance', () => {
        it('should allow PermissionRequirements to be used as Permissions', () => {
            const requiredPermissions = {
                scopes: ['read:confluence-content']
            };
            // This should compile without errors, demonstrating inheritance
            const permissions = requiredPermissions;
            expect(permissions.scopes).toEqual(['read:confluence-content']);
        });
        it('should allow MissingPermissions to be used as Permissions', () => {
            const missingPermissions = {
                scopes: ['write:jira-work']
            };
            // This should compile without errors, demonstrating inheritance
            const permissions = missingPermissions;
            expect(permissions.scopes).toEqual(['write:jira-work']);
        });
    });
    describe('Loading state', () => {
        it('should start with loading true', () => {
            const requiredPermissions = {
                scopes: ['read:confluence-content']
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            expect(result.current.isLoading).toBe(true);
            expect(result.current.hasPermission).toBe(false);
            expect(result.current.missingPermissions).toBe(null);
            expect(result.current.error).toBe(null);
        });
        it('should set loading to false after context loads', async () => {
            const mockContext = {
                permissions: {
                    scopes: ['read:confluence-content']
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                scopes: ['read:confluence-content']
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.hasPermission).toBe(true);
            expect(result.current.missingPermissions).toBe(null);
        });
    });
    describe('Error handling', () => {
        it('should handle context loading errors', async () => {
            const error = new Error('Failed to load context');
            mockGetContext.mockRejectedValue(error);
            const requiredPermissions = {
                scopes: ['read:confluence-content']
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.error).toEqual(error);
            expect(result.current.hasPermission).toBe(false);
            expect(result.current.missingPermissions).toBe(null);
        });
        it('should handle non-Error objects in catch block', async () => {
            mockGetContext.mockRejectedValue('String error');
            const requiredPermissions = {
                scopes: ['read:confluence-content']
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.error).toEqual(new Error('Failed to load context'));
        });
    });
    describe('Scope permissions', () => {
        it('should grant permission when all required scopes are present', async () => {
            const mockContext = {
                permissions: {
                    scopes: ['read:confluence-content', 'write:confluence-content']
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                scopes: ['read:confluence-content']
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
            expect(result.current.missingPermissions).toBe(null);
        });
        it('should deny permission when required scopes are missing', async () => {
            const mockContext = {
                permissions: {
                    scopes: ['read:confluence-content']
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                scopes: ['read:confluence-content', 'write:jira-work']
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(false);
            expect(result.current.missingPermissions).toEqual({
                scopes: ['write:jira-work']
            });
        });
        it('should handle scopes as object format', async () => {
            const mockContext = {
                permissions: {
                    scopes: {
                        'read:confluence-content': { allowImpersonation: false },
                        'write:confluence-content': { allowImpersonation: true }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                scopes: ['read:confluence-content']
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
        it('should handle empty scopes array', async () => {
            const mockContext = {
                permissions: {
                    scopes: []
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                scopes: []
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
    });
    describe('External permissions', () => {
        it('should grant permission for allowed fetch URLs', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            backend: ['https://api.example.com', 'https://api.test.com'],
                            client: ['https://cdn.example.com']
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        backend: ['https://api.example.com'],
                        client: ['https://cdn.example.com']
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
        it('should deny permission for disallowed fetch URLs', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            backend: ['https://api.example.com']
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        backend: ['https://api.example.com', 'https://api.unauthorized.com']
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(false);
            expect(result.current.missingPermissions).toEqual({
                external: {
                    fetch: {
                        backend: ['https://api.unauthorized.com']
                    }
                }
            });
        });
        it('should handle wildcard URL patterns', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            backend: ['https://api.example.com/*', 'https://*.test.com/**']
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        backend: ['https://api.example.com/users', 'https://subdomain.test.com/api']
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
        it('should handle resource permissions (fonts, images, etc.)', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fonts: ['https://fonts.googleapis.com'],
                        images: ['https://images.example.com'],
                        scripts: ['https://scripts.example.com']
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fonts: ['https://fonts.googleapis.com'],
                    images: ['https://images.example.com']
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
    });
    describe('Complex permission scenarios', () => {
        it('should handle mixed permission types', async () => {
            const mockContext = {
                permissions: {
                    scopes: ['read:confluence-content', 'write:confluence-content', 'read:jira-work'],
                    external: {
                        fetch: {
                            backend: ['https://api.example.com', 'https://api.test.com'],
                            client: ['https://cdn.example.com', 'https://cdn.test.com']
                        },
                        images: ['https://images.example.com', 'https://images.test.com'],
                        fonts: ['https://fonts.googleapis.com', 'https://fonts.gstatic.com'],
                        scripts: ['https://scripts.example.com']
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                scopes: ['read:confluence-content', 'write:confluence-content'],
                external: {
                    fetch: {
                        backend: ['https://api.example.com'],
                        client: ['https://cdn.example.com']
                    },
                    images: ['https://images.example.com'],
                    fonts: ['https://fonts.googleapis.com'],
                    scripts: ['https://scripts.example.com']
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
        it('should identify missing permissions across different types', async () => {
            const mockContext = {
                permissions: {
                    scopes: ['read:confluence-content', 'read:jira-work'],
                    external: {
                        fetch: {
                            backend: ['https://api.example.com', 'https://api.authorized.com'],
                            client: ['https://cdn.authorized.com']
                        },
                        images: ['https://images.authorized.com'],
                        fonts: ['https://fonts.authorized.com']
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                scopes: ['read:confluence-content', 'write:jira-work', 'admin:confluence'],
                external: {
                    fetch: {
                        backend: ['https://api.example.com', 'https://api.unauthorized.com', 'https://api.missing.com'],
                        client: ['https://cdn.example.com', 'https://cdn.unauthorized.com']
                    },
                    images: ['https://images.example.com', 'https://images.unauthorized.com'],
                    fonts: ['https://fonts.example.com'],
                    scripts: ['https://scripts.example.com', 'https://scripts.unauthorized.com']
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(false);
            expect(result.current.missingPermissions).toEqual({
                scopes: ['write:jira-work', 'admin:confluence'],
                external: {
                    fetch: {
                        backend: ['https://api.unauthorized.com', 'https://api.missing.com'],
                        client: ['https://cdn.example.com', 'https://cdn.unauthorized.com']
                    },
                    images: ['https://images.example.com', 'https://images.unauthorized.com'],
                    fonts: ['https://fonts.example.com'],
                    scripts: ['https://scripts.example.com', 'https://scripts.unauthorized.com']
                }
            });
        });
    });
    describe('CSP path matching for client fetch', () => {
        it('should allow any path when allowlist has no path', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            client: ['https://cdn.example.com']
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        client: [
                            'https://cdn.example.com',
                            'https://cdn.example.com/',
                            'https://cdn.example.com/any/path',
                            'https://cdn.example.com/file.js'
                        ]
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
        it('should use prefix matching when allowlist has trailing slash', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            client: ['https://cdn.example.com/api/']
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        client: [
                            'https://cdn.example.com/api/',
                            'https://cdn.example.com/api/users',
                            'https://cdn.example.com/api/v1/data'
                        ]
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
        it('should block paths outside prefix when using trailing slash', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            client: ['https://cdn.example.com/api/']
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        client: ['https://cdn.example.com/other', 'https://cdn.example.com/']
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(false);
            expect(result.current.missingPermissions?.external?.fetch?.client).toEqual([
                'https://cdn.example.com/other',
                'https://cdn.example.com/'
            ]);
        });
        it('should use exact matching when allowlist has no trailing slash', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            client: ['https://cdn.example.com/bundle.js']
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        client: ['https://cdn.example.com/bundle.js']
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
        it('should block non-exact paths when using exact matching', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            client: ['https://cdn.example.com/bundle.js']
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        client: [
                            'https://cdn.example.com/bundle.js/extra',
                            'https://cdn.example.com/other.js',
                            'https://cdn.example.com/'
                        ]
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(false);
            expect(result.current.missingPermissions?.external?.fetch?.client).toEqual([
                'https://cdn.example.com/bundle.js/extra',
                'https://cdn.example.com/other.js',
                'https://cdn.example.com/'
            ]);
        });
    });
    describe('Backend vs Client CSP differences', () => {
        it('should allow any path for backend (hostname-only matching)', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            backend: ['https://api.example.com/specific/path']
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        backend: [
                            'https://api.example.com',
                            'https://api.example.com/different/path',
                            'https://api.example.com/specific/path'
                        ]
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
        it('should demonstrate backend allows but client blocks different paths', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            backend: ['https://api.example.com/api/'],
                            client: ['https://api.example.com/api/']
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        backend: ['https://api.example.com/private/secret.json'],
                        client: ['https://api.example.com/private/secret.json']
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(false);
            // Backend should pass (hostname-only), client should fail (CSP path check)
            expect(result.current.missingPermissions?.external?.fetch?.backend).toBeUndefined();
            expect(result.current.missingPermissions?.external?.fetch?.client).toEqual([
                'https://api.example.com/private/secret.json'
            ]);
        });
    });
    describe('CSP for resource types', () => {
        it('should use CSP validation for images with paths', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        images: ['https://cdn.example.com/public/']
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    images: ['https://cdn.example.com/public/image.png', 'https://cdn.example.com/public/nested/image.jpg']
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
        it('should block images outside allowed directory', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        images: ['https://cdn.example.com/public/']
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    images: ['https://cdn.example.com/private/image.png', 'https://cdn.example.com/image.png']
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(false);
            expect(result.current.missingPermissions?.external?.images).toEqual([
                'https://cdn.example.com/private/image.png',
                'https://cdn.example.com/image.png'
            ]);
        });
        it('should apply CSP to all resource types', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        scripts: ['https://cdn.example.com'],
                        styles: ['https://cdn.example.com/css/'],
                        fonts: ['https://fonts.example.com/font.woff2']
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    scripts: ['https://cdn.example.com/bundle.js'],
                    styles: ['https://cdn.example.com/css/main.css'],
                    fonts: ['https://fonts.example.com/font.woff2'] // Exact match
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
    });
    describe('URL normalization and protocol handling', () => {
        it('should handle URLs without protocol', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            backend: ['api.example.com']
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        backend: ['https://api.example.com', 'api.example.com']
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
        it('should handle CSP secure protocol upgrades (http -> https)', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            client: ['http://example.com']
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        client: ['http://example.com', 'https://example.com']
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
        it('should not allow protocol downgrades (https -> http)', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            client: ['https://example.com']
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        client: ['http://example.com']
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(false);
            expect(result.current.missingPermissions?.external?.fetch?.client).toEqual(['http://example.com']);
        });
    });
    describe('Edge cases', () => {
        it('should handle empty required permissions', async () => {
            const mockContext = {
                permissions: {
                    scopes: ['read:confluence-content']
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {};
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
            expect(result.current.missingPermissions).toBe(null);
        });
        it('should handle complex external permission objects', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            backend: [
                                'https://api.example.com',
                                { address: 'https://api.address.com' },
                                { remote: 'https://api.remote.com' }
                            ]
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        backend: ['https://api.example.com', 'https://api.address.com']
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
    });
});
