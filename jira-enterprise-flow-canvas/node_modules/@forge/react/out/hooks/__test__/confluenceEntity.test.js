"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// defining mock functions above import so they are initialised before jest.mock runs
const mockRequestConf = jest.fn();
const mockGetContext = jest.fn(async () => mockPropertyHook_1.mockConfContext);
const confluenceEntity_1 = require("../confluenceEntity");
const mockPropertyHook_1 = require("./mockPropertyHook");
jest.mock('@forge/bridge', () => ({
    requestConfluence: mockRequestConf,
    view: { getContext: mockGetContext }
}));
describe('confAPIEndpoints string generation, given an entityType, productContext and required property data', () => {
    const spaceEndpoints = (0, confluenceEntity_1.confAPIEndpoints)({ entityType: 'Space', context: mockPropertyHook_1.mockConfContext });
    const contentEndpoints = (0, confluenceEntity_1.confAPIEndpoints)({ entityType: 'Content', context: mockPropertyHook_1.mockConfContext });
    it('should generate the expected property create URL', () => {
        expect(spaceEndpoints.create()).toEqual('/wiki/api/v2/spaces/MOCK_SPACE_ID/properties');
        expect(contentEndpoints.create()).toEqual('/wiki/api/v2/pages/MOCK_PAGE_ID/properties');
    });
    it('should generate the expected property get URL', () => {
        expect(spaceEndpoints.fetch('MOCK_PROP_KEY')).toEqual('/wiki/api/v2/spaces/MOCK_SPACE_ID/properties?key=MOCK_PROP_KEY');
        expect(contentEndpoints.fetch('MOCK_PROP_KEY')).toEqual('/wiki/api/v2/pages/MOCK_PAGE_ID/properties?key=MOCK_PROP_KEY');
    });
    it('should generate the expected property update URL', () => {
        expect(spaceEndpoints.update('MOCK_PROP_ID')).toEqual('/wiki/api/v2/spaces/MOCK_SPACE_ID/properties/MOCK_PROP_ID');
        expect(contentEndpoints.update('MOCK_PROP_ID')).toEqual('/wiki/api/v2/pages/MOCK_PAGE_ID/properties/MOCK_PROP_ID');
    });
    it('should generate the expected property delete URL', () => {
        expect(spaceEndpoints.delete('MOCK_PROP_ID')).toEqual('/wiki/api/v2/spaces/MOCK_SPACE_ID/properties/MOCK_PROP_ID');
        expect(contentEndpoints.delete('MOCK_PROP_ID')).toEqual('/wiki/api/v2/pages/MOCK_PAGE_ID/properties/MOCK_PROP_ID');
    });
    it('should throw an error if spaceId not available', () => {
        const emptyContext = { localId: '', extension: {} };
        expect(() => (0, confluenceEntity_1.confAPIEndpoints)({ entityType: 'Space', context: emptyContext })).toThrow('Space properties not available for this app.');
        expect(() => (0, confluenceEntity_1.confAPIEndpoints)({ entityType: 'Content', context: emptyContext })).toThrow('Content properties not available for this app.');
    });
});
describe('confluenceEntity', () => {
    const contentEntity = (0, confluenceEntity_1.confluenceEntity)({
        entityType: 'Content',
        origPropertyKey: 'MOCK_PROP_KEY',
        initValue: mockPropertyHook_1.DEFAULT_PROP_VALUE
    });
    const contentEndpoints = (0, confluenceEntity_1.confAPIEndpoints)({ entityType: 'Content', context: mockPropertyHook_1.mockConfContext });
    afterEach(() => jest.clearAllMocks());
    describe('when running its get() output function', () => {
        beforeAll(() => {
            mockRequestConf.mockResolvedValue(mockPropertyHook_1.mockConfGetExistingRes);
        });
        it('should make a GET request with the right URL', async () => {
            const contentGetUrl = contentEndpoints.fetch('forge-MOCK_LOCAL_ID-MOCK_PROP_KEY');
            const contentGetBody = expect.objectContaining({ method: 'GET' });
            await contentEntity.get();
            expect(mockRequestConf).toHaveBeenNthCalledWith(1, contentGetUrl, contentGetBody);
        });
        it('if the property exists, it should return its value', async () => {
            const output = await contentEntity.get();
            expect(output).toEqual(mockPropertyHook_1.EXISTING_PROP_VALUE);
            expect(mockRequestConf).toHaveBeenCalledTimes(1); // stop making further requests
        });
        it('should throw an error if the GET request fails', async () => {
            mockRequestConf.mockResolvedValueOnce(mockPropertyHook_1.mockFailedRes);
            await expect(contentEntity.get).rejects.toThrow(`The request to fetch the content property (forge-MOCK_LOCAL_ID-MOCK_PROP_KEY) failed with status (400).`);
        });
        describe('if the property does not exist, it should create it', () => {
            beforeEach(() => {
                mockRequestConf.mockResolvedValueOnce(mockPropertyHook_1.mockConfGetNonExistentRes).mockResolvedValueOnce(mockPropertyHook_1.mockConfCreateRes);
            });
            it('should make a POST request to the API with the right URL and body', async () => {
                const contentPostUrl = contentEndpoints.create();
                const contentPostBody = expect.objectContaining({
                    method: 'POST',
                    body: JSON.stringify({ key: 'forge-MOCK_LOCAL_ID-MOCK_PROP_KEY', value: mockPropertyHook_1.DEFAULT_PROP_VALUE })
                });
                await contentEntity.get();
                expect(mockRequestConf).toHaveBeenCalledTimes(2);
                expect(mockRequestConf).toHaveBeenNthCalledWith(2, contentPostUrl, contentPostBody);
            });
            it('should return the value of the created property (i.e. DEFAULT_PROP_VALUE value)', async () => {
                const output = await contentEntity.get();
                expect(output).toEqual(mockPropertyHook_1.DEFAULT_PROP_VALUE);
            });
            it('should throw an error if the POST request fails', async () => {
                mockRequestConf.mockReset();
                mockRequestConf.mockResolvedValueOnce(mockPropertyHook_1.mockConfGetNonExistentRes).mockResolvedValueOnce(mockPropertyHook_1.mockFailedRes);
                await expect(contentEntity.get).rejects.toThrow(`The request to create the content property (forge-MOCK_LOCAL_ID-MOCK_PROP_KEY) failed with status (400).`);
            });
        });
    });
    describe('when running its update() output function', () => {
        beforeEach(() => {
            mockRequestConf.mockResolvedValueOnce(mockPropertyHook_1.mockConfGetExistingRes).mockResolvedValueOnce(mockPropertyHook_1.mockConfUpdateValueRes);
        });
        it('should fetch the original property, then make a PUT request with the right url and body', async () => {
            const contentGetUrl = contentEndpoints.fetch('forge-MOCK_LOCAL_ID-MOCK_PROP_KEY');
            const contentGetBody = expect.objectContaining({ method: 'GET' });
            const contentPutUrl = contentEndpoints.update('MOCK_PROP_ID');
            // both value & version props need to be present in body string
            const valueUpdateStr = `"value":${mockPropertyHook_1.UPDATED_PROP_VALUE}`;
            const versionUpdateStr = `"version":{"number":${mockPropertyHook_1.UPDATED_PROP_VALUE}`;
            const contentPutBody = (updateStr) => expect.objectContaining({
                body: expect.stringContaining(updateStr)
            });
            await contentEntity.update(mockPropertyHook_1.UPDATED_PROP_VALUE);
            expect(mockRequestConf).toHaveBeenCalledTimes(2);
            expect(mockRequestConf).toHaveBeenNthCalledWith(1, contentGetUrl, contentGetBody);
            [valueUpdateStr, versionUpdateStr].forEach((updateStr) => {
                expect(mockRequestConf).toHaveBeenNthCalledWith(2, contentPutUrl, contentPutBody(updateStr));
            });
        });
        it('should return the value of the UPDATED_PROP_VALUE property when updating with concrete value', async () => {
            const valUpdate = await contentEntity.update(mockPropertyHook_1.UPDATED_PROP_VALUE);
            expect(valUpdate).toEqual(mockPropertyHook_1.UPDATED_PROP_VALUE);
        });
        it('should return the value of the UPDATED_PROP_VALUE property when updating with setter function', async () => {
            mockRequestConf.mockReset();
            mockRequestConf.mockResolvedValueOnce(mockPropertyHook_1.mockConfGetExistingRes).mockResolvedValueOnce(mockPropertyHook_1.mockConfUpdateFunctionRes);
            const updateCBFunc = (existingVal) => {
                return existingVal * mockPropertyHook_1.UPDATED_PROP_VALUE;
            };
            const expectedResult = mockPropertyHook_1.EXISTING_PROP_VALUE * mockPropertyHook_1.UPDATED_PROP_VALUE;
            const funcUpdate = await contentEntity.update(updateCBFunc);
            expect(funcUpdate).toEqual(expectedResult);
        });
        it('should throw an error if the PUT request fails', async () => {
            mockRequestConf.mockReset();
            mockRequestConf.mockResolvedValueOnce(mockPropertyHook_1.mockConfGetExistingRes).mockResolvedValueOnce(mockPropertyHook_1.mockFailedRes);
            await expect(() => contentEntity.update(mockPropertyHook_1.UPDATED_PROP_VALUE)).rejects.toThrow(`The request to update the content property (forge-MOCK_LOCAL_ID-MOCK_PROP_KEY) failed with status (400).`);
        });
        describe('if the property does not exist, it should create it', () => {
            beforeEach(() => {
                mockRequestConf.mockReset();
                mockRequestConf
                    .mockResolvedValueOnce(mockPropertyHook_1.mockConfGetNonExistentRes)
                    .mockResolvedValueOnce(mockPropertyHook_1.mockConfCreateRes)
                    .mockResolvedValueOnce(mockPropertyHook_1.mockConfUpdateValueRes);
            });
            it('should make a POST request to the API with the right URL and body', async () => {
                const contentGetUrl = contentEndpoints.fetch('forge-MOCK_LOCAL_ID-MOCK_PROP_KEY');
                const contentGetBody = expect.objectContaining({ method: 'GET' });
                const contentPutUrl = contentEndpoints.update('MOCK_PROP_ID');
                const contentPostUrl = contentEndpoints.create();
                const contentPostBody = expect.objectContaining({
                    method: 'POST',
                    body: JSON.stringify({ key: 'forge-MOCK_LOCAL_ID-MOCK_PROP_KEY', value: mockPropertyHook_1.DEFAULT_PROP_VALUE })
                });
                // both value & version props need to be present in body string
                const valueUpdateStr = `"value":${mockPropertyHook_1.UPDATED_PROP_VALUE}`;
                const contentPutBody = (updateStr) => expect.objectContaining({
                    body: expect.stringContaining(updateStr)
                });
                const valUpdate = await contentEntity.update(mockPropertyHook_1.UPDATED_PROP_VALUE);
                expect(valUpdate).toEqual(mockPropertyHook_1.UPDATED_PROP_VALUE);
                expect(mockRequestConf).toHaveBeenCalledTimes(3);
                expect(mockRequestConf).toHaveBeenNthCalledWith(1, contentGetUrl, contentGetBody);
                expect(mockRequestConf).toHaveBeenNthCalledWith(2, contentPostUrl, contentPostBody);
                expect(mockRequestConf).toHaveBeenNthCalledWith(3, contentPutUrl, contentPutBody(valueUpdateStr));
            });
        });
    });
    describe('when running its delete() output function', () => {
        beforeEach(() => {
            mockRequestConf.mockResolvedValueOnce(mockPropertyHook_1.mockConfGetExistingRes).mockResolvedValueOnce(mockPropertyHook_1.mockConfDeleteRes);
        });
        it('should fetch the original property, then make a DELETE request with the right url', async () => {
            const contentGetUrl = contentEndpoints.fetch('forge-MOCK_LOCAL_ID-MOCK_PROP_KEY');
            const contentGetBody = expect.objectContaining({ method: 'GET' });
            const contentDeleteUrl = contentEndpoints.delete('MOCK_PROP_ID');
            const contentDeleteBody = expect.objectContaining({ method: 'DELETE' });
            await contentEntity.delete();
            expect(mockRequestConf).toHaveBeenCalledTimes(2);
            expect(mockRequestConf).toHaveBeenNthCalledWith(1, contentGetUrl, contentGetBody);
            expect(mockRequestConf).toHaveBeenNthCalledWith(2, contentDeleteUrl, contentDeleteBody);
            jest.clearAllMocks();
        });
        it('should throw an error if the DELETE request fails', async () => {
            mockRequestConf.mockReset();
            mockRequestConf.mockResolvedValueOnce(mockPropertyHook_1.mockConfGetExistingRes).mockResolvedValueOnce(mockPropertyHook_1.mockFailedRes);
            await expect(contentEntity.delete).rejects.toThrow(`The request to delete the content property (forge-MOCK_LOCAL_ID-MOCK_PROP_KEY) failed with status (400).`);
        });
    });
});
