"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ForgeReconciler = exports.hostConfig = exports.nonChildPropsAreEqual = exports.insertBefore = exports.appendChild = exports.createElement = exports.callBridge = void 0;
const tslib_1 = require("tslib");
const react_reconciler_1 = tslib_1.__importDefault(require("react-reconciler"));
const constants_1 = require("react-reconciler/constants");
const uuid_1 = require("uuid");
// Only taking the first 5 characters of the uuid to keep the id shorter in the DOM to readability.
// The chances of clashing with 5 characters is still 1 in 1 million.
const idPropsPrefixAppUUID = (0, uuid_1.v4)().slice(0, 5);
const idPropsPrefix = `forge-app-${idPropsPrefixAppUUID}`;
// Checks the props of the component to see if it has an id prop. If so prefixes the value with the idPropsPrefix\
// This is done to avoid id conflicts with components in host product and other forge apps in the same page
const newPropsWithIdPrefix = (props) => {
    const idProps = ['id', 'labelFor', 'inputId'];
    const newProps = idProps.reduce((acc, idProp) => {
        if (props[idProp]) {
            return {
                ...acc,
                [idProp]: `${idPropsPrefix}-${props[idProp]}`
            };
        }
        return acc;
    }, props);
    return newProps;
};
const attachFunctionPropId = (props) => {
    for (const key in props) {
        const propValue = props[key];
        if (typeof propValue === 'function' && !propValue.__id__) {
            propValue.__id__ = (0, uuid_1.v4)();
        }
    }
    return props;
};
const handleReconcilerError = async (error) => {
    try {
        await self?.__bridge?.callBridge('onError', { error });
    }
    catch (e) {
        // eslint-disable-next-line no-console
        console.log('error calling bridge onError', e);
    }
};
const callBridge = function (cmd, data) {
    // @ts-ignore
    // eslint-disable-next-line @typescript-eslint/no-floating-promises
    self?.__bridge?.callBridge(cmd, data);
};
exports.callBridge = callBridge;
const createElement = ({ type, props = {}, forgeReactMajorVersion }) => {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { children, ...restProps } = props;
    const newProps = newPropsWithIdPrefix(attachFunctionPropId(restProps));
    const element = {
        type,
        children: [],
        props: newProps,
        key: (0, uuid_1.v4)()
    };
    if (forgeReactMajorVersion) {
        element.forgeReactMajorVersion = forgeReactMajorVersion;
    }
    return element;
};
exports.createElement = createElement;
const appendChild = (parent, child) => {
    if (parent.children.includes(child)) {
        const removeIndex = parent.children.indexOf(child);
        parent.children.splice(removeIndex, 1);
    }
    parent.children.push(child);
};
exports.appendChild = appendChild;
const insertBefore = (parent, child, beforeChild) => {
    const insertIndex = parent.children.indexOf(beforeChild);
    if (parent.children.includes(child)) {
        const removeIndex = parent.children.indexOf(child);
        parent.children.splice(removeIndex, 1);
    }
    parent.children.splice(insertIndex, 0, child);
};
exports.insertBefore = insertBefore;
/**
 * Performs a shallow comparison of the old and new props for a component, but doesn't
 * compare the "children" prop. This works because the custom reconciler extracts the
 * "children" prop from the ForgeDoc and includes it separately.
 *
 * This function is used in prepareUpdate to determine whether or not to increment the
 * reconciliationCount for the component - the reconciliationCount should only be incremented
 * if the props have changed.
 *
 * @param newProps The new props being passed to the component
 * @param oldProps The old props the component previously had
 * @returns True if the props are equal and false otherwise
 */
const nonChildPropsAreEqual = (oldProps, newProps) => {
    const newPropsKey = Object.keys(newProps).filter((key) => key !== 'children');
    const oldPropsKey = Object.keys(oldProps).filter((key) => key !== 'children');
    if (newPropsKey.length !== oldPropsKey.length) {
        return false;
    }
    for (const key of newPropsKey) {
        if (newProps[key] !== oldProps[key]) {
            return false;
        }
    }
    return true;
};
exports.nonChildPropsAreEqual = nonChildPropsAreEqual;
exports.hostConfig = {
    supportsMutation: true,
    supportsPersistence: false,
    noTimeout: -1,
    isPrimaryRenderer: false,
    supportsHydration: false,
    resetAfterCommit(containerInfo) {
        (0, exports.callBridge)('reconcile', { forgeDoc: containerInfo });
    },
    createInstance(type, instanceProps) {
        const element = (0, exports.createElement)({ type, props: instanceProps });
        return element;
    },
    createTextInstance(text) {
        const element = (0, exports.createElement)({ type: 'String', props: { text } });
        return element;
    },
    appendInitialChild(parentInstance, child) {
        (0, exports.appendChild)(parentInstance, child);
    },
    appendChild(parent, child) {
        (0, exports.appendChild)(parent, child);
    },
    appendChildToContainer(container, child) {
        (0, exports.appendChild)(container, child);
    },
    finalizeInitialChildren() {
        return false;
    },
    prepareUpdate(instance, type, oldProps, newProps) {
        instance.props = newProps;
        return newProps;
    },
    shouldSetTextContent() {
        return false;
    },
    getRootHostContext() {
        return {};
    },
    getChildHostContext() {
        return null;
    },
    getPublicInstance(instance) {
        return instance;
    },
    prepareForCommit() {
        return null;
    },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    preparePortalMount() { },
    scheduleTimeout(fn, delay) {
        return setTimeout(fn, delay);
    },
    cancelTimeout(id) {
        clearTimeout(id);
    },
    insertBefore(parentInstance, child, beforeChild) {
        (0, exports.insertBefore)(parentInstance, child, beforeChild);
    },
    insertInContainerBefore(container, child, beforeChild) {
        (0, exports.insertBefore)(container, child, beforeChild);
    },
    removeChild(parent, child) {
        const removeIndex = parent.children.indexOf(child);
        parent.children.splice(removeIndex, 1);
    },
    removeChildFromContainer(container, child) {
        const removeIndex = container.children.indexOf(child);
        container.children.splice(removeIndex, 1);
    },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    resetTextContent() { },
    commitTextUpdate(textInstance, oldText, newText) {
        textInstance.props.text = newText;
    },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    commitMount() { },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    commitUpdate() { },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    hideInstance() { },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    hideTextInstance() { },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    unhideInstance() { },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    unhideTextInstance() { },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    clearContainer() { },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    detachDeletedInstance() { },
    getCurrentEventPriority() {
        return constants_1.DefaultEventPriority;
    },
    getInstanceFromNode() {
        return null;
    },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    beforeActiveInstanceBlur() { },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    afterActiveInstanceBlur() { },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    prepareScopeUpdate() { },
    getInstanceFromScope() {
        return null;
    }
};
const reconciler = (0, react_reconciler_1.default)(exports.hostConfig);
exports.ForgeReconciler = {
    render: (element) => {
        const rootElement = (0, exports.createElement)({ type: 'Root', props: {}, forgeReactMajorVersion: 11 });
        const container = reconciler.createContainer(rootElement, 0, null, false, null, 'root', (err) => {
            // eslint-disable-next-line no-console
            console.log(err);
        }, null);
        try {
            reconciler.updateContainer(element, container, null, null);
        }
        catch (e) {
            // only report errors that are not recoverable
            void handleReconcilerError(e);
            throw e;
        }
    },
    addConfig: (element) => {
        const macroConfigElement = (0, exports.createElement)({ type: 'MacroConfig', props: {}, forgeReactMajorVersion: 11 });
        const container = reconciler.createContainer(macroConfigElement, 0, null, false, null, 'macroConfig', (err) => {
            // eslint-disable-next-line no-console
            console.log(err);
        }, null);
        reconciler.updateContainer(element, container, null, null);
    }
};
exports.default = exports.ForgeReconciler;
