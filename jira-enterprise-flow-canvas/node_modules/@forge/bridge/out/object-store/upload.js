"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.upload = exports.createUploadPromises = void 0;
const invoke_1 = require("../invoke");
const errors_1 = require("../errors");
const utils_1 = require("./utils");
const bridge_1 = require("../bridge");
const callBridge = (0, bridge_1.getCallBridge)();
const base64ToBlob = (base64, mimeType) => {
    const byteCharacters = atob(base64);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    return new Blob([byteArray], { type: mimeType || 'application/octet-stream' });
};
const getObjectMetadata = async (blob) => {
    const length = blob.size;
    const arrayBuffer = await blob.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
    const hashArray = new Uint8Array(hashBuffer);
    const checksum = btoa(String.fromCharCode(...hashArray));
    const checksumType = 'SHA256';
    return {
        length,
        checksum,
        checksumType
    };
};
const createUploadPromises = async ({ functionKey, objects }) => {
    if (!functionKey || functionKey.length === 0) {
        throw new errors_1.BridgeAPIError('functionKey is required to filter and generate presigned URLs');
    }
    if (!Array.isArray(objects) || objects.length === 0) {
        throw new errors_1.BridgeAPIError('objects array is required and must not be empty');
    }
    const blobs = objects.map((obj, index) => {
        if (obj instanceof Blob) {
            return obj;
        }
        const isBase64Object = obj && typeof obj === 'object' && 'data' in obj && typeof obj.data === 'string';
        if (!isBase64Object) {
            throw new errors_1.BridgeAPIError(`Invalid object type at index ${index}. Only Blob or Base64Object (with data string and optional mimeType) are accepted.`);
        }
        try {
            return base64ToBlob(obj.data, obj.mimeType);
        }
        catch (e) {
            throw new errors_1.BridgeAPIError(`Invalid base64 data at index ${index}. The data string must be valid base64 encoded.`);
        }
    });
    const allObjectMetadata = await Promise.all(blobs.map((blob) => getObjectMetadata(blob)));
    const presignedURLsToObjectMetadata = (await (0, invoke_1.invoke)(functionKey, {
        allObjectMetadata
    }));
    if (!presignedURLsToObjectMetadata || typeof presignedURLsToObjectMetadata !== 'object') {
        throw new errors_1.BridgeAPIError('Invalid response from functionKey');
    }
    const checksumToBlobMap = new Map();
    const checksumToIndexMap = new Map();
    blobs.forEach((blob, index) => {
        const metadata = allObjectMetadata[index];
        checksumToBlobMap.set(metadata.checksum, blob);
        checksumToIndexMap.set(metadata.checksum, index);
    });
    const uploadPromises = Object.entries(presignedURLsToObjectMetadata).map(([presignedUrl, metadata]) => {
        const { key, checksum } = metadata;
        const object = checksumToBlobMap.get(checksum);
        const index = checksumToIndexMap.get(checksum);
        if (index === undefined) {
            return {
                promise: Promise.resolve({
                    success: false,
                    key: key,
                    error: `Index not found for checksum ${checksum}`
                }),
                index: -1
            };
        }
        if (!object) {
            return {
                promise: Promise.resolve({
                    success: false,
                    key: key,
                    error: `Blob not found for checksum ${checksum}`
                }),
                index
            };
        }
        const uploadPromise = (async () => {
            try {
                const response = await fetch(presignedUrl, {
                    method: 'PUT',
                    body: object,
                    headers: {
                        'Content-Type': object.type || 'application/octet-stream',
                        'Content-Length': object.size.toString()
                    }
                });
                return {
                    success: response.ok,
                    key: key,
                    status: response.status,
                    error: response.ok ? undefined : `Upload failed with status ${response.status}`
                };
            }
            catch (error) {
                return {
                    success: false,
                    key: key,
                    status: 503,
                    error: error instanceof Error ? error.message : 'Upload failed'
                };
            }
        })();
        return { promise: uploadPromise, index, objectType: object.type, objectSize: object.size };
    });
    return uploadPromises;
};
exports.createUploadPromises = createUploadPromises;
const upload = async ({ functionKey, objects }) => {
    await (0, utils_1.checkRestrictedEnvironment)();
    void callBridge('trackObjectStoreAction', { action: 'upload' });
    const uploadPromises = await (0, exports.createUploadPromises)({ functionKey, objects });
    const results = await Promise.all(uploadPromises.map((item) => item.promise));
    return results;
};
exports.upload = upload;
