"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.productFetchApi = exports.remoteFetchApi = void 0;
const blobParser_1 = require("../utils/blobParser");
const parseFormData = async (form, matchFilePrefix = false) => {
    const parsed = {};
    for (const [key, value] of form.entries()) {
        const isFileKey = matchFilePrefix ? key.startsWith('file') : key === 'file';
        if (isFileKey) {
            const fileName = value.name;
            const fileType = value.type;
            parsed[key] = await (0, blobParser_1.blobToBase64)(value);
            parsed[`__${key}Name`] = fileName;
            parsed[`__${key}Type`] = fileType;
        }
        else {
            parsed[key] = value;
        }
    }
    return JSON.stringify(parsed);
};
const validateFetchOptions = (init) => {
    if (!init) {
        return init;
    }
    if ('signal' in init) {
        const { signal: _signal, ...rest } = init;
        console.error('Signal is not supported in @forge/bridge and was removed from fetch options. Please use the fetch method from @forge/api for signal support.');
        return rest;
    }
    return init;
};
const parseRequest = async (fetchType, init) => {
    const isFormData = (init === null || init === void 0 ? void 0 : init.body) instanceof FormData ? true : false;
    const requestBody = isFormData ? await parseFormData(init === null || init === void 0 ? void 0 : init.body, fetchType === 'remote') : init === null || init === void 0 ? void 0 : init.body;
    const req = new Request('', { body: requestBody, method: init === null || init === void 0 ? void 0 : init.method, headers: init === null || init === void 0 ? void 0 : init.headers });
    const headers = Object.fromEntries(req.headers.entries());
    const body = req.method !== 'GET' ? await req.text() : null;
    return {
        body,
        headers: new Headers(headers),
        isMultipartFormData: isFormData
    };
};
const remoteFetchApi = (callBridge) => {
    const fetch = async (remoteKey, init) => {
        const validatedInit = validateFetchOptions(init);
        const { body: requestBody, headers: requestHeaders, isMultipartFormData } = await parseRequest('remote', validatedInit);
        const fetchPayload = {
            remoteKey,
            fetchRequestInit: { ...validatedInit, body: requestBody, headers: [...requestHeaders.entries()] },
            isMultipartFormData
        };
        const { body, headers, statusText, status, isAttachment } = await callBridge('fetchRemote', fetchPayload);
        const responseBody = isAttachment ? (0, blobParser_1.base64ToBlob)(body, headers['content-type']) : body;
        return new Response(responseBody || null, { headers, status, statusText });
    };
    return {
        requestRemote: (remoteKey, fetchOptions) => fetch(remoteKey, fetchOptions)
    };
};
exports.remoteFetchApi = remoteFetchApi;
const productFetchApi = (callBridge) => {
    const fetch = async (product, restPath, init) => {
        const validatedInit = validateFetchOptions(init);
        const { body: requestBody, headers: requestHeaders, isMultipartFormData } = await parseRequest('product', validatedInit);
        if (!requestHeaders.has('X-Atlassian-Token')) {
            requestHeaders.set('X-Atlassian-Token', 'no-check');
        }
        const fetchPayload = {
            product,
            restPath,
            fetchRequestInit: {
                ...validatedInit,
                body: requestBody,
                headers: [...requestHeaders.entries()]
            },
            isMultipartFormData
        };
        const { body, headers, statusText, status, isAttachment } = await callBridge('fetchProduct', fetchPayload);
        const responseBody = isAttachment ? (0, blobParser_1.base64ToBlob)(body, headers['content-type']) : body;
        return new Response(responseBody || null, { headers, status, statusText });
    };
    return {
        requestConfluence: (restPath, fetchOptions) => fetch('confluence', restPath, fetchOptions),
        requestJira: (restPath, fetchOptions) => fetch('jira', restPath, fetchOptions),
        requestBitbucket: (restPath, fetchOptions) => fetch('bitbucket', restPath, fetchOptions)
    };
};
exports.productFetchApi = productFetchApi;
