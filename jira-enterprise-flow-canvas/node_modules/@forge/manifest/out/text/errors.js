"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.References = exports.errors = void 0;
const types_1 = require("../types");
const utils_1 = require("../utils");
exports.errors = {
    invalidManifest: (reason) => `manifest.yml failed to parse content - ${reason}`,
    twgPreviewScopes: (scopes) => `This app requests Teamwork Graph scopes (${scopes.join(', ')}), which grant org-wide read access ` +
        `across Jira, Confluence, Compass, JSM, Teams, Goals, Projects, and users. ` +
        `End-user permissions are respected, but access is not limited to a single site or product.`,
    missingManifest: () => `To run this command, make sure you're in the top-level directory of your app, and the manifest.yml file is in the same directory.`,
    schemaError: (value, path, reason) => {
        if (value) {
            return `${path.join(' ')} '${value}' ${reason}`;
        }
        return `${path.length === 0 ? 'document' : path.join(' ')} ${reason}`;
    },
    schema: {
        oneOf: (props) => props
            ? `required properties are ${props.map((v) => "'" + v.join(', ') + "'").join(' or ')}`
            : 'provided properties do not match schema. Learn more about modules at https://go.atlassian.com/forge-modules.',
        enumValues: (props) => `allowed values are ${props.map((v) => "'" + v + "'").join(', ')}`,
        deprecatedValue: (section, field, additionalInfo) => `The "${field}" property under "${section}" is deprecated and can be removed. ${additionalInfo ? `${additionalInfo}` : ''}`,
        additionalProperties: (additionalProperty) => `should NOT have additional property '${additionalProperty}'`,
        notAllowed: (props) => props
            ? `does not support the following Forge properties - ${props.map((v) => "'" + v + "'").join(', ')}`
            : 'provided properties do not match schema. Learn more about modules at https://go.atlassian.com/forge-modules',
        missingEnvironmentVariable: (variable) => `could not find environment variable '${variable}'`,
        errorReadingResourceFile: (variable, errorMessage) => `error while reading resource file: '${variable}'. Error: ${errorMessage}`,
        resourceNotFound: (variable) => `could not find resource: '${variable}'`,
        resourcePathNotDefined: (variable) => `resource path not defined for resource: '${variable}'`,
        resourceFileNotSupported: (variable) => `resource file type not supported: '${variable}'`
    },
    permissions: {
        invalidPermission: (element, value) => `Invalid '${element}' permission in the manifest.yml file - '${value}'. Learn more about permissions at: https://go.atlassian.com/forge-permissions.`,
        missingPermissionFromScope: (scope, event) => `Trigger event: '${event}' requires '${scope}' scope`,
        missingEndpointPermissionFromScope: (scope, key) => `Endpoint module: '${key}' requires '${scope}' scope.`,
        missingRemotePermissionFromScope: (scope, key) => `Remote: '${key}' requires '${scope}' scope.`,
        deprecatedPermission: (element, value) => `There are deprecated scopes '${element}' in the manifest.yml file: '${value.join(', ')}'. You need to update this app to use new scopes and remove the deprecated scopes. Learn more at: https://go.atlassian.com/forge-permissions.`,
        deprecatedEgressPermission: (key) => `There are deprecated egress permission entries for '${key}' in the manifest.yml file`,
        globalUrlNotRecommended: (element) => `Global URL usage detected for '${element}' permission in the manifest.yml file. We recommend using a more specific URL.`,
        imageUrlNotRecommended: (element, value) => `Unnecessary URL detected for '${element}' permission in the manifest.yml file. Your app should not need the URL '${value}' to work properly.`,
        fontAndStylesNotRecommended: (element) => `Unnecessary usage of '${element}' permission in the manifest.yml file. You can avoid using this permission by packaging the fonts and styles with your app code.`,
        backendEgressPathIgnored: (url) => `Detected a backend egress URL with a path in manifest.yml: '${url}'. Currently, backend egress only validates domains, so the path is ignored.`,
        malformedScope: (index) => `The scope definition at index '${index}' is malformed. Use either a string with the scope key, or an object with the scope key as the only key`
    },
    connectModules: {
        invalidConnectModule: (module) => `invalid value '${module}' in connectModules`,
        duplicateLifecycleFound: (module) => `'${module}' should contain only one element`
    },
    modules: {
        invalidModule: (module) => `invalid value '${module}' in modules`,
        missingModule: () => 'document must have at least 1 module',
        missingFunction: () => 'document must have at least 1 function',
        duplicateKeyFound: (key) => `found duplicate module key '${key}'`,
        wrongFunctionReference: (module, functionKey) => `${module} references undefined function module with key '${functionKey}'`,
        wrongEndpointReference: (module, endpointKey) => `${module} references undefined endpoint module with key '${endpointKey}'`,
        wrongServiceReference: (module, serviceKey) => `${module} references undefined service with key '${serviceKey}'`,
        wrongResourceReference: (module, resourceKey) => `missing resource key '${resourceKey}' is being referenced by ${module} module`,
        wrongResourceType: (folder) => `Client Side UI Kit resource (${folder}) cannot be a directory`,
        singleEntryOfTheModule: (moduleType) => `Only a single entry of the ${moduleType} module can be defined in the manifest`,
        singleEntryOfModuleWithoutConfigureAndStartedParams: (moduleType) => `The ${moduleType} module can only have a single entry that doesn’t include either useAsConfig or useAsGetStarted properties.`,
        singleEntryOfModuleWithConfigureParam: (moduleType) => `The ${moduleType} module can only have a single entry that includes the useAsConfig property.`,
        singleEntryOfModuleWithGetStartedParam: (moduleType) => `The ${moduleType} module can only have a single entry that includes the useAsGetStarted property.`,
        displayConditions: {
            overcomplicated: (moduleKey) => `Nesting of display conditions of the "${moduleKey}" module exceeds 10 levels.`,
            invalid: (moduleKey) => `Display conditions of the "${moduleKey}" module are invalid.`,
            propertyNotAllowed: (moduleKey, propertyName) => `Display conditions of the "${moduleKey}" module are invalid. "${propertyName}" property is not allowed.`,
            typeMismatch: (moduleKey, propertyName, errorDetails) => `Display conditions of the "${moduleKey}" module are invalid. "${propertyName}" property ${errorDetails}.`
        },
        bitbucket: {
            endpointOnlySupportSystemToken: (moduleKey, endpointModuleKey) => `Bitbucket module: '${moduleKey}' using remote endpoint: '${endpointModuleKey}' only supports appSystemToken. Update appUserToken to false.`,
            endpointNeedsRoute: (moduleKey, endpointModuleKey) => `Bitbucket module: '${moduleKey}' using remote endpoint: '${endpointModuleKey}' requires 'route' parameter.`
        },
        confluence: {
            multipleProperty: (property, moduleKey, keys) => `There can be only 1 ${moduleKey} module which designates "${property}": true. Modules containing designation: ${keys.join(', ')}`,
            propertyUniqueness: (property, moduleKey, keys) => `${property} should be unique across all ${moduleKey} modules. Found duplicates: ${keys.join(', ')}`,
            crossModulePropertyUniqueness: (property, keys) => `${property} should be unique across all modules. Found duplicates: ${keys.join(', ')}`,
            validateCustomContentHierarchyUnknown: (property, moduleKey, unknownKey) => `${property} of the "${moduleKey}" module refers to unknown key: ${unknownKey}`,
            validateCustomContentCrossReferenceMissingContainer: (moduleKey, referredModuleKey) => `supportedContainerTypes of the "${moduleKey}" module refers to "${referredModuleKey}" module. "${referredModuleKey}" module must include "${moduleKey}" in supportedChildTypes`,
            validateCustomContentCrossReferenceMissingChild: (moduleKey, referredModuleKey) => `supportedChildTypes of the "${moduleKey}" module refers to "${referredModuleKey}" module. "${referredModuleKey}" module must include "${moduleKey}" in supportedContainerTypes`,
            keyboardShortcuts: {
                emptyAccelerator: () => 'Keyboard shortcut accelerator must be defined and not be an empty string.',
                spaceAroundAccelerator: (accelerator) => `Keyboard shortcut accelerator must not have surrounding empty spaces. Accelerator issue found: [${accelerator}]`,
                invalidPlusSyntax: (accelerator) => `Keyboard shortcut accelerator must not be single "+" character or have empty spaces on left or right of "+" character. Accelerator issue found: [${accelerator}]`,
                combinationKeysAreNotUnique: (accelerator) => `Keyboard shortcut accelerator combinations must have unique keys when joined with "+". Accelerator issue found: [${accelerator}]`,
                invalidKey: (accelerator, key) => `Keyboard shortcut accelerator key must be a valid named key, i.e. ctrl, command, or a single key. Accelerator issue found: [${accelerator}] with invalid key: [${key}]`,
                moreThanOneNonModifierKey: (accelerator) => `Keyboard shortcut accelerator combination is invalid. A valid accelerator combination should have a single key or a single key preceeded with one or more modifiers, i.e. ctrl, shift, command. Accelerator issue found: [${accelerator}]`,
                modifierKeysShouldPrecedeNonModifierKey: (accelerator) => `Keyboard shortcut accelerator modifier keys should precede the key being modified. Instead of "a+ctrl", one should specify the accelerator as "ctrl+a". Accelerator issue found: [${accelerator}]`
            },
            autoConvert: {
                invalidMatcherPatternRegex: (pattern, keyName, index) => `The pattern '${pattern}' at index '${index}' for key '${keyName}' needs to be in a valid URL format between 1-1024 characters long and cannot use wildcard (*) for protocol. Please provide a valid URL within the character limitations and with a valid protocol.`,
                emptyMatcherArray: (keyName) => `Macro autoConvert matchers array for key '${keyName}' must not be empty array.`
            },
            fullPage: {
                invalidRouteRegex: (pattern, keyName, index) => `The routePrefix '${pattern}' at index '${index}' for key '${keyName}' needs to be in a valid URL route between 1-255 characters and contain only URL safe characters such as: a-z, 0-9 and '\' and '-'.`,
                invalidIcon: (pattern, keyName, index) => `The icon '${pattern}' at index '${index}' for key '${keyName}' needs to be a defined resource of file type svg.`
            }
        },
        jiraWorkflowValidator: {
            missingProperty: (key) => `${types_1.AllModuleTypes.JiraWorkflowValidator} module '${key}' must have either a function or expression.`,
            invalidProperty: (key) => `${types_1.AllModuleTypes.JiraWorkflowValidator} module '${key}' can only have either a function or expression`
        },
        jiraWorkflowCondition: {
            missingExpression: (key) => `${types_1.AllModuleTypes.JiraWorkflowCondition} module '${key}' must have a non-blank expression.`
        },
        jiraEntityProperty: {
            maxExtractionsPerApp: (limit) => `All ${types_1.AllModuleTypes.JiraEntityProperty} modules combined cannot declare more than ${limit} values.`
        },
        jiraJqlFunction: {
            duplicateFunctionNames: (names) => `JQL function names must be unique. Found duplicates: ${names.join(', ')}.`
        },
        jiraActionValidator: {
            limitPerActionType: (actionType, limit) => `Only ${limit} ${types_1.AllModuleTypes.JiraActionValidator} module is allowed per action type. Found multiple modules for action type: ${actionType}.`,
            incompatibleModules: (otherModules) => `${types_1.AllModuleTypes.JiraActionValidator} modules can only be declared with page modules and core functions. Found incompatible modules: ${otherModules.join(', ')}.`,
            tooManyModules: (totalModules, limit) => `Apps with ${types_1.AllModuleTypes.JiraActionValidator} modules can declare up to ${limit} additional modules. Found ${totalModules} total modules.`
        },
        jiraFullPageModule: {
            invalidRouteRegex: (pattern, keyName, index) => `The routePrefix '${pattern}' at index '${index}' for key '${keyName}' needs to be in a valid URL route between 1-255 characters and contain only URL safe characters such as: a-z, 0-9 and '\' and '-'.`,
            propertyUniqueness: (property, moduleKey, keys) => `${property} should be unique across all ${moduleKey} modules. Found duplicates: ${keys.join(', ')}`,
            invalidIcon: (icon, keyName, index) => `The icon '${icon}' at index '${index}' for key '${keyName}' needs to be a defined resource of file type svg.`
        },
        moduleScopesValidator: {
            missingScopes: (moduleType, key, scopes) => `${moduleType} module '${key}' requires '${scopes.join(', ')}' scope(s).`
        },
        customFields: {
            searchAlias: (aliases) => `Search alias should be always unique per field. Found duplicates: ${aliases.join(', ')}.`,
            connectFieldPropertyRequiresMigration: (key) => `jira:customField module '${key}' cannot have connectFieldProperty unless migratedFromConnect is true.`
        },
        subPages: {
            invalidPagesAndSectionsForConfigurePages: (key) => `You can’t use either pages or sections in the ${key} entry that includes either useAsConfig or useAsGetStarted properties.`,
            subPagesWithUIKit: (key) => `Subpages in UI kit are not supported. Use Custom UI in the '${key}' module instead.`,
            invalidPagesAndSections: (key) => `'pages' cannot be used with 'sections' in the module '${key}'.`
        },
        function: {
            invalidKeyLength: (key) => `The function key exceeds 23 characters: ‘${key}’.`,
            handler: {
                invalidRegex: (key, regex) => `${(0, utils_1.cleanKey)(types_1.AllModuleTypes.CoreFunction)} handler property '${key}' must be in format <module>.<function> (example: index.run).`,
                fileNotExists: (key, fileName) => `${(0, utils_1.cleanKey)(types_1.AllModuleTypes.CoreFunction)} handler property '${key}' cannot find associated file with name '${fileName}.[jt](s|sx)'`
            }
        },
        endpoint: {
            remote: {
                notExists: (key) => `${(0, utils_1.cleanKey)(types_1.AllModuleTypes.CoreEndpoint)} remote property '${key}' was not found.`
            }
        },
        trigger: {
            ignoreSelfFilteringWorksOnlyWithJiraEvents: () => `Trigger filtering with ignoreSelf works only with Jira events`,
            endpointOnlySupportSystemToken: (productEventKey, endpointModuleKey) => `Trigger module: '${productEventKey}' using remote endpoint: '${endpointModuleKey}' only supports appSystemToken. Update appUserToken to false.`,
            endpointNeedsRoute: (productEventKey, endpointModuleKey) => `Trigger module: '${productEventKey}' using remote endpoint: '${endpointModuleKey}' requires 'route' parameter.`
        },
        remote: {
            missingModuleRemoteStorageInScopeEUD: (key) => `missing storage.inScopeEUD in ${key} module. storage.inScopeEUD is required if storage is present in operations.`,
            allRegionsNotDeclared: (key) => `All region specific URLs are not declared for ${key}`,
            baseUrlNotPresent: (key) => `A remote must declare baseUrl for ${key}`,
            neitherBaseUrlNorUserConfigurationPresent: (key) => `A remote must declare either baseUrl or configurable for ${key}`
        },
        rovo: {
            incorrectAgentActionReference: (module, moduleKey) => `${module} references undefined action module with key '${moduleKey}'.`,
            undefinedActionName: (action) => `Action '${action}' does not have a name property. 'name' property will be required when Forge Agents are GA.`,
            incorrectA2AEndpointReference: (module, endpointKey) => `${module} references undefined endpoint '${endpointKey}' in agent2Agent protocol.`,
            incorrectA2AEndpointConfiguration: (module, endpointKey) => `${module} endpoint '${endpointKey}' must reference a remote. Agent2Agent protocol requires remote endpoints.`
        },
        action: {
            unreferencedAction: (action) => `Action '${action}' is not referenced by any Rovo agent or automation:actionProvider module.`,
            tooManyAutomationActions: (limit) => `App is allowed to define max ${limit} actions within automation:actionProvider modules`,
            undefinedAutomationActionReference: (module, moduleKey) => `${module} references undefined action module with key '${moduleKey}'.`
        },
        llm: {
            tooManyModulesDeclared: (numberOfModules) => `Found ${numberOfModules} LLM modules. Maximum 1 is allowed.`,
            tooManyModelsDeclared: (numberOfModels, limit) => `Found ${numberOfModels} LLM models. Maximum ${limit} are allowed.`,
            duplicateModel: (modelName) => `Found duplicate llm model name '${modelName}'.`
        },
        graphConnector: {
            invalidAuthProvider: (moduleKey, provider) => `graph:connector module '${moduleKey}' references auth provider '${provider}' which is not defined in providers.auth. Define it in providers.auth.`
        },
        'migration:dataResidency': {
            remoteNotFound: (key) => `No remote found with key '${key}' matching migration:dataResidency.remote.`,
            moreThanOneRemote: () => `More than one remote found in migration:dataResidency.`,
            missingRemote: () => `Missing remote in migration:dataResidency.`
        }
    },
    resources: {
        missingResource: (folder, key) => `missing resource '${folder}' is being referenced by '${key}' in resources`,
        duplicateKeyFound: (key) => `found duplicate resource key '${key}'`,
        emptyDirectory: (folder, key) => `empty directory '${folder}' is being referenced by '${key}' in resources`,
        missingEntrypoint: (folder, key) => `missing index.html file in directory (${folder}) is being referenced by a Custom UI resource in ${key} module`,
        deprecatedCspPolicyDefinition: (folder) => `The index.html file in the (${folder}) directory is using a deprecated method of defining CSP. To use the supported method, go to: https://go.atlassian.com/forge-content-security-and-egress-controls`,
        tooManyResourcesError: (limit) => `document exceeds ${limit} resources`,
        nonDirectory: (folder, key) => `Custom UI resource must be a directory. (${folder}) in ${key} module is not a directory`
    },
    deprecationInfo: {
        app: {
            name: 'You can now manage this in the Developer Console at https://developer.atlassian.com/console/.'
        }
    },
    providers: {
        missingRemote: (provider, remote) => `missing remote '${remote}' is being referenced by '${provider}' in providers`,
        missingEgress: (remote) => `missing egress permissions for remote '${remote}'. Please add the remote to permissions.fetch`,
        missingProfileFunction: (provider, functionKey) => `missing function '${functionKey}' is being referenced by '${provider}' in providers`,
        hasRegionUrls: (provider, remote) => `External Authentication Provider does not support region specific URLs. The '${provider}' provider's remote '${remote}' contains region specific URLs.`
    },
    app: {
        missingAppConnectRemote: () => `missing app.connect.remote. app.connect.remote is required if connectModules are present.`,
        missingRemoteForConnect: (key) => `no remote found with key '${key}' matching app.connect.remote value.`,
        missingConnectModules: () => 'Missing connectModules. When app.connect.authentication is present, connectModules is required.',
        features: {
            deprecatedAutoUserConsent: () => 'The autoUserConsent feature flag is no longer required to use automatic user consent and should be removed from the manifest.'
        },
        remotes: {
            missingRemotesStorageInScopeEUD: (key) => `missing storage.inScopeEUD in remote ${key}. storage.inScopeEUD is required if storage is present in operations.`,
            missingAppScopesForRemoteAuth: () => 'Missing app scopes. If OAuth tokens are required, add valid scopes in addition to OAuth token config scopes (see https://go.atlassian.com/forgescopes). Otherwise, remove OAuth token config.'
        },
        storage: {
            entities: {
                entityNameTooLong: (entity, limit) => `Entity name '${entity}' exceeds maximum allowed length of ${limit} characters.`,
                missingAttributes: (entity) => `Entity '${entity}' must contain at least one attribute.`,
                tooManyAttributes: (entity, limit) => `Entity '${entity}' contains more attributes than the allowed limit of ${limit}.`,
                attributeNameTooLong: (entity, attribute, limit) => `Entity '${entity}' attribute name '${attribute}' exceeds maximum allowed length of ${limit}.`,
                tooManyIndexes: (entity, limit) => `Entity '${entity}' contains more indexes than the allowed limit of ${limit}.`,
                invalidIndexRange: (entity, index) => `Entity '${entity}' index '${index}' must refer to a valid attribute of the entity.`,
                invalidIndexPartition: (entity, partition) => `Entity '${entity}' index partition '${partition}' must refer to a valid attribute of the entity.`,
                reservedIndexName: (entity, index) => `Entity '${entity}' cannot use reserved index name '${index}'.`
            }
        },
        package: {
            extraFiles: {
                missing: (glob) => `Extra files specification '${glob}' does not match any files.`
            }
        },
        compatibility: {
            invalidConfluenceModuleInJira: () => 'Using the module `confluence:fullPage` is invalid when the required product is Jira. Full page modules must match the required product. Use `jira:fullPage` as the module type, or change the required product to Confluence in your manifest.yml compatibility settings.',
            invalidJiraModuleInConfluence: () => 'Using the module `jira:fullPage` is invalid when the required product is Confluence. Full page modules must match the required product. Use `confluence:fullPage` as the module type, or change the required product to Jira in your manifest.yml compatibility settings.'
        }
    },
    translations: {
        missingTranslationsJsonFile: (languageLocaleCode) => `There is no available translations JSON file for the specified fallback language: '${languageLocaleCode}'`,
        duplicateFallbackConfig: (languageLocaleCode) => `Duplicated fallback configuration found for: '${languageLocaleCode}'`,
        invalidLanguageFile: (languageLocaleCode, path) => `An error occurred while reading JSON file for '${languageLocaleCode}' at the specified path: ${path}`,
        duplicateResourceKey: (languageLocaleCode) => `Duplicate translations resource key found: '${languageLocaleCode}'`,
        i18nKeyNotFound: (keyName) => `i18n key '${keyName}' could not be found in default locale file.`,
        missingTranslationsPropertyError: 'i18n key(s) found but translations property is missing in manifest file',
        internalI18nPropertyKeyFound: (propertyKey, moduleKey) => `Unexpected property key '${propertyKey}' found in '${moduleKey}' module`,
        i18nValueValidationError: (keyName, languageLocaleCode, errorMsg) => `i18n value for key '${keyName}' for locale '${languageLocaleCode}' ${errorMsg}`
    },
    deprecation: {
        runtime: {
            message: (runtimeName) => {
                const changelogUrl = 'https://go.atlassian.com/forge-changelog';
                return runtimeName === 'sandbox'
                    ? `The sandbox runtime is deprecated and will be removed in the future ${changelogUrl}/#CHANGE-789.`
                    : `The ${runtimeName} runtime is deprecated and will be removed in the future. Check ${changelogUrl} for more information on ${runtimeName} deprecation and removal dates.`;
            }
        }
    }
};
var References;
(function (References) {
    References["MissingManifest"] = "manifest-file-required";
    References["InvalidManifest"] = "valid-yaml-required";
    References["SchemaError"] = "valid-document-required";
    References["Permissions"] = "valid-permissions-required";
    References["MissingScopes"] = "permission-scope-required";
    References["Modules"] = "valid-module-required";
    References["ConnectModules"] = "valid-connect-module-required";
    References["Resources"] = "valid-resource-required";
    References["Providers"] = "valid-provider-required";
    References["Deprecated"] = "deprecated-property";
    References["App"] = "valid-app-config-required";
})(References = exports.References || (exports.References = {}));
