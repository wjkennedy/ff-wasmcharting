"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateUnreferencedActions = void 0;
const types_1 = require("../../../types");
const text_1 = require("../../../text");
const utils_1 = require("../../../utils");
const validateUnreferencedActions = (allModules, yamlContentByLine) => {
    const validationErrors = [];
    const unreferencedActions = getUnreferencedActions(allModules);
    unreferencedActions.forEach((action) => {
        validationErrors.push(getValidationError(action, yamlContentByLine));
    });
    return validationErrors;
};
exports.validateUnreferencedActions = validateUnreferencedActions;
function getUnreferencedActions(allModules) {
    const actionKey = (0, utils_1.cleanKey)(types_1.AllModuleTypes.CoreAction);
    const allActions = new Set((allModules[actionKey]?.map((action) => action.key) ?? []));
    const rovoAgents = allModules[types_1.AllModuleTypes.RovoAgent];
    const automationActionProviders = allModules[types_1.AllModuleTypes.AutomationActionProvider];
    rovoAgents?.forEach((agent) => {
        agent.actions?.forEach((action) => {
            allActions.delete(action);
        });
    });
    automationActionProviders?.forEach((actionProvider) => {
        actionProvider.actions?.forEach((action) => {
            allActions.delete(action);
        });
    });
    return Array.from(allActions);
}
function getValidationError(action, yamlContentByLine) {
    return {
        message: text_1.errors.modules.action.unreferencedAction(action),
        reference: text_1.References.Modules,
        level: 'warning',
        ...(0, utils_1.findPosition)(action, yamlContentByLine)
    };
}
