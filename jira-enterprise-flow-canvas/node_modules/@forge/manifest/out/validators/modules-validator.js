"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModulesValidator = void 0;
const types_1 = require("../types");
const utils_1 = require("../utils");
const text_1 = require("../text");
const fs_1 = require("fs");
const path_1 = require("path");
const ui_modifications_1 = require("./modules-validators/jira/ui-modifications");
const validate_timetrackingprovider_module_1 = require("./modules-validators/jira/validate-timetrackingprovider-module");
const confluence_1 = require("./modules-validators/confluence");
const validate_full_admin_page_1 = require("./modules-validators/jira/validate-full-admin-page");
const remote_1 = require("./modules-validators/remote");
const dataResidency_1 = require("./modules-validators/dataResidency");
const validateModuleScopes_1 = require("./modules-validators/validateModuleScopes");
const bitbucket_1 = require("./modules-validators/bitbucket");
const rovo_1 = require("./modules-validators/rovo");
const validate_workflow_1 = require("./modules-validators/jira/validate-workflow");
const validate_full_page_1 = require("./modules-validators/jira/validate-full-page");
const validate_full_page_module_1 = require("./modules-validators/jira/validate-full-page-module");
const validate_custom_field_1 = require("./modules-validators/jira/validate-custom-field");
const validate_trigger_1 = require("./modules-validators/jira/validate-trigger");
const validate_command_1 = require("./modules-validators/jira/validate-command");
const validate_action_validator_1 = require("./modules-validators/jira/validate-action-validator");
const automation_1 = require("./modules-validators/automation");
const graph_1 = require("./modules-validators/graph");
class ModulesValidator {
    functionHandlerRegex = /^([\p{Alpha}\d_-]+(?:\/[\p{Alpha}\d_-]+)*)\.([\p{Alpha}\d_-]+)$/u;
    async validate(manifest) {
        if (!manifest?.typedContent || !manifest.filePath) {
            return {
                success: false,
                manifestObject: manifest
            };
        }
        let validationErrors = [...this.connectModuleValidation(manifest)];
        if (manifest.typedContent.modules) {
            const { typedContent: { modules, connectModules, remotes, permissions, services, providers }, yamlContentByLine, filePath } = manifest;
            validationErrors = validationErrors.concat(this.checkUnsupportedModules(manifest.typedContent.modules, yamlContentByLine), this.functionKeyLength(modules, yamlContentByLine), this.minimumModuleCountValidation(modules, yamlContentByLine), this.functionKeyDefinedValidation(modules, yamlContentByLine), this.endpointValidations(modules, yamlContentByLine, remotes, permissions?.scopes || [], services), this.duplicateModuleKeyValidation(modules, connectModules || {}, yamlContentByLine), this.functionHandlerValidation(modules, yamlContentByLine, filePath), (0, validate_workflow_1.validateJiraWorkflowValidator)(modules, yamlContentByLine), (0, validate_workflow_1.validateJiraWorkflowCondition)(modules, yamlContentByLine), (0, ui_modifications_1.validateUiModificationsModule)(modules, yamlContentByLine), (0, validate_full_admin_page_1.validateJiraFullAdminPage)(modules, yamlContentByLine), (0, validate_full_page_1.validateJiraFullPage)(modules, yamlContentByLine), (0, validate_full_page_module_1.validateJiraFullPageModule)(modules, yamlContentByLine), (0, validate_custom_field_1.validateJiraCustomField)(modules, yamlContentByLine), (0, confluence_1.validateConfluenceModules)(modules, yamlContentByLine), (0, bitbucket_1.validateBitbucketModules)(modules, yamlContentByLine), (0, validate_trigger_1.validateJiraTriggers)(modules, yamlContentByLine), (0, remote_1.validateRemoteModules)(modules, yamlContentByLine), (0, dataResidency_1.validateMigrationDataResidencyModule)(modules, remotes, yamlContentByLine), (0, validateModuleScopes_1.validateModuleScopes)(modules, yamlContentByLine, permissions), (0, rovo_1.validateRovoModules)(modules, yamlContentByLine), (0, automation_1.validateAutomationModules)(modules, yamlContentByLine), (0, validate_timetrackingprovider_module_1.validateJiraTimeTrackingModule)(modules, yamlContentByLine), (0, validate_command_1.validateJiraCommandModule)(modules, yamlContentByLine), (0, validate_action_validator_1.validateJiraActionValidator)(modules, yamlContentByLine), (0, graph_1.validateGraphModules)(modules, providers, yamlContentByLine));
        }
        else {
            const { typedContent: { connectModules }, yamlContentByLine } = manifest;
            validationErrors = validationErrors.concat(this.duplicateModuleKeyValidation({}, connectModules || {}, yamlContentByLine));
        }
        return {
            success: validationErrors.length === 0,
            manifestObject: manifest,
            errors: validationErrors
        };
    }
    isNotFunctionOrEndpoint(moduleKey) {
        return moduleKey !== (0, utils_1.cleanKey)(types_1.AllModuleTypes.CoreFunction) && moduleKey !== (0, utils_1.cleanKey)(types_1.AllModuleTypes.CoreEndpoint);
    }
    functionKeyLength(modules, yamlContentByLine) {
        const validationErrors = [];
        modules.function?.forEach((f) => {
            if (f.key.length > 23) {
                validationErrors.push({
                    message: text_1.errors.modules.function.invalidKeyLength(f.key),
                    reference: text_1.References.Modules,
                    level: 'error',
                    ...(0, utils_1.findPosition)(f.key, yamlContentByLine)
                });
            }
        });
        return validationErrors;
    }
    minimumModuleCountValidation(modules, yamlContentByLine) {
        const validationErrors = [];
        if (Object.keys(modules).filter((moduleKey) => this.isNotFunctionOrEndpoint(moduleKey)).length < 1) {
            validationErrors.push({
                message: text_1.errors.modules.missingModule(),
                reference: text_1.References.Modules,
                level: 'error',
                ...(0, utils_1.findPosition)('app', yamlContentByLine)
            });
        }
        return validationErrors;
    }
    checkUnsupportedModules(modules, yamlContentByLine) {
        const validationErrors = [];
        Object.keys(modules)
            .filter((key) => !types_1.SUPPORTED_MODULES.map((key) => (0, utils_1.cleanKey)(key)).includes(key))
            .forEach((invalidKey) => {
            validationErrors.push({
                message: text_1.errors.modules.invalidModule(invalidKey),
                reference: text_1.References.Modules,
                level: 'error',
                ...(0, utils_1.findPosition)(invalidKey, yamlContentByLine)
            });
        });
        return validationErrors;
    }
    connectModuleValidation(manifest) {
        const validationErrors = [];
        if (!manifest.typedContent?.modules && !manifest.typedContent?.connectModules) {
            validationErrors.push({
                message: text_1.errors.schemaError(undefined, [], text_1.errors.schema.oneOf([['modules'], ['connectModules']])),
                reference: text_1.References.SchemaError,
                level: 'error',
                line: 1,
                column: 0
            });
        }
        return validationErrors;
    }
    functionKeyDefinedValidation(modules, yamlContentByLine) {
        const validationErrors = [];
        const validModules = Object.keys(modules).filter((moduleKey) => this.isNotFunctionOrEndpoint(moduleKey));
        validModules.forEach((moduleKey) => {
            modules[moduleKey]?.forEach((module) => {
                (0, utils_1.findInvalidFunctionReferences)(module, modules.function).forEach((functionKey) => {
                    validationErrors.push({
                        message: text_1.errors.modules.wrongFunctionReference(moduleKey, functionKey),
                        reference: text_1.References.Modules,
                        level: 'error',
                        ...(0, utils_1.findPosition)(moduleKey, yamlContentByLine)
                    });
                });
                (0, utils_1.findInvalidEndpointReferences)(module, modules.endpoint).forEach((endpointKey) => {
                    validationErrors.push({
                        message: text_1.errors.modules.wrongEndpointReference(moduleKey, endpointKey),
                        reference: text_1.References.Modules,
                        level: 'error',
                        ...(0, utils_1.findPosition)(moduleKey, yamlContentByLine)
                    });
                });
            });
        });
        return validationErrors;
    }
    endpointValidations(modules, yamlContentByLine, remotes, scopes, services) {
        const validationErrors = [];
        const _checkRemoteExists = (remoteKey) => {
            return remotes?.find((remote) => remote.key === remoteKey) !== undefined;
        };
        const { endpoint: _endpoint } = modules;
        const eventModulesWithEndpoint = modules?.trigger?.filter((trigger) => trigger.endpoint != null) || [];
        eventModulesWithEndpoint.forEach((event) => {
            const endpointModule = _endpoint?.find((remoteEndpoint) => remoteEndpoint.key === event.endpoint);
            if (endpointModule) {
                if (endpointModule.auth?.appUserToken?.enabled) {
                    validationErrors.push({
                        message: text_1.errors.modules.trigger.endpointOnlySupportSystemToken(event.key, endpointModule.key),
                        reference: text_1.References.Modules,
                        level: 'error',
                        ...(0, utils_1.findPosition)(endpointModule.key, yamlContentByLine)
                    });
                }
                if (endpointModule.route === null || endpointModule.route === undefined) {
                    validationErrors.push({
                        message: text_1.errors.modules.trigger.endpointNeedsRoute(event.key, endpointModule.key),
                        reference: text_1.References.Modules,
                        level: 'error',
                        ...(0, utils_1.findPosition)(endpointModule.key, yamlContentByLine)
                    });
                }
            }
        });
        function isRemoteType(obj) {
            return obj && typeof obj === 'object' && 'remote' in obj;
        }
        function isServiceType(obj) {
            return obj && typeof obj === 'object' && 'service' in obj;
        }
        _endpoint?.forEach((endpoint) => {
            if (isRemoteType(endpoint)) {
                if (!_checkRemoteExists(endpoint.remote)) {
                    validationErrors.push({
                        message: text_1.errors.modules.endpoint.remote.notExists(endpoint.remote),
                        reference: text_1.References.Modules,
                        level: 'error',
                        ...(0, utils_1.findPosition)(endpoint.remote, yamlContentByLine)
                    });
                }
            }
            else if (isServiceType(endpoint)) {
                (0, utils_1.findInvalidServiceReferences)(endpoint, services).forEach((service) => {
                    validationErrors.push({
                        message: text_1.errors.modules.wrongServiceReference('endpoint', service),
                        reference: text_1.References.Modules,
                        level: 'error',
                        ...(0, utils_1.findPosition)('endpoint', yamlContentByLine)
                    });
                });
            }
        });
        return validationErrors;
    }
    duplicateModuleKeyValidation(modules, connectModules, yamlContentByLine) {
        const validationErrors = [];
        const moduleKeys = [];
        [modules, connectModules].forEach((modules) => {
            Object.values(modules).forEach((moduleList) => {
                if (Array.isArray(moduleList)) {
                    moduleList.forEach((module) => moduleKeys.push(module.key));
                }
            });
        });
        const duplicateKeys = [...new Set(moduleKeys.filter((item, index) => moduleKeys.indexOf(item) != index))];
        duplicateKeys.forEach((duplicateKey) => {
            validationErrors.push({
                message: text_1.errors.modules.duplicateKeyFound(duplicateKey),
                reference: text_1.References.Modules,
                level: 'error',
                ...(0, utils_1.findPosition)(duplicateKey, yamlContentByLine)
            });
        });
        return validationErrors;
    }
    functionHandlerValidation(modules, yamlContentByLine, filePath) {
        const validationErrors = [];
        modules.function?.forEach((func) => {
            if (!this.functionHandlerRegex.test(func.handler)) {
                validationErrors.push({
                    message: text_1.errors.modules.function.handler.invalidRegex(func.handler, this.functionHandlerRegex),
                    reference: text_1.References.Modules,
                    level: 'error',
                    ...(0, utils_1.findPosition)(func.handler, yamlContentByLine)
                });
            }
            else {
                const matches = this.functionHandlerRegex.exec(func.handler);
                const fileName = matches ? matches[1] : undefined;
                const _checkFileExists = (fileName) => {
                    return (['tsx', 'jsx', 'ts', 'js'].find((ext) => (0, fs_1.existsSync)((0, path_1.resolve)((0, path_1.dirname)(filePath), 'src', `${fileName}.${ext}`))) !== undefined);
                };
                if (!_checkFileExists(fileName)) {
                    validationErrors.push({
                        message: text_1.errors.modules.function.handler.fileNotExists(func.handler, fileName),
                        reference: text_1.References.Modules,
                        level: 'error',
                        ...(0, utils_1.findPosition)(func.handler, yamlContentByLine)
                    });
                }
            }
        });
        return validationErrors;
    }
}
exports.ModulesValidator = ModulesValidator;
