"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionsValidator = exports.PROTOCOL_BLOCKLIST = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("../utils");
const text_1 = require("../text");
const egress_types_1 = require("../types/egress-types");
const url_1 = require("url");
const shipyard_scopes_json_1 = tslib_1.__importDefault(require("../scopes/shipyard-scopes.json"));
const deprecated_shipyard_scopes_json_1 = tslib_1.__importDefault(require("../scopes/deprecated-shipyard-scopes.json"));
const scopes_1 = require("../utils/scopes");
const features_1 = require("../utils/features");
exports.PROTOCOL_BLOCKLIST = [
    'javascript:',
    'data:',
    'vbscript:',
    'view-source:',
    'resource:',
    'about:',
    'chrome:',
    'livescript:',
    'mocha:',
    'file:',
    'mhtml:',
    'smb:'
];
class PermissionsValidator {
    remotesHasValidEntryForKey(remoteMap, key) {
        return (remoteMap !== undefined &&
            remoteMap.has(key) &&
            (remoteMap.get(key) === null || this.isValidURL(remoteMap.get(key), false)));
    }
    isValidURL(inputURL, allowGlobalUrl) {
        const protocolRegex = /^(.*?:\/\/)/;
        const validURI = /^(\*\.)?[.a-zA-Z0-9_\-\/:~#%?=&]+$/;
        const allowedProtocols = ['https:', 'wss:'];
        const MAX_URL_LENGTH = 1000;
        if (inputURL.length > MAX_URL_LENGTH) {
            return false;
        }
        if (inputURL === egress_types_1.GLOBAL_URL) {
            return allowGlobalUrl;
        }
        const customURLSchemeRegex = /^[a-zA-Z]+:(\\\\)?/;
        if (customURLSchemeRegex.test(inputURL) &&
            ![...exports.PROTOCOL_BLOCKLIST, 'http'].some((protocol) => inputURL.startsWith(protocol)) &&
            !allowedProtocols.some((protocol) => inputURL.startsWith(protocol))) {
            return true;
        }
        if (!inputURL.includes('.') || inputURL.includes(' ')) {
            return false;
        }
        try {
            const domainOrUrlWithProtocol = protocolRegex.test(inputURL) ? inputURL : `https://${inputURL}`;
            const parsedUrl = new url_1.URL(domainOrUrlWithProtocol);
            if (!allowedProtocols.includes(parsedUrl.protocol)) {
                return false;
            }
            return validURI.test(parsedUrl.hostname);
        }
        catch (_) {
            return false;
        }
    }
    isValidHash(cspString) {
        const BASE_64_HASH_PATTERNS = [
            /^sha256-[a-zA-Z0-9=+/]{44}$/,
            /^sha384-[a-zA-Z0-9=+/]{64}$/,
            /^sha512-[a-zA-Z0-9=+/]{88}$/
        ];
        return BASE_64_HASH_PATTERNS.some((pattern) => pattern.test(cspString));
    }
    hasPathComponent(url) {
        try {
            const protocolRegex = /^(.*?:\/\/)/;
            const urlWithProtocol = protocolRegex.test(url) ? url : `https://${url}`;
            const parsedUrl = new url_1.URL(urlWithProtocol);
            const pathname = parsedUrl.pathname;
            return pathname.length > 0 && pathname !== '/';
        }
        catch {
            return false;
        }
    }
    addValidationErrors(result, element, values, manifest) {
        values.forEach((value) => {
            result.push({
                message: text_1.errors.permissions.invalidPermission(element, value),
                reference: text_1.References.Permissions,
                level: 'error',
                ...(0, utils_1.findPosition)(value, manifest.yamlContentByLine)
            });
        });
    }
    validateExternalPermissionURLs(result, extPermType, perms, manifest) {
        const invalidPerms = perms?.filter((key) => !this.isValidURL(key, true));
        if (invalidPerms?.length) {
            this.addValidationErrors(result, extPermType, invalidPerms, manifest);
        }
        const globalUrl = perms?.find((key) => key === egress_types_1.GLOBAL_URL);
        if (globalUrl) {
            result.push({
                message: text_1.errors.permissions.globalUrlNotRecommended(extPermType),
                reference: text_1.References.Permissions,
                level: 'warning',
                ...(0, utils_1.findPosition)(extPermType.split('.')[1], manifest.yamlContentByLine)
            });
        }
        if (['external.styles', 'external.fonts'].includes(extPermType) && perms?.length) {
            result.push({
                message: text_1.errors.permissions.fontAndStylesNotRecommended(extPermType),
                reference: text_1.References.Permissions,
                level: 'warning',
                ...(0, utils_1.findPosition)(extPermType.split('.')[1], manifest.yamlContentByLine)
            });
        }
        if (extPermType === 'external.images') {
            const invalidImageUrls = perms?.filter((key) => egress_types_1.AVATAR_URLS.includes(key));
            if (invalidImageUrls?.length) {
                invalidImageUrls.forEach((imageUrl) => {
                    result.push({
                        message: text_1.errors.permissions.imageUrlNotRecommended(extPermType, imageUrl),
                        reference: text_1.References.Permissions,
                        level: 'warning',
                        ...(0, utils_1.findPosition)(extPermType.split('.')[1], manifest.yamlContentByLine)
                    });
                });
            }
        }
        if (extPermType === 'external.fetch.backend') {
            const urlsWithPaths = perms?.filter((key) => this.hasPathComponent(key));
            if (urlsWithPaths?.length) {
                urlsWithPaths.forEach((url) => {
                    result.push({
                        message: text_1.errors.permissions.backendEgressPathIgnored(url),
                        reference: text_1.References.Permissions,
                        level: 'warning',
                        ...(0, utils_1.findPosition)(url, manifest.yamlContentByLine)
                    });
                });
            }
        }
    }
    async validate(manifest) {
        if (!manifest || !manifest.typedContent || !manifest.typedContent.permissions) {
            return {
                success: true,
                manifestObject: manifest
            };
        }
        const errors = [];
        const ALL_SCOPES = shipyard_scopes_json_1.default.concat(deprecated_shipyard_scopes_json_1.default);
        const invalidScopes = (0, scopes_1.getAllScopeKeys)(manifest.typedContent.permissions.scopes ?? []).filter((scope) => !ALL_SCOPES.includes(scope));
        if (invalidScopes?.length) {
            this.addValidationErrors(errors, 'scopes', invalidScopes, manifest);
        }
        const invalidScripts = manifest.typedContent.permissions.content?.scripts?.filter((key) => !egress_types_1.EGRESS_TYPES.ALLOWED_CSP_TYPES.includes(key) && !this.isValidHash(key));
        if (invalidScripts?.length) {
            this.addValidationErrors(errors, 'content.scripts', invalidScripts, manifest);
        }
        const mapping = [
            {
                element: 'external.fetch.backend',
                perms: manifest.typedContent.permissions.external?.fetch?.backend
                    ?.map((key) => {
                    if (typeof key === 'object' && 'address' in key) {
                        return key.address;
                    }
                    return key;
                })
                    .filter((key) => typeof key === 'string')
            },
            {
                element: 'external.fetch.client',
                perms: manifest.typedContent.permissions.external?.fetch?.client
                    ?.map((key) => {
                    if (typeof key === 'object' && 'address' in key) {
                        return key.address;
                    }
                    return key;
                })
                    .filter((key) => typeof key === 'string')
            },
            {
                element: 'external.navigation',
                perms: manifest.typedContent.permissions.external?.navigation?.map((key) => typeof key === 'object' ? key.address : key)
            },
            {
                element: 'external.styles',
                perms: manifest.typedContent.permissions.external?.styles?.map((key) => typeof key === 'object' ? key.address : key)
            },
            {
                element: 'external.frames',
                perms: manifest.typedContent.permissions.external?.frames?.map((key) => typeof key === 'object' ? key.address : key)
            },
            {
                element: 'external.fonts',
                perms: manifest.typedContent.permissions.external?.fonts?.map((key) => typeof key === 'object' ? key.address : key)
            },
            {
                element: 'external.images',
                perms: manifest.typedContent.permissions.external?.images?.map((key) => typeof key === 'object' ? key.address : key)
            },
            {
                element: 'external.media',
                perms: manifest.typedContent.permissions.external?.media?.map((key) => typeof key === 'object' ? key.address : key)
            },
            {
                element: 'external.scripts',
                perms: manifest.typedContent.permissions.external?.scripts?.map((key) => typeof key === 'object' ? key.address : key)
            }
        ];
        mapping.forEach((item) => this.validateExternalPermissionURLs(errors, item.element, item.perms, manifest));
        const { fetch: originalFetch, configurable: _configurable, ...restOfExternalPermissions } = manifest.typedContent.permissions.external || {};
        Object.entries(originalFetch || {}).forEach(([key, values]) => {
            if (values.some((value) => typeof value === 'string')) {
                errors.push({
                    message: text_1.errors.permissions.deprecatedEgressPermission(`fetch.${key}`),
                    reference: text_1.References.Permissions,
                    level: 'warning',
                    metadata: {
                        hasDeprecatedEgressPermissions: true
                    },
                    ...(0, utils_1.findPosition)(key, manifest.yamlContentByLine)
                });
            }
        });
        Object.entries(restOfExternalPermissions || {}).forEach(([key, values]) => {
            if (values.some((value) => typeof value === 'string')) {
                errors.push({
                    message: text_1.errors.permissions.deprecatedEgressPermission(key),
                    reference: text_1.References.Permissions,
                    level: 'warning',
                    metadata: {
                        hasDeprecatedEgressPermissions: true
                    },
                    ...(0, utils_1.findPosition)(key, manifest.yamlContentByLine)
                });
            }
        });
        const remoteMap = manifest.typedContent.remotes?.reduce((prev, item) => {
            if ((0, features_1.configurableRemotesEnabled)()) {
                if (item.baseUrl) {
                    const baseUrl = typeof item.baseUrl === 'string' ? item.baseUrl : item.baseUrl.default;
                    return prev.set(item.key, baseUrl);
                }
                if (!item.baseUrl && item.configurable) {
                    return prev.set(item.key, null);
                }
                return prev;
            }
            else {
                if (item.baseUrl !== undefined) {
                    const baseUrl = typeof item.baseUrl === 'string' ? item.baseUrl : item.baseUrl.default;
                    return prev.set(item.key, baseUrl);
                }
                else {
                    return prev;
                }
            }
        }, new Map());
        const invalidBackendRemotes = manifest.typedContent.permissions.external?.fetch?.backend
            ?.filter((item) => typeof item === 'object' && 'remote' in item && !this.remotesHasValidEntryForKey(remoteMap, item.remote))
            .map((item) => item.remote);
        if (invalidBackendRemotes?.length) {
            this.addValidationErrors(errors, 'external.fetch.backend', invalidBackendRemotes, manifest);
        }
        const invalidClientRemotes = manifest.typedContent.permissions.external?.fetch?.client
            ?.filter((item) => typeof item === 'object' && 'remote' in item && !this.remotesHasValidEntryForKey(remoteMap, item.remote))
            .map((item) => item.remote);
        if (invalidClientRemotes?.length) {
            this.addValidationErrors(errors, 'external.fetch.client', invalidClientRemotes, manifest);
        }
        return {
            success: errors.length === 0,
            errors
        };
    }
}
exports.PermissionsValidator = PermissionsValidator;
